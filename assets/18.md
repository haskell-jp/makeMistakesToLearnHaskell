# もっと簡潔に書く

課題16の回答を書き換えて、できるだけ簡潔に書いてみましょう。  
今回は純粋にリファクタリングをしてください。特に振る舞いを変える必要はありません。

## 必要な知識

Haskellには、コードを極めて簡潔に書くテクニックが、たくさんあります。この課題では、そうしたテクニックのうち、特によく使われるものを紹介します。みなさんがHaskellを書くときに必ずしもここで学習したことを使う必要はないですが、既存のHaskell製コードの中でも高確率で使われているので、是非習得してください。

### （カリー化された）関数の部分適用

まずは、関数の部分適用という手法を知ることで、適度に関数の定義を書かずに済ますテクニックのほか、Haskellにおける関数`->`の秘密も知りましょう。

まずは一例として、`map`関数の型定義を思い出してください:

```haskell
ghci> :t map
map :: (a -> b) -> [a] -> [b]
```

関数`(a -> b)`とリスト`[a]`という、二つの引数を受け取るようになっていますね。

```haskell
ghci> map (\x -> x * 2) [3, 8, 9]
[6,16,18]
```

ではこれに一つ目の引数である、関数`(a -> b)`のみを適用するとどうなるでしょうか:

```haskell
ghci> map (\x -> x * 2)

<interactive>:5:1: error:
    ? No instance for (Show ([Integer] -> [Integer]))
        arising from a use of ‘print’
        (maybe you haven't applied a function to enough arguments?)
    ? In a stmt of an interactive GHCi command: print it
```

案の定エラーになりました。`No instance for (Show ([Integer] -> [Integer]))`という行で始まるこのエラーは、「整数のリストを受け取って整数のリストを返す関数`[Integer] -> [Integer]`は、`Show`型クラスのインスタンスではない」という意味の型エラーです。GHCiは入力したHaskellの式を評価した後、結果を`print`関数で表示するので、評価した結果の値は`Show`型クラスのインスタンスでなければならないのでした。

ここからが本題です。`No instance for (Show ([Integer] -> [Integer]))`における、「整数のリストを受け取って整数のリストを返す関数`[Integer] -> [Integer]`」という型の式とは、一体何のことでしょう？そう、入力した`map (\x -> x * 2)`のことです。`map (\x -> x * 2)`は、`[Integer] -> [Integer]`という型の値なのです！

毎度おなじみ`:t`コマンドでもチェックしてみましょう:

```haskell
ghci> :t map (\x -> x * 2)
map (\x -> x * 2) :: Num b => [b] -> [b]
```

`map (\x -> x * 2)`の型は、`Num b => [b] -> [b]`、すなわち`Num`型クラスのインスタンスである型`b`（数値型）の値のリストを受け取って、同じく`b`のリストを返す関数だそうです。先ほど型エラーが発生した際は`[Integer] -> [Integer]`と言っていたのに、食い違ってますね。これは課題hoge(7?)で解説した、`Num`型クラスの「デフォルトの型」が採用された結果です。`Num`型クラスにはデフォルトの型として`Integer`型（整数型）が設定されているので、GHCiが式を評価しようとしたけど`Num`型クラスの型が決まらなかった、という場合は`Integer`が使用されるのです。

いずれにしても、`Integer`型クラスは`Num`型クラスのインスタンスなので、`map (\x -> x * 2)`に`[Integer]`型、すなわち整数のリストを渡せば、`[Integer]`、整数のリストが返ってくるはずです。試しに渡してみましょう！

```haskell
ghci> doubles = map (\x -> x * 2)
ghci> doubles [3, 8, 9]
[6,16,18]
```

`map (\x -> x * 2) [3, 8, 9]`と同じ結果が返りました！

なぜこのような振る舞いになるのでしょうか？その秘密は、Haskellにおける関数型の、ある特徴にあります。次のような、「`a`という型の値と`b`という型の値を受け取って`c`という型の値を返す関数を例にしましょう:

```haskell
a -> b -> c
```

このように2つ（以上）の引数を受け取る関数型に、カッコを補うと、実はHaskellは次のように解釈していることがわかります:

```haskell
a -> (b -> c)
```

上記のように、`a -> (b -> c)`は、`a`という型の値を一つ受け取って、`(b -> c)`という型の関数を返す関数です。`a`型の値を1つ受け取ることによって、

```haskell
(b -> c)
```

という、引数を（残り）一つ受け取る関数になるのです。

Haskellには、厳密な意味では「一つの引数を受け取って一つの値を返す関数」しか存在しません。`a -> b -> c`のように、2つ以上の引数を受け取るよう振る舞う関数は、「関数を返す関数」を組み合わせることによって表現されます。

注意⚠️ Haskellには厳密には「一つの引数を受け取って一つの値を返す関数」しかないと申しましたが、実際に`a -> b -> c`のような関数について話す時は「この関数は二つの引数を受け取る」といった表現を普通に使用します。本入門のこれ以降でも用いる予定ですので「Haskellには一つの引数を受け取る関数しかないのだから～」などとはいちいち考えなくて結構です。

この特徴を利用すると、余計なラムダ抽象を書かずに済ませたり、引数の名前を考えずに済ませたりすることができます。

例えば「文字列のリストにおける、すべての文字を大文字にする」という処理を次↓のように書いていたとします:

```haskell
ghci> import Data.Char

ghci> map (\s -> map toUpper s) ["hello", "world!"]
["HELLO","WORLD!"]
```

こちらの`(\s -> map toUpper s)`は、「`map`関数に`toUpper`関数を渡して作った関数」に引数`s`を渡しているだけの関数なので、次↓のように書き換えることができます:

```haskell
ghci> map (map toUpper) ["hello", "world!"]
["HELLO","WORLD!"]
```

このように、`a -> b -> c`といった型の複数の引数を受け取る関数から、最初のいくつかの引数だけを適用した新しい関数を作ることを「部分適用」と言います。Haskellでは部分適用を利用することで、一つの関数から簡単に新しい関数を作ることができます。

ところで、ここで一つ思い出していただきたいことがあります。例えば`map`関数のように、これまで紹介した「関数を受け取る関数」はこんな型でした:

```haskell
ghci> :t map
map :: (a -> b) -> [a] -> [b]
```

もしこの`(a -> b) -> [a] -> [b]`の`(a -> b)`からカッコを取り除いて、

```haskell
map :: a -> b -> [a] -> [b]
```

という型にしたら、どのような意味になるのでしょうか？

実は`a -> b -> [a] -> [b]`という型の関数にしたら「`a`型の値、`b`型の値、`[a]`型の値という**三つの**引数を受け取り、`[b]`型の値を返す関数」という意味になってしまいます。Haskellには厳密な意味では「一つの引数を受け取る関数」しかないのでそれに則って言い換えると「`a`型の値を受け取って『`b`型の値を受け取って《`[a]`型の値を受け取って`[b]`型の値を返す関数》』を返す関数」を返す関数」です。つまりカッコを補って書き換えると、こんな関数になっているものと解釈されます:

```haskell
map :: a -> (b -> ([a] -> [b]))
```

関数を表す`->`という型は、右結合（同じ優先順位の演算子を複数並べたとき、右辺に書かれた式が優先して結合される）なので、カッコを書くことで初めて「関数を受け取る関数」として宣言できるようになっています。カッコを書き忘れると上記のように思いの外引数の多い関数になってしまいますので、ご注意ください。

### `:t` で演算子の型定義も調べる・演算子を普通の関数のように前置記法で記述する

次のテクニックを学ぶ前に、これまで触れてこなかった、演算子の型定義をチェックする方法について紹介させてください。Haskellでは、`map`や`putStrLn`といった普通の関数に加えて、`+`や`&&`などの「演算子」も普通の関数と全く同じように扱えるようになっています。普通の関数が`map f [1, 2, 3]`といった具合に**引数を関数の後に書く（前置記法で記述する）**のに対して、`*`や`&&`は`1 + 4`、`True && False`といったように、**引数を関数の左右に書く（中置記法で記述する）**関数だと捉えてください。

普通の関数は前置記法で書き、演算子は中値記法で書く、という違いから、Haskellの構文における取り扱い、すなわちGHCがHaskellのソースコードを読んで解釈する時の扱いも異なります。そのため、例えば次のように`:t`コマンドを直接演算子に使用しても、エラーになってしまいます:

```haskell
ghci> :t &&

<interactive>:1:1: error: parse error on input ‘&&’
```

これを直すには`&&`をカッコ`()`で囲います:

```haskell
ghci> :t (&&)
(&&) :: Bool -> Bool -> Bool
```

`&&`演算子は左辺と右辺に`Bool`型の値をとって`Bool`型の値を返すので、`Bool -> Bool -> Bool`、すなわち`Bool`型の値を二つ受け取って`Bool`型の値を返す関数なのです。

これは、課題hoge(16?)で`!`という演算子を`import`する際、

```haskell
import Data.Map.Strict ((!))
```

と、カッコで囲っていたのと同じことです。`!`という名前の演算子を普通の関数と同じように`import`するには、カッコ`()`で囲う必要があるのです。

以上から察せられるでしょうか？実はHaskellにおける演算子は、カッコ`()`で囲うことによって、普通の関数 --- 厳密には関数を始めとする変数の名前である「識別子」 --- と同じように扱われるようになります。

なので、ここまで紹介した`:t`や`import`に限らず、普通の識別子が書けるほとんどあらゆる場面において、カッコで囲った演算子を使用できます:

```haskell
-- 例えば、普通の関数と同様前置関数（の識別子）として扱ったり、
ghci> (+) 7 4
11

-- そのまま変数の識別子として、値を代入したりできます！
ghci> (+) = "+ 演算子と同じ見た目だけど中にあるのは文字列"

-- もちろん、変数なので他の関数に渡すことも！
ghci> putStrLn (+)
+ 演算子と同じ見た目だけど中にあるのは文字列
```

更に、前節で紹介した「Haskellにおける関数はカリー化されている」という特徴を思い出してください。「2つ以上の引数を受け取るよう振る舞う関数は、「関数を返す関数」を組み合わせることによって表現」されるという事実は、演算子にも適用されます:

```haskell
-- (+) という関数に 4 を渡すと、
ghci> plus4 = (+) 4
-- 4 を足す関数が返ってくる。
ghci> plus4 3
7
-- 4 + 3 と同じ

-- (-) という関数に 10 を渡すと、
ghci> subtractFrom10 = (-) 10
-- 10 から何かを引く関数が返ってくる。
ghci> subtractFrom10 4
6
-- 10 - 4 と同じ
```

この特徴を利用すると、次の`(\x -> 100 * x)`ように、演算子を一度使うためだけにラムダ抽象を書く必要がなくなります:

```haskell
-- ↓のように書いていたのを...
ghci> map (\x -> 100 * x) [1, 2, 3]
[100,200,300]

-- ↓のように書き換えることができる！
ghci> map ((*) 100) [1, 2, 3]
[100,200,300]
```

### 関数適用演算子`$`でカッコを減らす

続いて紹介するのは、`$`という演算子です。`$`を使うことで、関数呼び出しの際使用するカッコを減らすことができます。

`$`は演算子なので、先程紹介した通り`:t`コマンドで型定義を見るにはカッコで囲って`($)`と書いてください:

```haskell
ghci> :t ($)
($) :: (a -> b) -> a -> b
```

第1引数（演算子なのでまたの名を右辺）には関数`(a -> b)`を、第2引数にあたる左辺には`a`型の値を渡します。名前が同じ型引数は必ず同じ型を表す、というルールがあるので、右辺の関数`(a -> b)`における引数`a`と、左辺の引数`a`は同じ型となります。そして`(a -> b)`型の値と`a`型の値を受け取ると、`$`は結果として`b`型の値を返します。この`b`型は右辺の関数`(a -> b)`における`b`、つまり戻り値の型と同じです。まとめると、`$`は関数を一つと、その関数の引数を受け取り、その関数が返す結果の型と同じ型の値を返します。

文章での説明だと分かりづらいので、実際に使ってみましょう。左辺に関数と、右辺にその関数の引数を渡せば使えるんでしたね。であれば例えば次のように使えるはずです:

```haskell
ghci> words $ "abc def"
["abc","def"]

ghci> putStrLn $ "Hello, world!"
Hello, world!

ghci> show $ [1, 2, 3]
"[1,2,3]"
```

三つ例を挙げてみました。特にエラーにならず、ちゃんと使えているようですね。では実行した結果はいかがでしょうか...？

実は上記の場合、`$`と書いても書かなくても何も変わりません！

```haskell
ghci> words "abc def"
["abc","def"]

ghci> putStrLn "Hello, world!"
Hello, world!

ghci> show [1, 2, 3]
"[1,2,3]"
```

`$`という演算子は、左辺に渡した関数に、右辺に渡した引数を渡して実行し、その結果を返す、ただそれだけの演算子なのです。一体それが何の役に立つのでしょうか？それを知るためには、GHCiの`:i`というコマンドを使うのが分かりやすいです。

#### `:i`コマンドで、演算子の結合の優先順位を確認する

※おことわり: 「結合の優先順位」については後ほど説明します。

GHCiの`:i`コマンド（`:info`の略）は、指定した識別子（変数などの名前）の型だけでなく、識別子が表すものの種類に応じて、便利な情報を色々教えてくれます。例えば件の`$`といった演算子の場合、演算子の結合の優先順位まで教えてくれます:

```haskell
ghci> :i ($)
($) :: (a -> b) -> a -> b       -- Defined in ‘GHC.Base’
infixr 0 $
```

最後の行にある`infixr 0 $`という箇所が、演算子の優先順位を表しています。`infixr`というキーワードが、`$`演算子が右結合の演算子であることを示します（左結合の場合は`infixl`と書かれます）。`infixr`に続いて書かれている`0`という数字が、結合の優先順位を示しています。`0`から`9`までの数字を書けるようになっていまして、数字が大きければ大きいほど、結合の優先順位が高くなります。つまり、`infixr 0`である`$`演算子は「右結合の演算子で、最も結合の優先順位が低い」と定義されています。

他の演算子とも比べてみましょう。

```haskell
ghci> :i (+)
-- ... 省略 ...
infixl 6 +

ghci> :i (-)
-- ... 省略 ...
infixl 6 -

ghci> :i (*)
-- ... 省略 ...
infixl 7 *

ghci> :i (/)
-- ... 省略 ...
infixl 7 /
```

足し算`(+)`引き算`(-)`よりかけ算`(*)`割り算`(/)`の方が優先順位が高く、左結合になっていることがわかります。いずれにしても`infixr 0 $`よりは結合の優先順位が高いようですね。

さて、ここまで「演算子の結合の優先順位」という言葉を何の説明もなく使用しました。他の多くのプログラミング言語にもある概念ではありますが、普段あまり意識しないかと思いますので、ここで説明しておきましょう。

「演算子の結合の優先順位」は、例えば次のような、演算子を複数使った式をイメージすると説明しやすいです:

```haskell
1 + 2 * 3
```

よく知られている数学の慣習上、かけ算は足し算より先に計算するので、`2 * 3`の結果`6`を`1`に足して`7`と計算するのが一般的でしょう。Haskellにも同様の解釈をしてもらうためには、`+`演算子よりも`*`演算子の結合の優先順位を**高く**して、`1 + 2`よりも先に`2 * 3`を処理してもらわなければなりません。このように、**演算子とその引数を複数並べたとき、どのような順番で処理するかを定めたルール**が「演算子の結合の優先順位」です。

先ほど`:i`で調べたとおり、Haskellでは足し算の演算子`+`や引き算の演算子`-`よりも、かけ算の演算子`*`や割り算の演算子`/`の方が優先順位が高いことになっています。ちゃんと数学の慣習に従っていますね。

それから、「右結合」と「左結合」という用語にも触れておきましょう。これまで調べた四則演算の演算子はいずれも「左結合」でした。というわけで恐らくより身近であろう「左結合」から説明します。

「左結合」の演算子は、同じ演算子（より正確には、同じ優先順位の演算子）を複数並べたとき、左側の演算子を先に計算するよう定められています。典型的には、引き算を複数使った次の式を思い浮かべてみると分かりやすいでしょう:

```
10 - 5 - 4
```

みなさんはこのような式を計算するときは、必ず次のように左側の`10 - 5`から順に計算するでしょう:

```
10 - 5 - 4
   ↓
   5 - 4
     ↓
     1
```

これを仮に右側の`5 - 4`から計算した場合、結果が意図しないものになってしまいます:

```
10 - 5 - 4
       ↓
     5 - 4
     ↓
10 - 1
   ↓
   9
```

これでは困るので、四則演算の演算子（`+`・`-`・`*`・`/`）は、同じ（優先順位の）ものを複数並べた場合、左側のものから先に計算するよう定められています。これが「左結合」です。

Haskellにはこれまで挙げた四則演算の演算子（`+`・`-`・`*`・`/`）以外にもたくさんの演算子があり、そのいずれも結合の優先順位や、右結合か左結合かが定められています。`$`もその一つで、最も結合の優先順位が低い、右結合の演算子として設定されていることは、先ほど説明しました。一体どうしてこのように設定されているのでしょうか？

それは、関数呼び出しの結合を他の演算子より弱めることで、他の演算子と関数を併せて使った際に、他の演算子を優先して結合させることで、カッコで囲う必要を減らせることです。

例えば、次のように`+`演算子で計算した結果を`print`関数に渡すとします:

```haskell
ghci> print (1 + 2 + 3)
6
```

こちらのコードでは、`1 + 2 + 3`を必ずカッコで囲わなければなりません。次のようにカッコを省略すると、型エラーになってしまいます:

```haskell
ghci> :{
ghci| print 1 + 2 + 3
ghci| :}

<interactive>:2:13: error:
    ? No instance for (Num (IO ())) arising from a use of ‘+’
    ? In the expression: print 1 + 2 + 3
      In an equation for ‘it’: it = print 1 + 2 + 3
```

このエラーは、`IO ()`という型の値は（`Num`型クラスのインスタンスではないので）`+`演算子が利用できない、という意味です。`IO ()`という型はまさしく`print 1`の結果の型です。すなわち`print 1 + 2 + 3`という式は、`1 + 2 + 3`よりも前に`print 1`を計算する式だと解釈されたのです。

このように解釈されるのは、Haskellでは関数呼び出しが最も強く結合するように定められているからです。`print 1`と書いたら、隣に`+ 3`があろうと`* 4`があろうとその他どんな中値記法の演算子があろうと、関数呼び出しである`print 1`が最優先されます[^1]。

[^1]: ユーザーが定義できる演算子ではない、Haskellの構文として定義されている演算子については例外があります。

一方`$`演算子は、普通の関数呼び出しは愚か、その他のほとんどの演算子より弱く結合するよう設定されているので、利用すれば次のようにカッコを省略して書くことができます:

```haskell
ghci> print $ 1 + 2 + 3
6
```

その他にも、次👇のように`++`演算子で文字列を結合した結果を`putStrLn`関数に渡す場合:

```haskell
ghci> putStrLn ("aaa" ++ show 111)
aaa111
```

これも`$`演算子を使ってカッコを省略できます:

```haskell
ghci> putStrLn $ "aaa" ++ show 111
aaa111
```

課題4で書いていた次の式👇も、

```haskell
ghci> unlines (reverse (lines "aaa\nbbb\nccc"))
"ccc\nbbb\naaa\n"
```

このように`$`を使ってカッコをゼロにできます:

```haskell
ghci> unlines $ reverse $ lines "aaa\nbbb\nccc"
"ccc\nbbb\naaa\n"
```

要するに「`$`よりも後ろはカッコが自動で補われる」と解釈すると良いでしょう。

ただし、👇のように`$`よりも結合の優先順位が高い演算子が左側にある場合はうまく行きません:

```haskell
ghci> "aaa" ++ show $ 1 + 110

<interactive>:9:1: error:
    ? Couldn't match expected type ‘Integer -> t’
                  with actual type ‘[Char]’
    ? The first argument of ($) takes one argument,
      but its type ‘[Char]’ has none
      In the expression: "aaa" ++ show $ 1 + 110
      In an equation for ‘it’: it = "aaa" ++ show $ 1 + 110
    ? Relevant bindings include it :: t (bound at <interactive>:9:1)

<interactive>:9:10: error:
    ? Couldn't match expected type ‘[Char]’
                  with actual type ‘() -> String’
    ? Probable cause: ‘show’ is applied to too few arguments
      In the second argument of ‘(++)’, namely ‘show’
      In the expression: "aaa" ++ show
      In the expression: "aaa" ++ show $ 1 + 110
```

これは、`$`の左辺に`"aaa" ++ show`を、右辺に`1 * 110`を渡した、と解釈されたことによる型エラーです。`$`よりも`++`の方が結合の優先順位が高いので、`"aaa" ++ show`を先に計算する、と解釈されたのです。

分かりやすくするためにカッコを補うと、次のとおりです:

```haskell
("aaa" ++ show) $ (1 + 110)
```

このように`$`よりも結合の優先順位が高い演算子が左側にある場合は、`$`を使ってカッコを省略することはできません。このような場合は、`$`を使わずにカッコを書く方がお勧めです:

```haskell
ghci> "aaa" ++ show (1 + 110)
"aaa111"
```

しかし、「`$`より左側に優先順位の高い他の演算子がある場合は`$`が上手く機能しない」ということを理解していても、前述のようなミスをしてしまうことはよくあります。そんなときは、私がこれまでの経験で得た、次のようなコツを思い出してみるといいかもしれません:

- 演算子の結合の優先順位を間違えたケースでは、先ほどのように型エラーが波及するので、複数の型エラーが同じ箇所で発生することが多い
    - よくわからない型エラーが同じ箇所で複数でてきた場合は、演算子の優先順位を間違えたことを疑うといいかもしれない
- `expected type`か`actual type`のどちらか一方が関数になっているけど、もう片方が関数じゃない時（あるいは、引数の数がそれぞれで異なる）場合も疑うといいかも知れない
- これ以外にも同じような型エラーになることはあるが、いずれにしても、単純な間違いを一つ犯しているだけである場合が多いので、**型エラーがたくさん出ても慌てない**ことが大事

### 関数合成演算子`.`で一番右の変数を消す

今度は、前節で紹介した関数適用演算子`$`と同じくらいよく使用される、関数合成演算子`.`を紹介します。何はともあれ`:t`コマンドで型定義を見てみましょう:

```haskell
ghci> :t (.)
(.) :: (b -> c) -> (a -> b) -> a -> c
```

`.`は`(b -> c)`・`(a -> b)`という型の、二つの関数を両辺に受け取ります。ところがそれだけでなく、右辺の関数の引数と同じ型`a`の値まで受け取って初めて、左辺の関数の結果と同じ`c`型の値を返すようです。...おかしいですね、演算子は左辺と右辺にしか値を受け取らないので引数は二つまでのはずでは...？

この謎の正体は、`.`を「関数を返す関数」として解釈することで明らかになります。すなわち、`.`は`(b -> c)`・`(a -> b)`という型の二つの関数を受け取った結果、`a -> c`という型の関数を返す演算子と捉えてみてください。`a -> c`を`.`が返す一つの関数としてカッコを補うと、`.`の型は次のように表されます:

```haskell
(.) :: (b -> c) -> (a -> b) -> (a -> c)
```

これで、`.`が「関数を返す関数」であることが分かりました。では、どのような関数を返すのでしょうか？実際に使って確かめてみましょう。簡単な例として、`show`関数と`length`関数を`.`に渡してみます:

```haskell
ghci> :t length . words
length . words :: String -> Int
```

`String -> Int`、すなわち文字列を受け取って整数を返す関数ができました。試しに使ってみましょう:

```haskell
ghci> length . words "aaa bbb ccc"

<interactive>:7:10: error:
    ? Couldn't match expected type: a -> t0 a0
                  with actual type: [String]
    ? Possible cause: ‘words’ is applied to too many arguments
      In the second argument of ‘(.)’, namely ‘words "aaa bbb ccc"’
      In the expression: length . words "aaa bbb ccc"
      In an equation for ‘it’: it = length . words "aaa bbb ccc"
    ? Relevant bindings include
        it :: a -> Int (bound at <interactive>:7:1)
```

... おっと、型エラーになってしまいました。`$`演算子の節で触れた通り、Haskellでは関数がどんな演算子よりも優先して結合されるので、`length . words "aaa bbb ccc"`という式は`words "aaa bbb ccc"`を最優先して計算してしまいます。`words "aaa bbb ccc"`は当然関数を返さないので、`.`で合成することができません！

従って、`length . words`をカッコで囲ってあげましょう:

```haskell
ghci> (length . words) "aaa bbb ccc"
3
```

できました。`3`という結果ですね。これは、`"aaa bbb ccc"`という文字列を`words`関数で単語のリストに分割し、その結果を`length`関数に渡してリストの長さを数えた結果です。すなわち、`.`によってできた`(length . words)`という関数は、引数を`words`関数に渡してその結果を`length`関数に渡す、`words`関数と`length`関数を繋いだ関数なのです。

一般化すると、`.`は両辺に関数を受け取り、新しい関数を作ります。この新しい関数は、右辺に渡した関数の引数を右辺の関数に渡し、右辺の関数の結果を左辺の関数に渡します。そして左辺の関数の結果を返す --- という流れで振る舞います。`.`は、左辺の関数と右辺の関数を繋ぐ演算子なのです。関数を「合成する」演算子だとも言われます。

`.`演算子を利用すると、二つの関数を使った`f (g x)`のような形の式を、`f . g`という形に書き換えることができます。`(g x)`にあったカッコや`x`という変数がなくなって、スッキリしますね。

これを応用すれば、例えば次のように`map`関数に渡す関数を作る際、ラムダ抽象やその引数`s`を書かずに済みます:

```haskell
map (\s -> show (length s)) ["aaa", "bb", "c"]
--  ^^^^^^^^^^^^^^^^^^^^^^^
--  この部分のラムダ抽象を...

map (show . length)         ["aaa", "bb", "c"]
--  ^^^^^^^^^^^^^^^
--  `.`を使って短くできました！
```

あるいは、関数定義を書く際にも利用できます。次のケースは、前節で紹介した`$`演算子を使って定義した関数です:

```haskell
reverseLines input = unlines $ reverse $ lines input
```

既にカッコを省略できていて簡潔ですが、実は`.`を使えばもっと簡潔に書くことができます:

```haskell
reverseLines = unlines . reverse . lines
```

引数`input`まで消えてより短くなりました！このように`.`は、一番右の変数を削除するのによく用いられます。

### 演算子のセクション

```
ghci> :t (/ 2)
(/ 2) :: Fractional a => a -> a
```

「半分にする関数」ができる！

```
ghci> (/ 2) 10
5.0
```

先頭に`"Hello, "`をくっつける関数

```
ghci> :t (++)
(++) :: [a] -> [a] -> [a]

ghci> :t ("Hello, " ++)
("Hello, " ++) :: [Char] -> [Char]

ghci> map ("Hello, " ++) ["Tom", "Bob", "Alice"]
["Hello, Tom","Hello, Bob","Hello, Alice"]
```

さっきの「演算子を前置関数に変換する」で紹介した

```
ghci> map ((+) 4) [1, 2, 3]
[5,6,7]
```

も、

```
ghci> map (+ 4) [1, 2, 3]
[5,6,7]
```

と書いていいし、足し算は右辺と左辺を入れ替えても結果が変わらないので、

```
ghci> map (4 +) [1, 2, 3]
[5,6,7]
```

と書いてもよい！

#### 演算子のセクションは、マイナスだけは使いにくい

```
ghci> :t (- 4)
(- 4) :: Num a => a
```

↑関数じゃない、「-4」という数！

```
ghci> :t (4 -)
(4 -) :: Num a => a -> a
```

↑こちらは関数

```
ghci> (- 4) 4

<interactive>:135:1: error:
    ? Non type-variable argument in the constraint: Num (t1 -> t2)
      (Use FlexibleContexts to permit this)
    ? When checking the inferred type
        it :: forall t1 t2. (Num t1, Num (t1 -> t2)) => t2

ghci> (4 -) 4
0
```

```
ghci> 5 * -3

<interactive>:145:1: error:
    Precedence parsing error
        cannot mix ‘*’ [infixl 7] and prefix `-' [infixl 6] in the same infix expression
ghci> 5 * (-3)
-15
```

単項演算子と二項演算子を混ぜたことによるエラー。  
Haskellではマイナス記号が唯一の単項演算子でもあり、普通の二項演算子でもある（[Haskell 2010 Language Reportの「Operator Applications」より][2]）。

[2]: https://www.haskell.org/onlinereport/haskell2010/haskellch3.html#x8-280003.4

### やり過ぎ注意、あるいはどこまでやるか

hoge: ポイントフリースタイルについてここで説明

例1: `yes`や`Yes`や`yEs`などを探す

前提: `filter`関数。第一引数が`True`を返した要素だけのリストを返す

```
ghci> :t filter
filter :: (a -> Bool) -> [a] -> [a]

-- 3より大きい数
ghci> filter (\x -> x > 3) [4, 3, 6]
[4,6]

-- 当然、第一引数の関数はラムダ抽象の代わりにセクションで書けるので
ghci> filter (> 3) [4, 3, 6]
[4,6]
```

```
ghci> import Data.Char

-- 大文字にすると「YES」になる文字列だけを返す
ghci> filter (\str -> map toUpper str == "YES") ["no", "yes", "yES", "iie", "YES"]
["yes","yES","YES"]
```

「`toUpper`した結果が`"YES"`と等しい」

```
ghci> filter ((== "YES") . map toUpper) ["no", "yes", "yES", "iie", "YES"]
["yes","yES","YES"]
```

このくらいなら序の口？

さっきの、

```
ghci> map ("Hello, " ++) ["Tom", "Bob", "Alice"]
["Hello, Tom","Hello, Bob","Hello, Alice"]
```

に、末尾に「!」を加えたくなったとする。

```
ghci> map (("Hello, " ++) . (++ "!")) ["Tom", "Bob", "Alice"]
["Hello, Tom!","Hello, Bob!","Hello, Alice!"]
```

さらにさらに、どんどんポイントフリースタイルにすると、読みにくくなってしまう例が: [ポイントフリースタイルへの道 〜最大公約数編〜 - Qiita][3]  
これまでの課題で紹介していない機能も利用していますが参考までにどうぞ。  
大事なことは、[**短く書ける人を上級者と呼ぶな**][4]ということです。

[3]: https://qiita.com/necojackarc/items/1bccc9643857d3ce7896
[4]: https://wiki.haskell.jp/Hikers%20Guide%20to%20Haskell#%E3%83%9D%E3%82%A4%E3%83%B3%E3%83%88%E3%83%95%E3%83%AA%E3%83%BC%E3%82%B9%E3%82%BF%E3%82%A4%E3%83%AB%E3%81%82%E3%82%8B%E3%81%84%E3%81%AF%E6%A7%98%E3%80%85%E3%81%AA%E3%82%B9%E3%82%BF%E3%82%A4%E3%83%AB%E3%81%A8%E3%81%AE%E4%BB%98%E3%81%8D%E5%90%88%E3%81%84%E6%96%B9

### ラムダ抽象や関数の引数でのパターンマッチ

関数の引数で直接パターンマッチできる

課題11の`doubles`関数、数値のリストを受け取ってすべての要素を2倍にする関数の再実装

```haskell
doubles xs =
    case xs of
        [] -> []
        x : xsLeft -> x * 2 : doubles xsLeft
```

第1引数`xs`は直ちに`case`式で使われている！  
こんな時はこう書き換えられる:

```haskell
doubles [] = []
doubles (x : xsLeft) = x * 2 : doubles xsLeft
```

`->`の代わりに`=`でパターンとその定義を区切っている点と、`(x : xsLeft)`のように、パターン全体を**カッコで囲う**必要がある点に注意。

カッコで囲う必要があるのは、関数定義では複数の引数を扱うことがあるため。  
例えば`doubles`関数に引数を増やして、引数で指定した数以外を掛けられるようにした場合:

```haskell
times n [] = []
times n (x : xsLeft) = x * n : times n xsLeft
```

`times n (x : xsLeft) = ...`の`(x : xsLeft)`からカッコを外してしまうと、

```haskell
ghci> :{
ghci| times n [] = []
ghci| times n x : xsLeft = x * n : times n xsLeft
ghci| :}

<interactive>:47:1: error: Parse error in pattern: times
```

となってしまい、`n`, `x`, `:`, `xsLeft`, という4つの引数を受け取るように見えてしまう。

おまけにかっこいい例: よく見かける（*でもすごく効率が悪い*）`n`番目のフィボナッチ数を計算する関数

```
fib n =
    case n of
        0 -> 0
        1 -> 1
        _ -> fib (n - 2) + fib (n - 1)
```

`case`で書くと↑のなのを、

```
fib 0 = 0
fib 1 = 1
fib n = fib (n - 2) + fib (n - 1)
```

と書き換えることができる。  
[元々のフィボナッチ数の定義][5]っぽくてかっこいい！  
（でもいずれにしても効率はすごく悪いのでくれぐれも使わないこと）

[5]: https://ja.wikipedia.org/wiki/%E3%83%95%E3%82%A3%E3%83%9C%E3%83%8A%E3%83%83%E3%83%81%E6%95%B0#%E6%A6%82%E8%A6%81

#### レコード型に対する関数の引数でのパターンマッチ

自分で定義した型でもOK！

※ここと次のタプルの節で紹介するパターンマッチは`case`式でも使えますが、特に引数でのパターンマッチで使うことが多いです。

例えばおなじみ`Entry`型を使って

```
data Entry =
  Entry { category :: String, price :: Integer }
  deriving Show
```

値コンストラクター`Entry`の第一引数にあたる`category`、第二引数にあたる`price`、それぞれにパターンマッチできる！

```
ghci> :{
ghci| formatEntry :: Entry -> String
ghci| formatEntry (Entry cat pri) = cat ++ ": " ++ show pri
ghci| :}

ghci> entry = Entry "Magazine" 120
ghci> formatEntry entry
"Magazine: 120"
```

パターンマッチは入れ子になった構造の中の要素に対してもできるので、さらに`category`が空文字列のものを特別扱いしたくなったら:

```
ghci> :{
ghci| formatEntry :: Entry -> String
ghci| formatEntry (Entry "" pri) = "<Unknown category>" ++ ": " ++ show pri
ghci| formatEntry (Entry cat pri) = cat ++ ": " ++ show pri
ghci| :}

ghci> entry = Entry "" 999999999999999
ghci> formatEntry entry
"<Unknown category>: 999999999999999"
```

ここでもカッコを忘れず！

```
ghci> :{
ghci| formatEntry :: Entry -> String
ghci| formatEntry Entry cat pri = cat ++ ": " ++ show pri
ghci| :}

<interactive>:89:13: error:
    ? The constructor ‘Entry’ should have 2 arguments, but has been given none
    ? In the pattern: Entry
      In an equation for ‘formatEntry’:
          formatEntry Entry cat pri = cat ++ ": " ++ show pri
      The equation(s) for ‘formatEntry’ have three arguments,
      but its type ‘Entry -> String’ has only one
```

こういう風にレコードラベルを用いたパターンマッチをすれば、フィールドの順番が違っていてもよい。

```
ghci> :{
ghci| formatEntry :: Entry -> String
ghci| formatEntry (Entry { category = "",  price = pri }) = "<Unknown category>" ++ ": " ++ show pri
ghci| formatEntry (Entry { category = cat, price = pri }) = cat ++ ": " ++ show pri
ghci| :}
```

#### タプルに対する関数の引数でのパターンマッチ

便利なサンプルが[`Prelude`モジュール][6]にいくつかある。  
以下はソースコードからの抜粋:

[6]: https://hackage.haskell.org/package/base-4.12.0.0/docs/Prelude.html#g:3

```
fst :: (a, b) -> a
fst (x, _) = x

snd :: (a, b) -> b
snd (_, y) = y
```

課題8で紹介したとおり、これらは`Prelude`モジュールに入っているので、何も`import`しなくても使える

おまけ: `curry`と`uncurry`

`curry`は「（サイズ2の）タプルを受け取る関数」を（Haskellの世界で普通の、カリー化された）2引数関数に変換する。

```
curry :: ((a, b) -> c) -> a -> b -> c
curry f x y = f (x, y)
```

`uncurry`はその逆。ここでタプルに対するパターンマッチが出てくる。

```
uncurry :: (a -> b -> c) -> ((a, b) -> c)
uncurry f (x, y) = f x y
```

おそらく`uncurry`の方が実践ではよく使う

典型的な使用例: `Map`方の値を`toList`関数で変換した結果を、そのまま2引数の関数に渡す

`(+)`を`uncurry`関数でタプルを受け取る関数に変換することで、`toList`結果の値をそのまま使える。

```
ghci> import qualified Data.Map.Strict as M

ghci> numberAndChars = M.fromList [(1, 3), (2, 4)]
ghci> map (uncurry (+)) $ M.toList numberAndChars
[4,6]
```

ラムダ抽象で書き換えると↓と同じ

```
ghci> map (\pair -> fst pair + snd pair) $ M.toList numberAndChars
[4,6]
```

#### ラムダ抽象の引数でのパターンマッチ

引数でのパターンマッチは、ラムダ抽象でも使える。

つまり、

```
tupleToEntry :: (String, Integer) -> Entry
tupleToEntry (cat, pri) = Entry cat pri
```

↑と↓は同じ！

```
tupleToEntry :: (String, Integer) -> Entry
tupleToEntry = \(cat, pri) -> Entry cat pri
```

課題8で↓のように書いていたのと実質同じようなもの。

```
-- ...
let (divResult, modResult) = divMod numerator denominator
-- ...
```

パターンマッチに関する話をまとめると

- 原則1: 値コンストラクターで値を組み立てるのと逆のことをするのがパターンマッチ。
    - リストには `[x, y]` という構文の、特別な値コンストラクターがある。本来は`x : y : []`。
- 原則2: 関数の引数を含めた、変数への代入を行うあらゆる場面でパターンマッチは使える。

でも、これは危ない！

```
ghci> dangerous = \(Just x) -> x
```

ラムダ抽象は

```
dangerous (Just x) = x
dangerous Nothing = "error!"
```

みたいに、関数定義の構文のように引数でパターンマッチしても場合分けができないので、

```
dangerous = \(Just x) -> x
```

みたいに書きたくなったら、↓のような`case`に変換するしかない（`LambdaCase`についてはいつか脚注に）。

```
dangerous = \mx ->
    case mx of
        Just x  -> ...
        Nothing -> ...
```

結果、うっかり`Nothing`が渡されてエラーになってしまうことも

```
ghci> dangerous Nothing
*** Exception: <interactive>:8:2-15: Non-exhaustive patterns in lambda
```

警告を有効にしても教えてくれない😱

```
ghci> :set -Wall
ghci> dangerous = (\(Just x) -> x)
```

`-Wincomplete-uni-patterns`を有効にしないといけない！

```
ghci> :set -Wincomplete-uni-patterns
ghci> dangerous = \(Just x) -> x

<interactive>:10:2: warning: [-Wincomplete-uni-patterns]
    Pattern match(es) are non-exhaustive
    In a lambda abstraction: Patterns not matched: Nothing
```

[GHCの将来のバージョンで、`-Wincomplete-uni-patterns`が`-Wall`に含まれる][7]かも。

[7]: https://gitlab.haskell.org/ghc/ghc/issues/15656

`-Wall`を有効にしても有効にならない警告の一覧は[GHC Users Guide][8]を参照。

<https://functor.tokyo/blog/2017-07-28-ghc-warnings-you-should-enable>

[8]: https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/using-warnings.html#ghc-flag--Wall

## HLintで改善点をある程度自動で見つける

```bash
shell> cabal install hlint
# あるいは...
shell> stack install hlint
```

ここで紹介していない`TupleSections`というGHCの拡張を使ったものも（GHCの拡張の話を後回しにしたいので敢えて紹介していません... あしからず）。

```bash
shell> hlint assets/16.hs
assets/16.hs:18:14: Warning: Avoid lambda
Found:
  \ x y -> x + y
Perhaps:
  (+)

assets/16.hs:19:19: Suggestion: Use tuple-section
Found:
  \ w -> (w, 1)
Perhaps:
  (, 1)
Note: may require `{-# LANGUAGE TupleSections #-}` adding to the top of the file

2 hints
```

HLintのさらに便利な使い方は[素晴らしき HLint を使いこなす][9]を。  
「この関数はこのモジュール以外では使わないでください」などというプロジェクト固有のルールを設定することもできます。

[9]: https://haskell.e-bigmoon.com/posts/2018-01-29-awesome-hlint.html
