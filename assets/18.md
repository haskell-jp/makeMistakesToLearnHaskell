# もっと簡潔に書く

課題16の回答を書き換えて、できるだけ簡潔に書いてみましょう。  
今回は純粋にリファクタリングをしてください。特に振る舞いを変える必要はありません。

## 必要な知識

Haskellには、コードを極めて簡潔に書くテクニックが、たくさんあります。この課題では、そうしたテクニックのうち、特によく使われるものを紹介します。みなさんがHaskellを書くときに必ずしもここで学習したことを使う必要はないですが、既存のHaskell製コードの中でも高確率で使われているので、是非習得してください。

### （カリー化された）関数の部分適用

まずは、関数の部分適用という手法を知ることで、適度に関数の定義を書かずに済ますテクニックのほか、Haskellにおける関数`->`の秘密も知りましょう。

まずは一例として、`map`関数の型定義を思い出してください:

```haskell
ghci> :t map
map :: (a -> b) -> [a] -> [b]
```

関数`(a -> b)`とリスト`[a]`という、二つの引数を受け取るようになっていますね。

```haskell
ghci> map (\x -> x * 2) [3, 8, 9]
[6,16,18]
```

ではこれに一つ目の引数である、関数`(a -> b)`のみを適用するとどうなるでしょうか:

```haskell
ghci> map (\x -> x * 2)

<interactive>:5:1: error:
    ? No instance for (Show ([Integer] -> [Integer]))
        arising from a use of ‘print’
        (maybe you haven't applied a function to enough arguments?)
    ? In a stmt of an interactive GHCi command: print it
```

案の定エラーになりました。`No instance for (Show ([Integer] -> [Integer]))`という行で始まるこのエラーは、「整数のリストを受け取って整数のリストを返す関数`[Integer] -> [Integer]`は、`Show`型クラスのインスタンスではない」という意味の型エラーです。GHCiは入力したHaskellの式を評価した後、結果を`print`関数で表示するので、評価した結果の値は`Show`型クラスのインスタンスでなければならないのでした。

ここからが本題です。`No instance for (Show ([Integer] -> [Integer]))`における、「整数のリストを受け取って整数のリストを返す関数`[Integer] -> [Integer]`」という型の式とは、一体何のことでしょう？そう、入力した`map (\x -> x * 2)`のことです。`map (\x -> x * 2)`は、`[Integer] -> [Integer]`という型の値なのです！

毎度おなじみ`:t`コマンドでもチェックしてみましょう:

```haskell
ghci> :t map (\x -> x * 2)
map (\x -> x * 2) :: Num b => [b] -> [b]
```

`map (\x -> x * 2)`の型は、`Num b => [b] -> [b]`、すなわち`Num`型クラスのインスタンスである型`b`（数値型）の値のリストを受け取って、同じく`b`のリストを返す関数だそうです。先ほど型エラーが発生した際は`[Integer] -> [Integer]`と言っていたのに、食い違ってますね。これは課題hoge(7?)で解説した、`Num`型クラスの「デフォルトの型」が採用された結果です。`Num`型クラスにはデフォルトの型として`Integer`型（整数型）が設定されているので、GHCiが式を評価しようとしたけど`Num`型クラスの型が決まらなかった、という場合は`Integer`が使用されるのです。

いずれにしても、`Integer`型クラスは`Num`型クラスのインスタンスなので、`map (\x -> x * 2)`に`[Integer]`型、すなわち整数のリストを渡せば、`[Integer]`、整数のリストが返ってくるはずです。試しに渡してみましょう！

```haskell
ghci> doubles = map (\x -> x * 2)
ghci> doubles [3, 8, 9]
[6,16,18]
```

`map (\x -> x * 2) [3, 8, 9]`と同じ結果が返りました！

なぜこのような振る舞いになるのでしょうか？その秘密は、Haskellにおける関数型の、ある特徴にあります。次のような、「`a`という型の値と`b`という型の値を受け取って`c`という型の値を返す関数を例にしましょう:

```haskell
a -> b -> c
```

このように2つ（以上）の引数を受け取る関数型に、カッコを補うと、実はHaskellは次のように解釈していることがわかります:

```haskell
a -> (b -> c)
```

上記のように、`a -> (b -> c)`は、`a`という型の値を一つ受け取って、`(b -> c)`という型の関数を返す関数です。`a`型の値を1つ受け取ることによって、

```haskell
(b -> c)
```

という、引数を（残り）一つ受け取る関数になるのです。

Haskellには、厳密な意味では「一つの引数を受け取って一つの値を返す関数」しか存在しません。`a -> b -> c`のように、2つ以上の引数を受け取るよう振る舞う関数は、「関数を返す関数」を組み合わせることによって表現されます。

注意⚠️ Haskellには厳密には「一つの引数を受け取って一つの値を返す関数」しかないと申しましたが、実際に`a -> b -> c`のような関数について話す時は「この関数は二つの引数を受け取る」といった表現を普通に使用します。本入門のこれ以降でも用いる予定ですので「Haskellには一つの引数を受け取る関数しかないのだから～」などとはいちいち考えなくて結構です。

この特徴を利用すると、余計なラムダ抽象を書かずに済ませたり、引数の名前を考えずに済ませたりすることができます。

例えば「文字列のリストにおける、すべての文字を大文字にする」という処理を次↓のように書いていたとします:

```haskell
ghci> import Data.Char

ghci> map (\s -> map toUpper s) ["hello", "world!"]
["HELLO","WORLD!"]
```

こちらの`(\s -> map toUpper s)`は、「`map`関数に`toUpper`関数を渡して作った関数」に引数`s`を渡しているだけの関数なので、次↓のように書き換えることができます:

```haskell
ghci> map (map toUpper) ["hello", "world!"]
["HELLO","WORLD!"]
```

このように、`a -> b -> c`といった型の複数の引数を受け取る関数から、最初のいくつかの引数だけを適用した新しい関数を作ることを「部分適用」と言います。Haskellでは部分適用を利用することで、一つの関数から簡単に新しい関数を作ることができます。

ところで、ここで一つ思い出していただきたいことがあります。例えば`map`関数のように、これまで紹介した「関数を受け取る関数」はこんな型でした:

```haskell
ghci> :t map
map :: (a -> b) -> [a] -> [b]
```

もしこの`(a -> b) -> [a] -> [b]`の`(a -> b)`からカッコを取り除いて、

```haskell
map :: a -> b -> [a] -> [b]
```

という型にしたら、どのような意味になるのでしょうか？

実は`a -> b -> [a] -> [b]`という型の関数にしたら「`a`型の値、`b`型の値、`[a]`型の値という**三つの**引数を受け取り、`[b]`型の値を返す関数」という意味になってしまいます。Haskellには厳密な意味では「一つの引数を受け取る関数」しかないのでそれに則って言い換えると「`a`型の値を受け取って『`b`型の値を受け取って《`[a]`型の値を受け取って`[b]`型の値を返す関数》』を返す関数」を返す関数」です。つまりカッコを補って書き換えると、こんな関数になっているものと解釈されます:

```haskell
map :: a -> (b -> ([a] -> [b]))
```

関数を表す`->`という型は、右結合（同じ優先順位の演算子を複数並べたとき、右辺に書かれた式が優先して結合される）なので、カッコを書くことで初めて「関数を受け取る関数」として宣言できるようになっています。カッコを書き忘れると上記のように思いの外引数の多い関数になってしまいますので、ご注意ください。

### 関数適用演算子`$`でカッコを減らす

関数適用演算子 `$`

```
ghci> :t ($)
($) :: (a -> b) -> a -> b
```

関数`(a -> b)`とその引数となる値`a`を受け取って、結果となる値`b`を返す。

使い方

```
ghci> words $ "abc def"
["abc","def"]
```

```
ghci> putStrLn $ "Hello, world!"
Hello, world!
```

普通に関数を実行するのと一緒！

```
ghci> words "abc def"
["abc","def"]
ghci> putStrLn "Hello, world!"
Hello, world!
```

#### `:i` コマンドで、演算子の優先順位を確認する

`:i`は型クラスの定義を確認する以外にも、いろいろ使える。

演算子をカッコで囲って渡すと、優先順位がわかる

```
ghci> :i ($)
($) :: (a -> b) -> a -> b       -- Defined in ‘GHC.Base’
infixr 0 $
```

`infixr 0 $`という部分が演算子の優先順位を示す。  
`infixr`で右結合の演算子、`infixl`で左結合の演算子。  
渡した`0`から`9`までの数字が大きければ大きいほど、結合の優先順位が高い。  
つまり、`infixr 0 $`は最弱。

他の演算子とも比べてみましょう。

```
ghci> :i (+)
-- ... 省略 ...
infixl 6 +

ghci> :i (-)
-- ... 省略 ...
infixl 6 -

ghci> :i (*)
-- ... 省略 ...
infixl 7 *

ghci> :i (/)
-- ... 省略 ...
infixl 7 /
```

足し算`(+)`引き算`(-)`よりかけ算`(*)`割り算`(/)`の方が優先順位が高く、左結合になっていることがわかります。  
いずれにしても`infixr 0 $`よりは強い

```
ghci> :i (++)
(++) :: [a] -> [a] -> [a]       -- Defined in ‘GHC.Base’
infixr 5 ++
```

こちらも`infixr 0 $`よりは強い

なので！

例えば

```
ghci> print (1 + 2 + 3)
6
```

を、

```
ghci> print $ 1 + 2 + 3
6
```

と書いたり

```
ghci> putStrLn ("aaa" ++ show 111)
aaa111
```

を、

```
ghci> putStrLn $ "aaa" ++ show 111
aaa111
```

と書いたり、課題4で書いていた

```
ghci> unlines (reverse (lines "aaa\nbbb\nccc"))
"ccc\nbbb\naaa\n"
```

を、

```
ghci> unlines $ reverse $ lines "aaa\nbbb\nccc"
"ccc\nbbb\naaa\n"
```

と書いたりできる。

要するに「`$`よりも後ろはカッコが自動で補われる」と考えるといい。

ただし、↓のように、`$`よりも結合の優先順位が高い演算子が左側にある場合はダメ:

```
ghci> "aaa" ++ show $ 1 + 110

<interactive>:9:1: error:
    ? Couldn't match expected type ‘Integer -> t’
                  with actual type ‘[Char]’
    ? The first argument of ($) takes one argument,
      but its type ‘[Char]’ has none
      In the expression: "aaa" ++ show $ 1 + 110
      In an equation for ‘it’: it = "aaa" ++ show $ 1 + 110
    ? Relevant bindings include it :: t (bound at <interactive>:9:1)

<interactive>:9:10: error:
    ? Couldn't match expected type ‘[Char]’
                  with actual type ‘() -> String’
    ? Probable cause: ‘show’ is applied to too few arguments
      In the second argument of ‘(++)’, namely ‘show’
      In the expression: "aaa" ++ show
      In the expression: "aaa" ++ show $ 1 + 110
```

カッコを補うと、↓のように解釈されてしまう。

```
ghci> ("aaa" ++ show) $ (1 + 110)
```

型エラーの原因に気づくコツ

- こういうときは上記のように、型エラーが波及するので、複数の型エラーが同じ箇所で発生することが多い。
  よくわからない型エラーが同じ箇所で複数でてきた場合は、演算子の優先順位を間違えたことを疑うといいかもしれない。
- `expected type`か`actual type`のどちらか一方が関数になっているけど、もう片方が関数じゃない時（あるいは、引数の数がそれぞれで異なる）場合も疑うといいかも。
- これ以外にも同じような型エラーになることはありますが、いずれにしても、単純な間違いを一つ犯しているだけである場合が多いので、**型エラーがたくさん出ても慌てない**ことが大事。

### 関数合成演算子`.`で一番右の変数を消す

```
ghci> :t (.)
(.) :: (b -> c) -> (a -> b) -> a -> c
```

2つの関数`f`, `g`と1つの引数`x`があるとき、`(f . g) x`は`f (g x)`と一緒

`f . g`と書いて「`g`の後に`f`（"`f` after `g`"）」と読む。

```
ghci> map (\s -> show (length s)) ["aaa", "bb", "c"]
["3","2","1"]
```

あるいは

```
ghci> map (\s -> show $ length s) ["aaa", "bb", "c"]
["3","2","1"]
```

と書いていたのを、

```
ghci> map (show . length) ["aaa", "bb", "c"]
["3","2","1"]
```

と書き換えられる。

ただし、↓のようには書けないので注意

```
ghci> show . length "aaa"

<interactive>:3:8: error:
    ? Couldn't match expected type ‘a -> ()’ with actual type ‘Int’
    ? Possible cause: ‘length’ is applied to too many arguments
      In the second argument of ‘(.)’, namely ‘length "aaa"’
      In the expression: show . length "aaa"
      In an equation for ‘it’: it = show . length "aaa"
    ? Relevant bindings include
        it :: a -> String (bound at <interactive>:3:1)
```

```
show . (length "aaa")
```

と解釈されてしまうため。  
**関数呼び出しが一番優先**して結合される！

当然、関数定義を書く際にも使える

```
reverseLines input = unlines $ reverse $ lines input
```

を、`.`で書き換えて、一番右の引数をなくす！

```
reverseLines = unlines . reverse . lines
```

`.`は、**一番右の変数を消して、関数を続けて適用できるようにする**演算子と覚える

このように、`.`などの演算子を駆使して引数や（`let`で作られる）ローカル変数をできるだけ書かないようにする書き方を、「ポイントフリースタイル」という。

### `$`と`.`を組み合わせる

再び課題4から

```
ghci> unlines $ reverse $ lines "aaa\nbbb\nccc"
"ccc\nbbb\naaa\n"
```

は、

```
ghci> unlines . reverse $ lines "aaa\nbbb\nccc"
"ccc\nbbb\naaa\n"
```

と書き換えられる。

こういう書き方を好む人も多い。

```
ghci> unlines . reverse . lines $ "aaa\nbbb\nccc"
"ccc\nbbb\naaa\n"
```

`.`と`$`の優先順位を思い出そう！  
あくまでも「`$`が一番結合の優先順位が低い演算子」という一点を押さえて。

一般化すると↓のような手順に

```
f0 (f1 (f2 (f3 arg1 arg2)))
```

`$`を使ってカッコを消し去る

```
f0 $ f1 (f2 (f3 arg1 arg2))
```

```
f0 $ f1 $ f2 (f3 arg1 arg2)
```

```
f0 $ f1 $ f2 $ f3 arg1 arg2
```

最後**以外の**`$`を`.`に変える

```
f0 . f1 $ f2 $ f3 arg1 arg2
```

```
f0 . f1 . f2 $ f3 arg1 arg2
```

↓はやり過ぎ

```
f1 . f2 . f3 arg1 arg2
```

### 演算子を前置関数に変換する

`:t`に渡すときはカッコで囲う必要があった。

```
ghci> :t (+)
(+) :: Num a => a -> a -> a
```

カッコで囲うとそのまま前置関数として使える、という意味でもある。

```
ghci> (+) 4 5
9
```

当然カリー化もされている

```
ghci> :t (+) 4
(+) 4 :: Num a => a -> a
ghci> plus4 = (+) 4
ghci> plus4 5
9
```

当然、そのまま他の関数に渡してもOK！

```
ghci> map plus4 [1, 2, 3]
[5,6,7]
ghci> map ((+) 4) [1, 2, 3]
[5,6,7]
```

### 演算子のセクション

```
ghci> :t (/ 2)
(/ 2) :: Fractional a => a -> a
```

「半分にする関数」ができる！

```
ghci> (/ 2) 10
5.0
```

先頭に`"Hello, "`をくっつける関数

```
ghci> :t (++)
(++) :: [a] -> [a] -> [a]

ghci> :t ("Hello, " ++)
("Hello, " ++) :: [Char] -> [Char]

ghci> map ("Hello, " ++) ["Tom", "Bob", "Alice"]
["Hello, Tom","Hello, Bob","Hello, Alice"]
```

さっきの「演算子を前置関数に変換する」で紹介した

```
ghci> map ((+) 4) [1, 2, 3]
[5,6,7]
```

も、

```
ghci> map (+ 4) [1, 2, 3]
[5,6,7]
```

と書いていいし、足し算は右辺と左辺を入れ替えても結果が変わらないので、

```
ghci> map (4 +) [1, 2, 3]
[5,6,7]
```

と書いてもよい！

#### 演算子のセクションは、マイナスだけは使いにくい

```
ghci> :t (- 4)
(- 4) :: Num a => a
```

↑関数じゃない、「-4」という数！

```
ghci> :t (4 -)
(4 -) :: Num a => a -> a
```

↑こちらは関数

```
ghci> (- 4) 4

<interactive>:135:1: error:
    ? Non type-variable argument in the constraint: Num (t1 -> t2)
      (Use FlexibleContexts to permit this)
    ? When checking the inferred type
        it :: forall t1 t2. (Num t1, Num (t1 -> t2)) => t2

ghci> (4 -) 4
0
```

```
ghci> 5 * -3

<interactive>:145:1: error:
    Precedence parsing error
        cannot mix ‘*’ [infixl 7] and prefix `-' [infixl 6] in the same infix expression
ghci> 5 * (-3)
-15
```

単項演算子と二項演算子を混ぜたことによるエラー。  
Haskellではマイナス記号が唯一の単項演算子でもあり、普通の二項演算子でもある（[Haskell 2010 Language Reportの「Operator Applications」より][1]）。

[1]: https://www.haskell.org/onlinereport/haskell2010/haskellch3.html#x8-280003.4

### やり過ぎ注意、あるいはどこまでやるか

例1: `yes`や`Yes`や`yEs`などを探す

前提: `filter`関数。第一引数が`True`を返した要素だけのリストを返す

```
ghci> :t filter
filter :: (a -> Bool) -> [a] -> [a]

-- 3より大きい数
ghci> filter (\x -> x > 3) [4, 3, 6]
[4,6]

-- 当然、第一引数の関数はラムダ抽象の代わりにセクションで書けるので
ghci> filter (> 3) [4, 3, 6]
[4,6]
```

```
ghci> import Data.Char

-- 大文字にすると「YES」になる文字列だけを返す
ghci> filter (\str -> map toUpper str == "YES") ["no", "yes", "yES", "iie", "YES"]
["yes","yES","YES"]
```

「`toUpper`した結果が`"YES"`と等しい」

```
ghci> filter ((== "YES") . map toUpper) ["no", "yes", "yES", "iie", "YES"]
["yes","yES","YES"]
```

このくらいなら序の口？

さっきの、

```
ghci> map ("Hello, " ++) ["Tom", "Bob", "Alice"]
["Hello, Tom","Hello, Bob","Hello, Alice"]
```

に、末尾に「!」を加えたくなったとする。

```
ghci> map (("Hello, " ++) . (++ "!")) ["Tom", "Bob", "Alice"]
["Hello, Tom!","Hello, Bob!","Hello, Alice!"]
```

さらにさらに、どんどんポイントフリースタイルにすると、読みにくくなってしまう例が: [ポイントフリースタイルへの道 〜最大公約数編〜 - Qiita][2]  
これまでの課題で紹介していない機能も利用していますが参考までにどうぞ。  
大事なことは、[**短く書ける人を上級者と呼ぶな**][3]ということです。

[2]: https://qiita.com/necojackarc/items/1bccc9643857d3ce7896
[3]: https://wiki.haskell.jp/Hikers%20Guide%20to%20Haskell#%E3%83%9D%E3%82%A4%E3%83%B3%E3%83%88%E3%83%95%E3%83%AA%E3%83%BC%E3%82%B9%E3%82%BF%E3%82%A4%E3%83%AB%E3%81%82%E3%82%8B%E3%81%84%E3%81%AF%E6%A7%98%E3%80%85%E3%81%AA%E3%82%B9%E3%82%BF%E3%82%A4%E3%83%AB%E3%81%A8%E3%81%AE%E4%BB%98%E3%81%8D%E5%90%88%E3%81%84%E6%96%B9

### ラムダ抽象や関数の引数でのパターンマッチ

関数の引数で直接パターンマッチできる

課題11の`doubles`関数、数値のリストを受け取ってすべての要素を2倍にする関数の再実装

```haskell
doubles xs =
    case xs of
        [] -> []
        x : xsLeft -> x * 2 : doubles xsLeft
```

第1引数`xs`は直ちに`case`式で使われている！  
こんな時はこう書き換えられる:

```haskell
doubles [] = []
doubles (x : xsLeft) = x * 2 : doubles xsLeft
```

`->`の代わりに`=`でパターンとその定義を区切っている点と、`(x : xsLeft)`のように、パターン全体を**カッコで囲う**必要がある点に注意。

カッコで囲う必要があるのは、関数定義では複数の引数を扱うことがあるため。  
例えば`doubles`関数に引数を増やして、引数で指定した数以外を掛けられるようにした場合:

```haskell
times n [] = []
times n (x : xsLeft) = x * n : times n xsLeft
```

`times n (x : xsLeft) = ...`の`(x : xsLeft)`からカッコを外してしまうと、

```haskell
ghci> :{
ghci| times n [] = []
ghci| times n x : xsLeft = x * n : times n xsLeft
ghci| :}

<interactive>:47:1: error: Parse error in pattern: times
```

となってしまい、`n`, `x`, `:`, `xsLeft`, という4つの引数を受け取るように見えてしまう。

おまけにかっこいい例: よく見かける（*でもすごく効率が悪い*）`n`番目のフィボナッチ数を計算する関数

```
fib n =
    case n of
        0 -> 0
        1 -> 1
        _ -> fib (n - 2) + fib (n - 1)
```

`case`で書くと↑のなのを、

```
fib 0 = 0
fib 1 = 1
fib n = fib (n - 2) + fib (n - 1)
```

と書き換えることができる。  
[元々のフィボナッチ数の定義][4]っぽくてかっこいい！  
（でもいずれにしても効率はすごく悪いのでくれぐれも使わないこと）

[4]: https://ja.wikipedia.org/wiki/%E3%83%95%E3%82%A3%E3%83%9C%E3%83%8A%E3%83%83%E3%83%81%E6%95%B0#%E6%A6%82%E8%A6%81

#### レコード型に対する関数の引数でのパターンマッチ

自分で定義した型でもOK！

※ここと次のタプルの節で紹介するパターンマッチは`case`式でも使えますが、特に引数でのパターンマッチで使うことが多いです。

例えばおなじみ`Entry`型を使って

```
data Entry =
  Entry { category :: String, price :: Integer }
  deriving Show
```

値コンストラクター`Entry`の第一引数にあたる`category`、第二引数にあたる`price`、それぞれにパターンマッチできる！

```
ghci> :{
ghci| formatEntry :: Entry -> String
ghci| formatEntry (Entry cat pri) = cat ++ ": " ++ show pri
ghci| :}

ghci> entry = Entry "Magazine" 120
ghci> formatEntry entry
"Magazine: 120"
```

パターンマッチは入れ子になった構造の中の要素に対してもできるので、さらに`category`が空文字列のものを特別扱いしたくなったら:

```
ghci> :{
ghci| formatEntry :: Entry -> String
ghci| formatEntry (Entry "" pri) = "<Unknown category>" ++ ": " ++ show pri
ghci| formatEntry (Entry cat pri) = cat ++ ": " ++ show pri
ghci| :}

ghci> entry = Entry "" 999999999999999
ghci> formatEntry entry
"<Unknown category>: 999999999999999"
```

ここでもカッコを忘れず！

```
ghci> :{
ghci| formatEntry :: Entry -> String
ghci| formatEntry Entry cat pri = cat ++ ": " ++ show pri
ghci| :}

<interactive>:89:13: error:
    ? The constructor ‘Entry’ should have 2 arguments, but has been given none
    ? In the pattern: Entry
      In an equation for ‘formatEntry’:
          formatEntry Entry cat pri = cat ++ ": " ++ show pri
      The equation(s) for ‘formatEntry’ have three arguments,
      but its type ‘Entry -> String’ has only one
```

こういう風にレコードラベルを用いたパターンマッチをすれば、フィールドの順番が違っていてもよい。

```
ghci> :{
ghci| formatEntry :: Entry -> String
ghci| formatEntry (Entry { category = "",  price = pri }) = "<Unknown category>" ++ ": " ++ show pri
ghci| formatEntry (Entry { category = cat, price = pri }) = cat ++ ": " ++ show pri
ghci| :}
```

#### タプルに対する関数の引数でのパターンマッチ

便利なサンプルが[`Prelude`モジュール][5]にいくつかある。  
以下はソースコードからの抜粋:

[5]: https://hackage.haskell.org/package/base-4.12.0.0/docs/Prelude.html#g:3

```
fst :: (a, b) -> a
fst (x, _) = x

snd :: (a, b) -> b
snd (_, y) = y
```

課題8で紹介したとおり、これらは`Prelude`モジュールに入っているので、何も`import`しなくても使える

おまけ: `curry`と`uncurry`

`curry`は「（サイズ2の）タプルを受け取る関数」を（Haskellの世界で普通の、カリー化された）2引数関数に変換する。

```
curry :: ((a, b) -> c) -> a -> b -> c
curry f x y = f (x, y)
```

`uncurry`はその逆。ここでタプルに対するパターンマッチが出てくる。

```
uncurry :: (a -> b -> c) -> ((a, b) -> c)
uncurry f (x, y) = f x y
```

おそらく`uncurry`の方が実践ではよく使う

典型的な使用例: `Map`方の値を`toList`関数で変換した結果を、そのまま2引数の関数に渡す

`(+)`を`uncurry`関数でタプルを受け取る関数に変換することで、`toList`結果の値をそのまま使える。

```
ghci> import qualified Data.Map.Strict as M

ghci> numberAndChars = M.fromList [(1, 3), (2, 4)]
ghci> map (uncurry (+)) $ M.toList numberAndChars
[4,6]
```

ラムダ抽象で書き換えると↓と同じ

```
ghci> map (\pair -> fst pair + snd pair) $ M.toList numberAndChars
[4,6]
```

#### ラムダ抽象の引数でのパターンマッチ

引数でのパターンマッチは、ラムダ抽象でも使える。

つまり、

```
tupleToEntry :: (String, Integer) -> Entry
tupleToEntry (cat, pri) = Entry cat pri
```

↑と↓は同じ！

```
tupleToEntry :: (String, Integer) -> Entry
tupleToEntry = \(cat, pri) -> Entry cat pri
```

課題8で↓のように書いていたのと実質同じようなもの。

```
-- ...
let (divResult, modResult) = divMod numerator denominator
-- ...
```

パターンマッチに関する話をまとめると

- 原則1: 値コンストラクターで値を組み立てるのと逆のことをするのがパターンマッチ。
    - リストには `[x, y]` という構文の、特別な値コンストラクターがある。本来は`x : y : []`。
- 原則2: 関数の引数を含めた、変数への代入を行うあらゆる場面でパターンマッチは使える。

でも、これは危ない！

```
ghci> dangerous = \(Just x) -> x
```

ラムダ抽象は

```
dangerous (Just x) = x
dangerous Nothing = "error!"
```

みたいに、関数定義の構文のように引数でパターンマッチしても場合分けができないので、

```
dangerous = \(Just x) -> x
```

みたいに書きたくなったら、↓のような`case`に変換するしかない（`LambdaCase`についてはいつか脚注に）。

```
dangerous = \mx ->
    case mx of
        Just x  -> ...
        Nothing -> ...
```

結果、うっかり`Nothing`が渡されてエラーになってしまうことも

```
ghci> dangerous Nothing
*** Exception: <interactive>:8:2-15: Non-exhaustive patterns in lambda
```

警告を有効にしても教えてくれない😱

```
ghci> :set -Wall
ghci> dangerous = (\(Just x) -> x)
```

`-Wincomplete-uni-patterns`を有効にしないといけない！

```
ghci> :set -Wincomplete-uni-patterns
ghci> dangerous = \(Just x) -> x

<interactive>:10:2: warning: [-Wincomplete-uni-patterns]
    Pattern match(es) are non-exhaustive
    In a lambda abstraction: Patterns not matched: Nothing
```

[GHCの将来のバージョンで、`-Wincomplete-uni-patterns`が`-Wall`に含まれる][6]かも。

[6]: https://gitlab.haskell.org/ghc/ghc/issues/15656

`-Wall`を有効にしても有効にならない警告の一覧は[GHC Users Guide][7]を参照。

<https://functor.tokyo/blog/2017-07-28-ghc-warnings-you-should-enable>

[7]: https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/using-warnings.html#ghc-flag--Wall

## HLintで改善点をある程度自動で見つける

```bash
shell> cabal install hlint
# あるいは...
shell> stack install hlint
```

ここで紹介していない`TupleSections`というGHCの拡張を使ったものも（GHCの拡張の話を後回しにしたいので敢えて紹介していません... あしからず）。

```bash
shell> hlint assets/16.hs
assets/16.hs:18:14: Warning: Avoid lambda
Found:
  \ x y -> x + y
Perhaps:
  (+)

assets/16.hs:19:19: Suggestion: Use tuple-section
Found:
  \ w -> (w, 1)
Perhaps:
  (, 1)
Note: may require `{-# LANGUAGE TupleSections #-}` adding to the top of the file

2 hints
```

HLintのさらに便利な使い方は[素晴らしき HLint を使いこなす][7]を。  
「この関数はこのモジュール以外では使わないでください」などというプロジェクト固有のルールを設定することもできます。

[7]: https://haskell.e-bigmoon.com/posts/2018-01-29-awesome-hlint.html
