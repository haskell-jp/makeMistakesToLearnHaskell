# ã‚‚ã£ã¨ç°¡æ½”ã«æ›¸ã

èª²é¡Œ16ã®å›ç­”ã‚’æ›¸ãæ›ãˆã¦ã€ã§ãã‚‹ã ã‘ç°¡æ½”ã«æ›¸ã„ã¦ã¿ã¾ã—ã‚‡ã†ã€‚  
ä»Šå›ã¯ç´”ç²‹ã«ãƒªãƒ•ã‚¡ã‚¯ã‚¿ãƒªãƒ³ã‚°ã‚’ã—ã¦ãã ã•ã„ã€‚ç‰¹ã«æŒ¯ã‚‹èˆã„ã‚’å¤‰ãˆã‚‹å¿…è¦ã¯ã‚ã‚Šã¾ã›ã‚“ã€‚

## å¿…è¦ãªçŸ¥è­˜

Haskellã«ã¯ã€ã‚³ãƒ¼ãƒ‰ã‚’æ¥µã‚ã¦ç°¡æ½”ã«æ›¸ããƒ†ã‚¯ãƒ‹ãƒƒã‚¯ãŒã€ãŸãã•ã‚“ã‚ã‚Šã¾ã™ã€‚ã“ã®èª²é¡Œã§ã¯ã€ãã†ã—ãŸãƒ†ã‚¯ãƒ‹ãƒƒã‚¯ã®ã†ã¡ã€ç‰¹ã«ã‚ˆãä½¿ã‚ã‚Œã‚‹ã‚‚ã®ã‚’ç´¹ä»‹ã—ã¾ã™ã€‚ã¿ãªã•ã‚“ãŒHaskellã‚’æ›¸ãã¨ãã«å¿…ãšã—ã‚‚ã“ã“ã§å­¦ç¿’ã—ãŸã“ã¨ã‚’ä½¿ã†å¿…è¦ã¯ãªã„ã§ã™ãŒã€æ—¢å­˜ã®Haskellè£½ã‚³ãƒ¼ãƒ‰ã®ä¸­ã§ã‚‚é«˜ç¢ºç‡ã§ä½¿ã‚ã‚Œã¦ã„ã‚‹ã®ã§ã€æ˜¯éç¿’å¾—ã—ã¦ãã ã•ã„ã€‚

### ï¼ˆã‚«ãƒªãƒ¼åŒ–ã•ã‚ŒãŸï¼‰é–¢æ•°ã®éƒ¨åˆ†é©ç”¨

ã¾ãšã¯ã€é–¢æ•°ã®éƒ¨åˆ†é©ç”¨ã¨ã„ã†æ‰‹æ³•ã‚’çŸ¥ã‚‹ã“ã¨ã§ã€é©åº¦ã«é–¢æ•°ã®å®šç¾©ã‚’æ›¸ã‹ãšã«æ¸ˆã¾ã™ãƒ†ã‚¯ãƒ‹ãƒƒã‚¯ã®ã»ã‹ã€Haskellã«ãŠã‘ã‚‹é–¢æ•°`->`ã®ç§˜å¯†ã‚‚çŸ¥ã‚Šã¾ã—ã‚‡ã†ã€‚

ã¾ãšã¯ä¸€ä¾‹ã¨ã—ã¦ã€`map`é–¢æ•°ã®å‹å®šç¾©ã‚’æ€ã„å‡ºã—ã¦ãã ã•ã„:

```haskell
ghci> :t map
map :: (a -> b) -> [a] -> [b]
```

é–¢æ•°`(a -> b)`ã¨ãƒªã‚¹ãƒˆ`[a]`ã¨ã„ã†ã€äºŒã¤ã®å¼•æ•°ã‚’å—ã‘å–ã‚‹ã‚ˆã†ã«ãªã£ã¦ã„ã¾ã™ã­ã€‚

```haskell
ghci> map (\x -> x * 2) [3, 8, 9]
[6,16,18]
```

ã§ã¯ã“ã‚Œã«ä¸€ã¤ç›®ã®å¼•æ•°ã§ã‚ã‚‹ã€é–¢æ•°`(a -> b)`ã®ã¿ã‚’é©ç”¨ã™ã‚‹ã¨ã©ã†ãªã‚‹ã§ã—ã‚‡ã†ã‹:

```haskell
ghci> map (\x -> x * 2)

<interactive>:5:1: error:
    ? No instance for (Show ([Integer] -> [Integer]))
        arising from a use of â€˜printâ€™
        (maybe you haven't applied a function to enough arguments?)
    ? In a stmt of an interactive GHCi command: print it
```

æ¡ˆã®å®šã‚¨ãƒ©ãƒ¼ã«ãªã‚Šã¾ã—ãŸã€‚`No instance for (Show ([Integer] -> [Integer]))`ã¨ã„ã†è¡Œã§å§‹ã¾ã‚‹ã“ã®ã‚¨ãƒ©ãƒ¼ã¯ã€ã€Œæ•´æ•°ã®ãƒªã‚¹ãƒˆã‚’å—ã‘å–ã£ã¦æ•´æ•°ã®ãƒªã‚¹ãƒˆã‚’è¿”ã™é–¢æ•°`[Integer] -> [Integer]`ã¯ã€`Show`å‹ã‚¯ãƒ©ã‚¹ã®ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã§ã¯ãªã„ã€ã¨ã„ã†æ„å‘³ã®å‹ã‚¨ãƒ©ãƒ¼ã§ã™ã€‚GHCiã¯å…¥åŠ›ã—ãŸHaskellã®å¼ã‚’è©•ä¾¡ã—ãŸå¾Œã€çµæœã‚’`print`é–¢æ•°ã§è¡¨ç¤ºã™ã‚‹ã®ã§ã€è©•ä¾¡ã—ãŸçµæœã®å€¤ã¯`Show`å‹ã‚¯ãƒ©ã‚¹ã®ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã§ãªã‘ã‚Œã°ãªã‚‰ãªã„ã®ã§ã—ãŸã€‚

ã“ã“ã‹ã‚‰ãŒæœ¬é¡Œã§ã™ã€‚`No instance for (Show ([Integer] -> [Integer]))`ã«ãŠã‘ã‚‹ã€ã€Œæ•´æ•°ã®ãƒªã‚¹ãƒˆã‚’å—ã‘å–ã£ã¦æ•´æ•°ã®ãƒªã‚¹ãƒˆã‚’è¿”ã™é–¢æ•°`[Integer] -> [Integer]`ã€ã¨ã„ã†å‹ã®å¼ã¨ã¯ã€ä¸€ä½“ä½•ã®ã“ã¨ã§ã—ã‚‡ã†ï¼Ÿãã†ã€å…¥åŠ›ã—ãŸ`map (\x -> x * 2)`ã®ã“ã¨ã§ã™ã€‚`map (\x -> x * 2)`ã¯ã€`[Integer] -> [Integer]`ã¨ã„ã†å‹ã®å€¤ãªã®ã§ã™ï¼

æ¯åº¦ãŠãªã˜ã¿`:t`ã‚³ãƒãƒ³ãƒ‰ã§ã‚‚ãƒã‚§ãƒƒã‚¯ã—ã¦ã¿ã¾ã—ã‚‡ã†:

```haskell
ghci> :t map (\x -> x * 2)
map (\x -> x * 2) :: Num b => [b] -> [b]
```

`map (\x -> x * 2)`ã®å‹ã¯ã€`Num b => [b] -> [b]`ã€ã™ãªã‚ã¡`Num`å‹ã‚¯ãƒ©ã‚¹ã®ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã§ã‚ã‚‹å‹`b`ï¼ˆæ•°å€¤å‹ï¼‰ã®å€¤ã®ãƒªã‚¹ãƒˆã‚’å—ã‘å–ã£ã¦ã€åŒã˜ã`b`ã®ãƒªã‚¹ãƒˆã‚’è¿”ã™é–¢æ•°ã ãã†ã§ã™ã€‚å…ˆã»ã©å‹ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ãŸéš›ã¯`[Integer] -> [Integer]`ã¨è¨€ã£ã¦ã„ãŸã®ã«ã€é£Ÿã„é•ã£ã¦ã¾ã™ã­ã€‚ã“ã‚Œã¯èª²é¡Œhoge(7?)ã§è§£èª¬ã—ãŸã€`Num`å‹ã‚¯ãƒ©ã‚¹ã®ã€Œãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã®å‹ã€ãŒæ¡ç”¨ã•ã‚ŒãŸçµæœã§ã™ã€‚`Num`å‹ã‚¯ãƒ©ã‚¹ã«ã¯ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã®å‹ã¨ã—ã¦`Integer`å‹ï¼ˆæ•´æ•°å‹ï¼‰ãŒè¨­å®šã•ã‚Œã¦ã„ã‚‹ã®ã§ã€GHCiãŒå¼ã‚’è©•ä¾¡ã—ã‚ˆã†ã¨ã—ãŸã‘ã©`Num`å‹ã‚¯ãƒ©ã‚¹ã®å‹ãŒæ±ºã¾ã‚‰ãªã‹ã£ãŸã€ã¨ã„ã†å ´åˆã¯`Integer`ãŒä½¿ç”¨ã•ã‚Œã‚‹ã®ã§ã™ã€‚

ã„ãšã‚Œã«ã—ã¦ã‚‚ã€`Integer`å‹ã‚¯ãƒ©ã‚¹ã¯`Num`å‹ã‚¯ãƒ©ã‚¹ã®ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ãªã®ã§ã€`map (\x -> x * 2)`ã«`[Integer]`å‹ã€ã™ãªã‚ã¡æ•´æ•°ã®ãƒªã‚¹ãƒˆã‚’æ¸¡ã›ã°ã€`[Integer]`ã€æ•´æ•°ã®ãƒªã‚¹ãƒˆãŒè¿”ã£ã¦ãã‚‹ã¯ãšã§ã™ã€‚è©¦ã—ã«æ¸¡ã—ã¦ã¿ã¾ã—ã‚‡ã†ï¼

```haskell
ghci> doubles = map (\x -> x * 2)
ghci> doubles [3, 8, 9]
[6,16,18]
```

`map (\x -> x * 2) [3, 8, 9]`ã¨åŒã˜çµæœãŒè¿”ã‚Šã¾ã—ãŸï¼

ãªãœã“ã®ã‚ˆã†ãªæŒ¯ã‚‹èˆã„ã«ãªã‚‹ã®ã§ã—ã‚‡ã†ã‹ï¼Ÿãã®ç§˜å¯†ã¯ã€Haskellã«ãŠã‘ã‚‹é–¢æ•°å‹ã®ã€ã‚ã‚‹ç‰¹å¾´ã«ã‚ã‚Šã¾ã™ã€‚æ¬¡ã®ã‚ˆã†ãªã€ã€Œ`a`ã¨ã„ã†å‹ã®å€¤ã¨`b`ã¨ã„ã†å‹ã®å€¤ã‚’å—ã‘å–ã£ã¦`c`ã¨ã„ã†å‹ã®å€¤ã‚’è¿”ã™é–¢æ•°ã‚’ä¾‹ã«ã—ã¾ã—ã‚‡ã†:

```haskell
a -> b -> c
```

ã“ã®ã‚ˆã†ã«2ã¤ï¼ˆä»¥ä¸Šï¼‰ã®å¼•æ•°ã‚’å—ã‘å–ã‚‹é–¢æ•°å‹ã«ã€ã‚«ãƒƒã‚³ã‚’è£œã†ã¨ã€å®Ÿã¯Haskellã¯æ¬¡ã®ã‚ˆã†ã«è§£é‡ˆã—ã¦ã„ã‚‹ã“ã¨ãŒã‚ã‹ã‚Šã¾ã™:

```haskell
a -> (b -> c)
```

ä¸Šè¨˜ã®ã‚ˆã†ã«ã€`a -> (b -> c)`ã¯ã€`a`ã¨ã„ã†å‹ã®å€¤ã‚’ä¸€ã¤å—ã‘å–ã£ã¦ã€`(b -> c)`ã¨ã„ã†å‹ã®é–¢æ•°ã‚’è¿”ã™é–¢æ•°ã§ã™ã€‚`a`å‹ã®å€¤ã‚’1ã¤å—ã‘å–ã‚‹ã“ã¨ã«ã‚ˆã£ã¦ã€

```haskell
(b -> c)
```

ã¨ã„ã†ã€å¼•æ•°ã‚’ï¼ˆæ®‹ã‚Šï¼‰ä¸€ã¤å—ã‘å–ã‚‹é–¢æ•°ã«ãªã‚‹ã®ã§ã™ã€‚

Haskellã«ã¯ã€å³å¯†ãªæ„å‘³ã§ã¯ã€Œä¸€ã¤ã®å¼•æ•°ã‚’å—ã‘å–ã£ã¦ä¸€ã¤ã®å€¤ã‚’è¿”ã™é–¢æ•°ã€ã—ã‹å­˜åœ¨ã—ã¾ã›ã‚“ã€‚`a -> b -> c`ã®ã‚ˆã†ã«ã€2ã¤ä»¥ä¸Šã®å¼•æ•°ã‚’å—ã‘å–ã‚‹ã‚ˆã†æŒ¯ã‚‹èˆã†é–¢æ•°ã¯ã€ã€Œé–¢æ•°ã‚’è¿”ã™é–¢æ•°ã€ã‚’çµ„ã¿åˆã‚ã›ã‚‹ã“ã¨ã«ã‚ˆã£ã¦è¡¨ç¾ã•ã‚Œã¾ã™ã€‚

æ³¨æ„âš ï¸ Haskellã«ã¯å³å¯†ã«ã¯ã€Œä¸€ã¤ã®å¼•æ•°ã‚’å—ã‘å–ã£ã¦ä¸€ã¤ã®å€¤ã‚’è¿”ã™é–¢æ•°ã€ã—ã‹ãªã„ã¨ç”³ã—ã¾ã—ãŸãŒã€å®Ÿéš›ã«`a -> b -> c`ã®ã‚ˆã†ãªé–¢æ•°ã«ã¤ã„ã¦è©±ã™æ™‚ã¯ã€Œã“ã®é–¢æ•°ã¯äºŒã¤ã®å¼•æ•°ã‚’å—ã‘å–ã‚‹ã€ã¨ã„ã£ãŸè¡¨ç¾ã‚’æ™®é€šã«ä½¿ç”¨ã—ã¾ã™ã€‚æœ¬å…¥é–€ã®ã“ã‚Œä»¥é™ã§ã‚‚ç”¨ã„ã‚‹äºˆå®šã§ã™ã®ã§ã€ŒHaskellã«ã¯ä¸€ã¤ã®å¼•æ•°ã‚’å—ã‘å–ã‚‹é–¢æ•°ã—ã‹ãªã„ã®ã ã‹ã‚‰ï½ã€ãªã©ã¨ã¯ã„ã¡ã„ã¡è€ƒãˆãªãã¦çµæ§‹ã§ã™ã€‚

ã“ã®ç‰¹å¾´ã‚’åˆ©ç”¨ã™ã‚‹ã¨ã€ä½™è¨ˆãªãƒ©ãƒ ãƒ€æŠ½è±¡ã‚’æ›¸ã‹ãšã«æ¸ˆã¾ã›ãŸã‚Šã€å¼•æ•°ã®åå‰ã‚’è€ƒãˆãšã«æ¸ˆã¾ã›ãŸã‚Šã™ã‚‹ã“ã¨ãŒã§ãã¾ã™ã€‚

ä¾‹ãˆã°ã€Œæ–‡å­—åˆ—ã®ãƒªã‚¹ãƒˆã«ãŠã‘ã‚‹ã€ã™ã¹ã¦ã®æ–‡å­—ã‚’å¤§æ–‡å­—ã«ã™ã‚‹ã€ã¨ã„ã†å‡¦ç†ã‚’æ¬¡â†“ã®ã‚ˆã†ã«æ›¸ã„ã¦ã„ãŸã¨ã—ã¾ã™:

```haskell
ghci> import Data.Char

ghci> map (\s -> map toUpper s) ["hello", "world!"]
["HELLO","WORLD!"]
```

ã“ã¡ã‚‰ã®`(\s -> map toUpper s)`ã¯ã€ã€Œ`map`é–¢æ•°ã«`toUpper`é–¢æ•°ã‚’æ¸¡ã—ã¦ä½œã£ãŸé–¢æ•°ã€ã«å¼•æ•°`s`ã‚’æ¸¡ã—ã¦ã„ã‚‹ã ã‘ã®é–¢æ•°ãªã®ã§ã€æ¬¡â†“ã®ã‚ˆã†ã«æ›¸ãæ›ãˆã‚‹ã“ã¨ãŒã§ãã¾ã™:

```haskell
ghci> map (map toUpper) ["hello", "world!"]
["HELLO","WORLD!"]
```

ã“ã®ã‚ˆã†ã«ã€`a -> b -> c`ã¨ã„ã£ãŸå‹ã®è¤‡æ•°ã®å¼•æ•°ã‚’å—ã‘å–ã‚‹é–¢æ•°ã‹ã‚‰ã€æœ€åˆã®ã„ãã¤ã‹ã®å¼•æ•°ã ã‘ã‚’é©ç”¨ã—ãŸæ–°ã—ã„é–¢æ•°ã‚’ä½œã‚‹ã“ã¨ã‚’ã€Œéƒ¨åˆ†é©ç”¨ã€ã¨è¨€ã„ã¾ã™ã€‚Haskellã§ã¯éƒ¨åˆ†é©ç”¨ã‚’åˆ©ç”¨ã™ã‚‹ã“ã¨ã§ã€ä¸€ã¤ã®é–¢æ•°ã‹ã‚‰ç°¡å˜ã«æ–°ã—ã„é–¢æ•°ã‚’ä½œã‚‹ã“ã¨ãŒã§ãã¾ã™ã€‚

ã¨ã“ã‚ã§ã€ã“ã“ã§ä¸€ã¤æ€ã„å‡ºã—ã¦ã„ãŸã ããŸã„ã“ã¨ãŒã‚ã‚Šã¾ã™ã€‚ä¾‹ãˆã°`map`é–¢æ•°ã®ã‚ˆã†ã«ã€ã“ã‚Œã¾ã§ç´¹ä»‹ã—ãŸã€Œé–¢æ•°ã‚’å—ã‘å–ã‚‹é–¢æ•°ã€ã¯ã“ã‚“ãªå‹ã§ã—ãŸ:

```haskell
ghci> :t map
map :: (a -> b) -> [a] -> [b]
```

ã‚‚ã—ã“ã®`(a -> b) -> [a] -> [b]`ã®`(a -> b)`ã‹ã‚‰ã‚«ãƒƒã‚³ã‚’å–ã‚Šé™¤ã„ã¦ã€

```haskell
map :: a -> b -> [a] -> [b]
```

ã¨ã„ã†å‹ã«ã—ãŸã‚‰ã€ã©ã®ã‚ˆã†ãªæ„å‘³ã«ãªã‚‹ã®ã§ã—ã‚‡ã†ã‹ï¼Ÿ

å®Ÿã¯`a -> b -> [a] -> [b]`ã¨ã„ã†å‹ã®é–¢æ•°ã«ã—ãŸã‚‰ã€Œ`a`å‹ã®å€¤ã€`b`å‹ã®å€¤ã€`[a]`å‹ã®å€¤ã¨ã„ã†**ä¸‰ã¤ã®**å¼•æ•°ã‚’å—ã‘å–ã‚Šã€`[b]`å‹ã®å€¤ã‚’è¿”ã™é–¢æ•°ã€ã¨ã„ã†æ„å‘³ã«ãªã£ã¦ã—ã¾ã„ã¾ã™ã€‚Haskellã«ã¯å³å¯†ãªæ„å‘³ã§ã¯ã€Œä¸€ã¤ã®å¼•æ•°ã‚’å—ã‘å–ã‚‹é–¢æ•°ã€ã—ã‹ãªã„ã®ã§ãã‚Œã«å‰‡ã£ã¦è¨€ã„æ›ãˆã‚‹ã¨ã€Œ`a`å‹ã®å€¤ã‚’å—ã‘å–ã£ã¦ã€`b`å‹ã®å€¤ã‚’å—ã‘å–ã£ã¦ã€Š`[a]`å‹ã®å€¤ã‚’å—ã‘å–ã£ã¦`[b]`å‹ã®å€¤ã‚’è¿”ã™é–¢æ•°ã€‹ã€ã‚’è¿”ã™é–¢æ•°ã€ã‚’è¿”ã™é–¢æ•°ã€ã§ã™ã€‚ã¤ã¾ã‚Šã‚«ãƒƒã‚³ã‚’è£œã£ã¦æ›¸ãæ›ãˆã‚‹ã¨ã€ã“ã‚“ãªé–¢æ•°ã«ãªã£ã¦ã„ã‚‹ã‚‚ã®ã¨è§£é‡ˆã•ã‚Œã¾ã™:

```haskell
map :: a -> (b -> ([a] -> [b]))
```

é–¢æ•°ã‚’è¡¨ã™`->`ã¨ã„ã†å‹ã¯ã€å³çµåˆï¼ˆåŒã˜å„ªå…ˆé †ä½ã®æ¼”ç®—å­ã‚’è¤‡æ•°ä¸¦ã¹ãŸã¨ãã€å³è¾ºã«æ›¸ã‹ã‚ŒãŸå¼ãŒå„ªå…ˆã—ã¦çµåˆã•ã‚Œã‚‹ï¼‰ãªã®ã§ã€ã‚«ãƒƒã‚³ã‚’æ›¸ãã“ã¨ã§åˆã‚ã¦ã€Œé–¢æ•°ã‚’å—ã‘å–ã‚‹é–¢æ•°ã€ã¨ã—ã¦å®£è¨€ã§ãã‚‹ã‚ˆã†ã«ãªã£ã¦ã„ã¾ã™ã€‚ã‚«ãƒƒã‚³ã‚’æ›¸ãå¿˜ã‚Œã‚‹ã¨ä¸Šè¨˜ã®ã‚ˆã†ã«æ€ã„ã®å¤–å¼•æ•°ã®å¤šã„é–¢æ•°ã«ãªã£ã¦ã—ã¾ã„ã¾ã™ã®ã§ã€ã”æ³¨æ„ãã ã•ã„ã€‚

### é–¢æ•°é©ç”¨æ¼”ç®—å­`$`ã§ã‚«ãƒƒã‚³ã‚’æ¸›ã‚‰ã™

é–¢æ•°é©ç”¨æ¼”ç®—å­ `$`

```
ghci> :t ($)
($) :: (a -> b) -> a -> b
```

é–¢æ•°`(a -> b)`ã¨ãã®å¼•æ•°ã¨ãªã‚‹å€¤`a`ã‚’å—ã‘å–ã£ã¦ã€çµæœã¨ãªã‚‹å€¤`b`ã‚’è¿”ã™ã€‚

ä½¿ã„æ–¹

```
ghci> words $ "abc def"
["abc","def"]
```

```
ghci> putStrLn $ "Hello, world!"
Hello, world!
```

æ™®é€šã«é–¢æ•°ã‚’å®Ÿè¡Œã™ã‚‹ã®ã¨ä¸€ç·’ï¼

```
ghci> words "abc def"
["abc","def"]
ghci> putStrLn "Hello, world!"
Hello, world!
```

#### `:i` ã‚³ãƒãƒ³ãƒ‰ã§ã€æ¼”ç®—å­ã®å„ªå…ˆé †ä½ã‚’ç¢ºèªã™ã‚‹

`:i`ã¯å‹ã‚¯ãƒ©ã‚¹ã®å®šç¾©ã‚’ç¢ºèªã™ã‚‹ä»¥å¤–ã«ã‚‚ã€ã„ã‚ã„ã‚ä½¿ãˆã‚‹ã€‚

æ¼”ç®—å­ã‚’ã‚«ãƒƒã‚³ã§å›²ã£ã¦æ¸¡ã™ã¨ã€å„ªå…ˆé †ä½ãŒã‚ã‹ã‚‹

```
ghci> :i ($)
($) :: (a -> b) -> a -> b       -- Defined in â€˜GHC.Baseâ€™
infixr 0 $
```

`infixr 0 $`ã¨ã„ã†éƒ¨åˆ†ãŒæ¼”ç®—å­ã®å„ªå…ˆé †ä½ã‚’ç¤ºã™ã€‚  
`infixr`ã§å³çµåˆã®æ¼”ç®—å­ã€`infixl`ã§å·¦çµåˆã®æ¼”ç®—å­ã€‚  
æ¸¡ã—ãŸ`0`ã‹ã‚‰`9`ã¾ã§ã®æ•°å­—ãŒå¤§ãã‘ã‚Œã°å¤§ãã„ã»ã©ã€çµåˆã®å„ªå…ˆé †ä½ãŒé«˜ã„ã€‚  
ã¤ã¾ã‚Šã€`infixr 0 $`ã¯æœ€å¼±ã€‚

ä»–ã®æ¼”ç®—å­ã¨ã‚‚æ¯”ã¹ã¦ã¿ã¾ã—ã‚‡ã†ã€‚

```
ghci> :i (+)
-- ... çœç•¥ ...
infixl 6 +

ghci> :i (-)
-- ... çœç•¥ ...
infixl 6 -

ghci> :i (*)
-- ... çœç•¥ ...
infixl 7 *

ghci> :i (/)
-- ... çœç•¥ ...
infixl 7 /
```

è¶³ã—ç®—`(+)`å¼•ãç®—`(-)`ã‚ˆã‚Šã‹ã‘ç®—`(*)`å‰²ã‚Šç®—`(/)`ã®æ–¹ãŒå„ªå…ˆé †ä½ãŒé«˜ãã€å·¦çµåˆã«ãªã£ã¦ã„ã‚‹ã“ã¨ãŒã‚ã‹ã‚Šã¾ã™ã€‚  
ã„ãšã‚Œã«ã—ã¦ã‚‚`infixr 0 $`ã‚ˆã‚Šã¯å¼·ã„

```
ghci> :i (++)
(++) :: [a] -> [a] -> [a]       -- Defined in â€˜GHC.Baseâ€™
infixr 5 ++
```

ã“ã¡ã‚‰ã‚‚`infixr 0 $`ã‚ˆã‚Šã¯å¼·ã„

ãªã®ã§ï¼

ä¾‹ãˆã°

```
ghci> print (1 + 2 + 3)
6
```

ã‚’ã€

```
ghci> print $ 1 + 2 + 3
6
```

ã¨æ›¸ã„ãŸã‚Š

```
ghci> putStrLn ("aaa" ++ show 111)
aaa111
```

ã‚’ã€

```
ghci> putStrLn $ "aaa" ++ show 111
aaa111
```

ã¨æ›¸ã„ãŸã‚Šã€èª²é¡Œ4ã§æ›¸ã„ã¦ã„ãŸ

```
ghci> unlines (reverse (lines "aaa\nbbb\nccc"))
"ccc\nbbb\naaa\n"
```

ã‚’ã€

```
ghci> unlines $ reverse $ lines "aaa\nbbb\nccc"
"ccc\nbbb\naaa\n"
```

ã¨æ›¸ã„ãŸã‚Šã§ãã‚‹ã€‚

è¦ã™ã‚‹ã«ã€Œ`$`ã‚ˆã‚Šã‚‚å¾Œã‚ã¯ã‚«ãƒƒã‚³ãŒè‡ªå‹•ã§è£œã‚ã‚Œã‚‹ã€ã¨è€ƒãˆã‚‹ã¨ã„ã„ã€‚

ãŸã ã—ã€â†“ã®ã‚ˆã†ã«ã€`$`ã‚ˆã‚Šã‚‚çµåˆã®å„ªå…ˆé †ä½ãŒé«˜ã„æ¼”ç®—å­ãŒå·¦å´ã«ã‚ã‚‹å ´åˆã¯ãƒ€ãƒ¡:

```
ghci> "aaa" ++ show $ 1 + 110

<interactive>:9:1: error:
    ? Couldn't match expected type â€˜Integer -> tâ€™
                  with actual type â€˜[Char]â€™
    ? The first argument of ($) takes one argument,
      but its type â€˜[Char]â€™ has none
      In the expression: "aaa" ++ show $ 1 + 110
      In an equation for â€˜itâ€™: it = "aaa" ++ show $ 1 + 110
    ? Relevant bindings include it :: t (bound at <interactive>:9:1)

<interactive>:9:10: error:
    ? Couldn't match expected type â€˜[Char]â€™
                  with actual type â€˜() -> Stringâ€™
    ? Probable cause: â€˜showâ€™ is applied to too few arguments
      In the second argument of â€˜(++)â€™, namely â€˜showâ€™
      In the expression: "aaa" ++ show
      In the expression: "aaa" ++ show $ 1 + 110
```

ã‚«ãƒƒã‚³ã‚’è£œã†ã¨ã€â†“ã®ã‚ˆã†ã«è§£é‡ˆã•ã‚Œã¦ã—ã¾ã†ã€‚

```
ghci> ("aaa" ++ show) $ (1 + 110)
```

å‹ã‚¨ãƒ©ãƒ¼ã®åŸå› ã«æ°—ã¥ãã‚³ãƒ„

- ã“ã†ã„ã†ã¨ãã¯ä¸Šè¨˜ã®ã‚ˆã†ã«ã€å‹ã‚¨ãƒ©ãƒ¼ãŒæ³¢åŠã™ã‚‹ã®ã§ã€è¤‡æ•°ã®å‹ã‚¨ãƒ©ãƒ¼ãŒåŒã˜ç®‡æ‰€ã§ç™ºç”Ÿã™ã‚‹ã“ã¨ãŒå¤šã„ã€‚
  ã‚ˆãã‚ã‹ã‚‰ãªã„å‹ã‚¨ãƒ©ãƒ¼ãŒåŒã˜ç®‡æ‰€ã§è¤‡æ•°ã§ã¦ããŸå ´åˆã¯ã€æ¼”ç®—å­ã®å„ªå…ˆé †ä½ã‚’é–“é•ãˆãŸã“ã¨ã‚’ç–‘ã†ã¨ã„ã„ã‹ã‚‚ã—ã‚Œãªã„ã€‚
- `expected type`ã‹`actual type`ã®ã©ã¡ã‚‰ã‹ä¸€æ–¹ãŒé–¢æ•°ã«ãªã£ã¦ã„ã‚‹ã‘ã©ã€ã‚‚ã†ç‰‡æ–¹ãŒé–¢æ•°ã˜ã‚ƒãªã„æ™‚ï¼ˆã‚ã‚‹ã„ã¯ã€å¼•æ•°ã®æ•°ãŒãã‚Œãã‚Œã§ç•°ãªã‚‹ï¼‰å ´åˆã‚‚ç–‘ã†ã¨ã„ã„ã‹ã‚‚ã€‚
- ã“ã‚Œä»¥å¤–ã«ã‚‚åŒã˜ã‚ˆã†ãªå‹ã‚¨ãƒ©ãƒ¼ã«ãªã‚‹ã“ã¨ã¯ã‚ã‚Šã¾ã™ãŒã€ã„ãšã‚Œã«ã—ã¦ã‚‚ã€å˜ç´”ãªé–“é•ã„ã‚’ä¸€ã¤çŠ¯ã—ã¦ã„ã‚‹ã ã‘ã§ã‚ã‚‹å ´åˆãŒå¤šã„ã®ã§ã€**å‹ã‚¨ãƒ©ãƒ¼ãŒãŸãã•ã‚“å‡ºã¦ã‚‚æ…Œã¦ãªã„**ã“ã¨ãŒå¤§äº‹ã€‚

### é–¢æ•°åˆæˆæ¼”ç®—å­`.`ã§ä¸€ç•ªå³ã®å¤‰æ•°ã‚’æ¶ˆã™

```
ghci> :t (.)
(.) :: (b -> c) -> (a -> b) -> a -> c
```

2ã¤ã®é–¢æ•°`f`, `g`ã¨1ã¤ã®å¼•æ•°`x`ãŒã‚ã‚‹ã¨ãã€`(f . g) x`ã¯`f (g x)`ã¨ä¸€ç·’

`f . g`ã¨æ›¸ã„ã¦ã€Œ`g`ã®å¾Œã«`f`ï¼ˆ"`f` after `g`"ï¼‰ã€ã¨èª­ã‚€ã€‚

```
ghci> map (\s -> show (length s)) ["aaa", "bb", "c"]
["3","2","1"]
```

ã‚ã‚‹ã„ã¯

```
ghci> map (\s -> show $ length s) ["aaa", "bb", "c"]
["3","2","1"]
```

ã¨æ›¸ã„ã¦ã„ãŸã®ã‚’ã€

```
ghci> map (show . length) ["aaa", "bb", "c"]
["3","2","1"]
```

ã¨æ›¸ãæ›ãˆã‚‰ã‚Œã‚‹ã€‚

ãŸã ã—ã€â†“ã®ã‚ˆã†ã«ã¯æ›¸ã‘ãªã„ã®ã§æ³¨æ„

```
ghci> show . length "aaa"

<interactive>:3:8: error:
    ? Couldn't match expected type â€˜a -> ()â€™ with actual type â€˜Intâ€™
    ? Possible cause: â€˜lengthâ€™ is applied to too many arguments
      In the second argument of â€˜(.)â€™, namely â€˜length "aaa"â€™
      In the expression: show . length "aaa"
      In an equation for â€˜itâ€™: it = show . length "aaa"
    ? Relevant bindings include
        it :: a -> String (bound at <interactive>:3:1)
```

```
show . (length "aaa")
```

ã¨è§£é‡ˆã•ã‚Œã¦ã—ã¾ã†ãŸã‚ã€‚  
**é–¢æ•°å‘¼ã³å‡ºã—ãŒä¸€ç•ªå„ªå…ˆ**ã—ã¦çµåˆã•ã‚Œã‚‹ï¼

å½“ç„¶ã€é–¢æ•°å®šç¾©ã‚’æ›¸ãéš›ã«ã‚‚ä½¿ãˆã‚‹

```
reverseLines input = unlines $ reverse $ lines input
```

ã‚’ã€`.`ã§æ›¸ãæ›ãˆã¦ã€ä¸€ç•ªå³ã®å¼•æ•°ã‚’ãªãã™ï¼

```
reverseLines = unlines . reverse . lines
```

`.`ã¯ã€**ä¸€ç•ªå³ã®å¤‰æ•°ã‚’æ¶ˆã—ã¦ã€é–¢æ•°ã‚’ç¶šã‘ã¦é©ç”¨ã§ãã‚‹ã‚ˆã†ã«ã™ã‚‹**æ¼”ç®—å­ã¨è¦šãˆã‚‹

ã“ã®ã‚ˆã†ã«ã€`.`ãªã©ã®æ¼”ç®—å­ã‚’é§†ä½¿ã—ã¦å¼•æ•°ã‚„ï¼ˆ`let`ã§ä½œã‚‰ã‚Œã‚‹ï¼‰ãƒ­ãƒ¼ã‚«ãƒ«å¤‰æ•°ã‚’ã§ãã‚‹ã ã‘æ›¸ã‹ãªã„ã‚ˆã†ã«ã™ã‚‹æ›¸ãæ–¹ã‚’ã€ã€Œãƒã‚¤ãƒ³ãƒˆãƒ•ãƒªãƒ¼ã‚¹ã‚¿ã‚¤ãƒ«ã€ã¨ã„ã†ã€‚

### `$`ã¨`.`ã‚’çµ„ã¿åˆã‚ã›ã‚‹

å†ã³èª²é¡Œ4ã‹ã‚‰

```
ghci> unlines $ reverse $ lines "aaa\nbbb\nccc"
"ccc\nbbb\naaa\n"
```

ã¯ã€

```
ghci> unlines . reverse $ lines "aaa\nbbb\nccc"
"ccc\nbbb\naaa\n"
```

ã¨æ›¸ãæ›ãˆã‚‰ã‚Œã‚‹ã€‚

ã“ã†ã„ã†æ›¸ãæ–¹ã‚’å¥½ã‚€äººã‚‚å¤šã„ã€‚

```
ghci> unlines . reverse . lines $ "aaa\nbbb\nccc"
"ccc\nbbb\naaa\n"
```

`.`ã¨`$`ã®å„ªå…ˆé †ä½ã‚’æ€ã„å‡ºãã†ï¼  
ã‚ãã¾ã§ã‚‚ã€Œ`$`ãŒä¸€ç•ªçµåˆã®å„ªå…ˆé †ä½ãŒä½ã„æ¼”ç®—å­ã€ã¨ã„ã†ä¸€ç‚¹ã‚’æŠ¼ã•ãˆã¦ã€‚

ä¸€èˆ¬åŒ–ã™ã‚‹ã¨â†“ã®ã‚ˆã†ãªæ‰‹é †ã«

```
f0 (f1 (f2 (f3 arg1 arg2)))
```

`$`ã‚’ä½¿ã£ã¦ã‚«ãƒƒã‚³ã‚’æ¶ˆã—å»ã‚‹

```
f0 $ f1 (f2 (f3 arg1 arg2))
```

```
f0 $ f1 $ f2 (f3 arg1 arg2)
```

```
f0 $ f1 $ f2 $ f3 arg1 arg2
```

æœ€å¾Œ**ä»¥å¤–ã®**`$`ã‚’`.`ã«å¤‰ãˆã‚‹

```
f0 . f1 $ f2 $ f3 arg1 arg2
```

```
f0 . f1 . f2 $ f3 arg1 arg2
```

â†“ã¯ã‚„ã‚Šéã

```
f1 . f2 . f3 arg1 arg2
```

### æ¼”ç®—å­ã‚’å‰ç½®é–¢æ•°ã«å¤‰æ›ã™ã‚‹

`:t`ã«æ¸¡ã™ã¨ãã¯ã‚«ãƒƒã‚³ã§å›²ã†å¿…è¦ãŒã‚ã£ãŸã€‚

```
ghci> :t (+)
(+) :: Num a => a -> a -> a
```

ã‚«ãƒƒã‚³ã§å›²ã†ã¨ãã®ã¾ã¾å‰ç½®é–¢æ•°ã¨ã—ã¦ä½¿ãˆã‚‹ã€ã¨ã„ã†æ„å‘³ã§ã‚‚ã‚ã‚‹ã€‚

```
ghci> (+) 4 5
9
```

å½“ç„¶ã‚«ãƒªãƒ¼åŒ–ã‚‚ã•ã‚Œã¦ã„ã‚‹

```
ghci> :t (+) 4
(+) 4 :: Num a => a -> a
ghci> plus4 = (+) 4
ghci> plus4 5
9
```

å½“ç„¶ã€ãã®ã¾ã¾ä»–ã®é–¢æ•°ã«æ¸¡ã—ã¦ã‚‚OKï¼

```
ghci> map plus4 [1, 2, 3]
[5,6,7]
ghci> map ((+) 4) [1, 2, 3]
[5,6,7]
```

### æ¼”ç®—å­ã®ã‚»ã‚¯ã‚·ãƒ§ãƒ³

```
ghci> :t (/ 2)
(/ 2) :: Fractional a => a -> a
```

ã€ŒåŠåˆ†ã«ã™ã‚‹é–¢æ•°ã€ãŒã§ãã‚‹ï¼

```
ghci> (/ 2) 10
5.0
```

å…ˆé ­ã«`"Hello, "`ã‚’ãã£ã¤ã‘ã‚‹é–¢æ•°

```
ghci> :t (++)
(++) :: [a] -> [a] -> [a]

ghci> :t ("Hello, " ++)
("Hello, " ++) :: [Char] -> [Char]

ghci> map ("Hello, " ++) ["Tom", "Bob", "Alice"]
["Hello, Tom","Hello, Bob","Hello, Alice"]
```

ã•ã£ãã®ã€Œæ¼”ç®—å­ã‚’å‰ç½®é–¢æ•°ã«å¤‰æ›ã™ã‚‹ã€ã§ç´¹ä»‹ã—ãŸ

```
ghci> map ((+) 4) [1, 2, 3]
[5,6,7]
```

ã‚‚ã€

```
ghci> map (+ 4) [1, 2, 3]
[5,6,7]
```

ã¨æ›¸ã„ã¦ã„ã„ã—ã€è¶³ã—ç®—ã¯å³è¾ºã¨å·¦è¾ºã‚’å…¥ã‚Œæ›¿ãˆã¦ã‚‚çµæœãŒå¤‰ã‚ã‚‰ãªã„ã®ã§ã€

```
ghci> map (4 +) [1, 2, 3]
[5,6,7]
```

ã¨æ›¸ã„ã¦ã‚‚ã‚ˆã„ï¼

#### æ¼”ç®—å­ã®ã‚»ã‚¯ã‚·ãƒ§ãƒ³ã¯ã€ãƒã‚¤ãƒŠã‚¹ã ã‘ã¯ä½¿ã„ã«ãã„

```
ghci> :t (- 4)
(- 4) :: Num a => a
```

â†‘é–¢æ•°ã˜ã‚ƒãªã„ã€ã€Œ-4ã€ã¨ã„ã†æ•°ï¼

```
ghci> :t (4 -)
(4 -) :: Num a => a -> a
```

â†‘ã“ã¡ã‚‰ã¯é–¢æ•°

```
ghci> (- 4) 4

<interactive>:135:1: error:
    ? Non type-variable argument in the constraint: Num (t1 -> t2)
      (Use FlexibleContexts to permit this)
    ? When checking the inferred type
        it :: forall t1 t2. (Num t1, Num (t1 -> t2)) => t2

ghci> (4 -) 4
0
```

```
ghci> 5 * -3

<interactive>:145:1: error:
    Precedence parsing error
        cannot mix â€˜*â€™ [infixl 7] and prefix `-' [infixl 6] in the same infix expression
ghci> 5 * (-3)
-15
```

å˜é …æ¼”ç®—å­ã¨äºŒé …æ¼”ç®—å­ã‚’æ··ãœãŸã“ã¨ã«ã‚ˆã‚‹ã‚¨ãƒ©ãƒ¼ã€‚  
Haskellã§ã¯ãƒã‚¤ãƒŠã‚¹è¨˜å·ãŒå”¯ä¸€ã®å˜é …æ¼”ç®—å­ã§ã‚‚ã‚ã‚Šã€æ™®é€šã®äºŒé …æ¼”ç®—å­ã§ã‚‚ã‚ã‚‹ï¼ˆ[Haskell 2010 Language Reportã®ã€ŒOperator Applicationsã€ã‚ˆã‚Š][1]ï¼‰ã€‚

[1]: https://www.haskell.org/onlinereport/haskell2010/haskellch3.html#x8-280003.4

### ã‚„ã‚Šéãæ³¨æ„ã€ã‚ã‚‹ã„ã¯ã©ã“ã¾ã§ã‚„ã‚‹ã‹

ä¾‹1: `yes`ã‚„`Yes`ã‚„`yEs`ãªã©ã‚’æ¢ã™

å‰æ: `filter`é–¢æ•°ã€‚ç¬¬ä¸€å¼•æ•°ãŒ`True`ã‚’è¿”ã—ãŸè¦ç´ ã ã‘ã®ãƒªã‚¹ãƒˆã‚’è¿”ã™

```
ghci> :t filter
filter :: (a -> Bool) -> [a] -> [a]

-- 3ã‚ˆã‚Šå¤§ãã„æ•°
ghci> filter (\x -> x > 3) [4, 3, 6]
[4,6]

-- å½“ç„¶ã€ç¬¬ä¸€å¼•æ•°ã®é–¢æ•°ã¯ãƒ©ãƒ ãƒ€æŠ½è±¡ã®ä»£ã‚ã‚Šã«ã‚»ã‚¯ã‚·ãƒ§ãƒ³ã§æ›¸ã‘ã‚‹ã®ã§
ghci> filter (> 3) [4, 3, 6]
[4,6]
```

```
ghci> import Data.Char

-- å¤§æ–‡å­—ã«ã™ã‚‹ã¨ã€ŒYESã€ã«ãªã‚‹æ–‡å­—åˆ—ã ã‘ã‚’è¿”ã™
ghci> filter (\str -> map toUpper str == "YES") ["no", "yes", "yES", "iie", "YES"]
["yes","yES","YES"]
```

ã€Œ`toUpper`ã—ãŸçµæœãŒ`"YES"`ã¨ç­‰ã—ã„ã€

```
ghci> filter ((== "YES") . map toUpper) ["no", "yes", "yES", "iie", "YES"]
["yes","yES","YES"]
```

ã“ã®ãã‚‰ã„ãªã‚‰åºã®å£ï¼Ÿ

ã•ã£ãã®ã€

```
ghci> map ("Hello, " ++) ["Tom", "Bob", "Alice"]
["Hello, Tom","Hello, Bob","Hello, Alice"]
```

ã«ã€æœ«å°¾ã«ã€Œ!ã€ã‚’åŠ ãˆãŸããªã£ãŸã¨ã™ã‚‹ã€‚

```
ghci> map (("Hello, " ++) . (++ "!")) ["Tom", "Bob", "Alice"]
["Hello, Tom!","Hello, Bob!","Hello, Alice!"]
```

ã•ã‚‰ã«ã•ã‚‰ã«ã€ã©ã‚“ã©ã‚“ãƒã‚¤ãƒ³ãƒˆãƒ•ãƒªãƒ¼ã‚¹ã‚¿ã‚¤ãƒ«ã«ã™ã‚‹ã¨ã€èª­ã¿ã«ãããªã£ã¦ã—ã¾ã†ä¾‹ãŒ: [ãƒã‚¤ãƒ³ãƒˆãƒ•ãƒªãƒ¼ã‚¹ã‚¿ã‚¤ãƒ«ã¸ã®é“ ã€œæœ€å¤§å…¬ç´„æ•°ç·¨ã€œ - Qiita][2]  
ã“ã‚Œã¾ã§ã®èª²é¡Œã§ç´¹ä»‹ã—ã¦ã„ãªã„æ©Ÿèƒ½ã‚‚åˆ©ç”¨ã—ã¦ã„ã¾ã™ãŒå‚è€ƒã¾ã§ã«ã©ã†ãã€‚  
å¤§äº‹ãªã“ã¨ã¯ã€[**çŸ­ãæ›¸ã‘ã‚‹äººã‚’ä¸Šç´šè€…ã¨å‘¼ã¶ãª**][3]ã¨ã„ã†ã“ã¨ã§ã™ã€‚

[2]: https://qiita.com/necojackarc/items/1bccc9643857d3ce7896
[3]: https://wiki.haskell.jp/Hikers%20Guide%20to%20Haskell#%E3%83%9D%E3%82%A4%E3%83%B3%E3%83%88%E3%83%95%E3%83%AA%E3%83%BC%E3%82%B9%E3%82%BF%E3%82%A4%E3%83%AB%E3%81%82%E3%82%8B%E3%81%84%E3%81%AF%E6%A7%98%E3%80%85%E3%81%AA%E3%82%B9%E3%82%BF%E3%82%A4%E3%83%AB%E3%81%A8%E3%81%AE%E4%BB%98%E3%81%8D%E5%90%88%E3%81%84%E6%96%B9

### ãƒ©ãƒ ãƒ€æŠ½è±¡ã‚„é–¢æ•°ã®å¼•æ•°ã§ã®ãƒ‘ã‚¿ãƒ¼ãƒ³ãƒãƒƒãƒ

é–¢æ•°ã®å¼•æ•°ã§ç›´æ¥ãƒ‘ã‚¿ãƒ¼ãƒ³ãƒãƒƒãƒã§ãã‚‹

èª²é¡Œ11ã®`doubles`é–¢æ•°ã€æ•°å€¤ã®ãƒªã‚¹ãƒˆã‚’å—ã‘å–ã£ã¦ã™ã¹ã¦ã®è¦ç´ ã‚’2å€ã«ã™ã‚‹é–¢æ•°ã®å†å®Ÿè£…

```haskell
doubles xs =
    case xs of
        [] -> []
        x : xsLeft -> x * 2 : doubles xsLeft
```

ç¬¬1å¼•æ•°`xs`ã¯ç›´ã¡ã«`case`å¼ã§ä½¿ã‚ã‚Œã¦ã„ã‚‹ï¼  
ã“ã‚“ãªæ™‚ã¯ã“ã†æ›¸ãæ›ãˆã‚‰ã‚Œã‚‹:

```haskell
doubles [] = []
doubles (x : xsLeft) = x * 2 : doubles xsLeft
```

`->`ã®ä»£ã‚ã‚Šã«`=`ã§ãƒ‘ã‚¿ãƒ¼ãƒ³ã¨ãã®å®šç¾©ã‚’åŒºåˆ‡ã£ã¦ã„ã‚‹ç‚¹ã¨ã€`(x : xsLeft)`ã®ã‚ˆã†ã«ã€ãƒ‘ã‚¿ãƒ¼ãƒ³å…¨ä½“ã‚’**ã‚«ãƒƒã‚³ã§å›²ã†**å¿…è¦ãŒã‚ã‚‹ç‚¹ã«æ³¨æ„ã€‚

ã‚«ãƒƒã‚³ã§å›²ã†å¿…è¦ãŒã‚ã‚‹ã®ã¯ã€é–¢æ•°å®šç¾©ã§ã¯è¤‡æ•°ã®å¼•æ•°ã‚’æ‰±ã†ã“ã¨ãŒã‚ã‚‹ãŸã‚ã€‚  
ä¾‹ãˆã°`doubles`é–¢æ•°ã«å¼•æ•°ã‚’å¢—ã‚„ã—ã¦ã€å¼•æ•°ã§æŒ‡å®šã—ãŸæ•°ä»¥å¤–ã‚’æ›ã‘ã‚‰ã‚Œã‚‹ã‚ˆã†ã«ã—ãŸå ´åˆ:

```haskell
times n [] = []
times n (x : xsLeft) = x * n : times n xsLeft
```

`times n (x : xsLeft) = ...`ã®`(x : xsLeft)`ã‹ã‚‰ã‚«ãƒƒã‚³ã‚’å¤–ã—ã¦ã—ã¾ã†ã¨ã€

```haskell
ghci> :{
ghci| times n [] = []
ghci| times n x : xsLeft = x * n : times n xsLeft
ghci| :}

<interactive>:47:1: error: Parse error in pattern: times
```

ã¨ãªã£ã¦ã—ã¾ã„ã€`n`, `x`, `:`, `xsLeft`, ã¨ã„ã†4ã¤ã®å¼•æ•°ã‚’å—ã‘å–ã‚‹ã‚ˆã†ã«è¦‹ãˆã¦ã—ã¾ã†ã€‚

ãŠã¾ã‘ã«ã‹ã£ã“ã„ã„ä¾‹: ã‚ˆãè¦‹ã‹ã‘ã‚‹ï¼ˆ*ã§ã‚‚ã™ã”ãåŠ¹ç‡ãŒæ‚ªã„*ï¼‰`n`ç•ªç›®ã®ãƒ•ã‚£ãƒœãƒŠãƒƒãƒæ•°ã‚’è¨ˆç®—ã™ã‚‹é–¢æ•°

```
fib n =
    case n of
        0 -> 0
        1 -> 1
        _ -> fib (n - 2) + fib (n - 1)
```

`case`ã§æ›¸ãã¨â†‘ã®ãªã®ã‚’ã€

```
fib 0 = 0
fib 1 = 1
fib n = fib (n - 2) + fib (n - 1)
```

ã¨æ›¸ãæ›ãˆã‚‹ã“ã¨ãŒã§ãã‚‹ã€‚  
[å…ƒã€…ã®ãƒ•ã‚£ãƒœãƒŠãƒƒãƒæ•°ã®å®šç¾©][4]ã£ã½ãã¦ã‹ã£ã“ã„ã„ï¼  
ï¼ˆã§ã‚‚ã„ãšã‚Œã«ã—ã¦ã‚‚åŠ¹ç‡ã¯ã™ã”ãæ‚ªã„ã®ã§ãã‚Œãã‚Œã‚‚ä½¿ã‚ãªã„ã“ã¨ï¼‰

[4]: https://ja.wikipedia.org/wiki/%E3%83%95%E3%82%A3%E3%83%9C%E3%83%8A%E3%83%83%E3%83%81%E6%95%B0#%E6%A6%82%E8%A6%81

#### ãƒ¬ã‚³ãƒ¼ãƒ‰å‹ã«å¯¾ã™ã‚‹é–¢æ•°ã®å¼•æ•°ã§ã®ãƒ‘ã‚¿ãƒ¼ãƒ³ãƒãƒƒãƒ

è‡ªåˆ†ã§å®šç¾©ã—ãŸå‹ã§ã‚‚OKï¼

â€»ã“ã“ã¨æ¬¡ã®ã‚¿ãƒ—ãƒ«ã®ç¯€ã§ç´¹ä»‹ã™ã‚‹ãƒ‘ã‚¿ãƒ¼ãƒ³ãƒãƒƒãƒã¯`case`å¼ã§ã‚‚ä½¿ãˆã¾ã™ãŒã€ç‰¹ã«å¼•æ•°ã§ã®ãƒ‘ã‚¿ãƒ¼ãƒ³ãƒãƒƒãƒã§ä½¿ã†ã“ã¨ãŒå¤šã„ã§ã™ã€‚

ä¾‹ãˆã°ãŠãªã˜ã¿`Entry`å‹ã‚’ä½¿ã£ã¦

```
data Entry =
  Entry { category :: String, price :: Integer }
  deriving Show
```

å€¤ã‚³ãƒ³ã‚¹ãƒˆãƒ©ã‚¯ã‚¿ãƒ¼`Entry`ã®ç¬¬ä¸€å¼•æ•°ã«ã‚ãŸã‚‹`category`ã€ç¬¬äºŒå¼•æ•°ã«ã‚ãŸã‚‹`price`ã€ãã‚Œãã‚Œã«ãƒ‘ã‚¿ãƒ¼ãƒ³ãƒãƒƒãƒã§ãã‚‹ï¼

```
ghci> :{
ghci| formatEntry :: Entry -> String
ghci| formatEntry (Entry cat pri) = cat ++ ": " ++ show pri
ghci| :}

ghci> entry = Entry "Magazine" 120
ghci> formatEntry entry
"Magazine: 120"
```

ãƒ‘ã‚¿ãƒ¼ãƒ³ãƒãƒƒãƒã¯å…¥ã‚Œå­ã«ãªã£ãŸæ§‹é€ ã®ä¸­ã®è¦ç´ ã«å¯¾ã—ã¦ã‚‚ã§ãã‚‹ã®ã§ã€ã•ã‚‰ã«`category`ãŒç©ºæ–‡å­—åˆ—ã®ã‚‚ã®ã‚’ç‰¹åˆ¥æ‰±ã„ã—ãŸããªã£ãŸã‚‰:

```
ghci> :{
ghci| formatEntry :: Entry -> String
ghci| formatEntry (Entry "" pri) = "<Unknown category>" ++ ": " ++ show pri
ghci| formatEntry (Entry cat pri) = cat ++ ": " ++ show pri
ghci| :}

ghci> entry = Entry "" 999999999999999
ghci> formatEntry entry
"<Unknown category>: 999999999999999"
```

ã“ã“ã§ã‚‚ã‚«ãƒƒã‚³ã‚’å¿˜ã‚Œãšï¼

```
ghci> :{
ghci| formatEntry :: Entry -> String
ghci| formatEntry Entry cat pri = cat ++ ": " ++ show pri
ghci| :}

<interactive>:89:13: error:
    ? The constructor â€˜Entryâ€™ should have 2 arguments, but has been given none
    ? In the pattern: Entry
      In an equation for â€˜formatEntryâ€™:
          formatEntry Entry cat pri = cat ++ ": " ++ show pri
      The equation(s) for â€˜formatEntryâ€™ have three arguments,
      but its type â€˜Entry -> Stringâ€™ has only one
```

ã“ã†ã„ã†é¢¨ã«ãƒ¬ã‚³ãƒ¼ãƒ‰ãƒ©ãƒ™ãƒ«ã‚’ç”¨ã„ãŸãƒ‘ã‚¿ãƒ¼ãƒ³ãƒãƒƒãƒã‚’ã™ã‚Œã°ã€ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã®é †ç•ªãŒé•ã£ã¦ã„ã¦ã‚‚ã‚ˆã„ã€‚

```
ghci> :{
ghci| formatEntry :: Entry -> String
ghci| formatEntry (Entry { category = "",  price = pri }) = "<Unknown category>" ++ ": " ++ show pri
ghci| formatEntry (Entry { category = cat, price = pri }) = cat ++ ": " ++ show pri
ghci| :}
```

#### ã‚¿ãƒ—ãƒ«ã«å¯¾ã™ã‚‹é–¢æ•°ã®å¼•æ•°ã§ã®ãƒ‘ã‚¿ãƒ¼ãƒ³ãƒãƒƒãƒ

ä¾¿åˆ©ãªã‚µãƒ³ãƒ—ãƒ«ãŒ[`Prelude`ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«][5]ã«ã„ãã¤ã‹ã‚ã‚‹ã€‚  
ä»¥ä¸‹ã¯ã‚½ãƒ¼ã‚¹ã‚³ãƒ¼ãƒ‰ã‹ã‚‰ã®æŠœç²‹:

[5]: https://hackage.haskell.org/package/base-4.12.0.0/docs/Prelude.html#g:3

```
fst :: (a, b) -> a
fst (x, _) = x

snd :: (a, b) -> b
snd (_, y) = y
```

èª²é¡Œ8ã§ç´¹ä»‹ã—ãŸã¨ãŠã‚Šã€ã“ã‚Œã‚‰ã¯`Prelude`ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã«å…¥ã£ã¦ã„ã‚‹ã®ã§ã€ä½•ã‚‚`import`ã—ãªãã¦ã‚‚ä½¿ãˆã‚‹

ãŠã¾ã‘: `curry`ã¨`uncurry`

`curry`ã¯ã€Œï¼ˆã‚µã‚¤ã‚º2ã®ï¼‰ã‚¿ãƒ—ãƒ«ã‚’å—ã‘å–ã‚‹é–¢æ•°ã€ã‚’ï¼ˆHaskellã®ä¸–ç•Œã§æ™®é€šã®ã€ã‚«ãƒªãƒ¼åŒ–ã•ã‚ŒãŸï¼‰2å¼•æ•°é–¢æ•°ã«å¤‰æ›ã™ã‚‹ã€‚

```
curry :: ((a, b) -> c) -> a -> b -> c
curry f x y = f (x, y)
```

`uncurry`ã¯ãã®é€†ã€‚ã“ã“ã§ã‚¿ãƒ—ãƒ«ã«å¯¾ã™ã‚‹ãƒ‘ã‚¿ãƒ¼ãƒ³ãƒãƒƒãƒãŒå‡ºã¦ãã‚‹ã€‚

```
uncurry :: (a -> b -> c) -> ((a, b) -> c)
uncurry f (x, y) = f x y
```

ãŠãã‚‰ã`uncurry`ã®æ–¹ãŒå®Ÿè·µã§ã¯ã‚ˆãä½¿ã†

å…¸å‹çš„ãªä½¿ç”¨ä¾‹: `Map`æ–¹ã®å€¤ã‚’`toList`é–¢æ•°ã§å¤‰æ›ã—ãŸçµæœã‚’ã€ãã®ã¾ã¾2å¼•æ•°ã®é–¢æ•°ã«æ¸¡ã™

`(+)`ã‚’`uncurry`é–¢æ•°ã§ã‚¿ãƒ—ãƒ«ã‚’å—ã‘å–ã‚‹é–¢æ•°ã«å¤‰æ›ã™ã‚‹ã“ã¨ã§ã€`toList`çµæœã®å€¤ã‚’ãã®ã¾ã¾ä½¿ãˆã‚‹ã€‚

```
ghci> import qualified Data.Map.Strict as M

ghci> numberAndChars = M.fromList [(1, 3), (2, 4)]
ghci> map (uncurry (+)) $ M.toList numberAndChars
[4,6]
```

ãƒ©ãƒ ãƒ€æŠ½è±¡ã§æ›¸ãæ›ãˆã‚‹ã¨â†“ã¨åŒã˜

```
ghci> map (\pair -> fst pair + snd pair) $ M.toList numberAndChars
[4,6]
```

#### ãƒ©ãƒ ãƒ€æŠ½è±¡ã®å¼•æ•°ã§ã®ãƒ‘ã‚¿ãƒ¼ãƒ³ãƒãƒƒãƒ

å¼•æ•°ã§ã®ãƒ‘ã‚¿ãƒ¼ãƒ³ãƒãƒƒãƒã¯ã€ãƒ©ãƒ ãƒ€æŠ½è±¡ã§ã‚‚ä½¿ãˆã‚‹ã€‚

ã¤ã¾ã‚Šã€

```
tupleToEntry :: (String, Integer) -> Entry
tupleToEntry (cat, pri) = Entry cat pri
```

â†‘ã¨â†“ã¯åŒã˜ï¼

```
tupleToEntry :: (String, Integer) -> Entry
tupleToEntry = \(cat, pri) -> Entry cat pri
```

èª²é¡Œ8ã§â†“ã®ã‚ˆã†ã«æ›¸ã„ã¦ã„ãŸã®ã¨å®Ÿè³ªåŒã˜ã‚ˆã†ãªã‚‚ã®ã€‚

```
-- ...
let (divResult, modResult) = divMod numerator denominator
-- ...
```

ãƒ‘ã‚¿ãƒ¼ãƒ³ãƒãƒƒãƒã«é–¢ã™ã‚‹è©±ã‚’ã¾ã¨ã‚ã‚‹ã¨

- åŸå‰‡1: å€¤ã‚³ãƒ³ã‚¹ãƒˆãƒ©ã‚¯ã‚¿ãƒ¼ã§å€¤ã‚’çµ„ã¿ç«‹ã¦ã‚‹ã®ã¨é€†ã®ã“ã¨ã‚’ã™ã‚‹ã®ãŒãƒ‘ã‚¿ãƒ¼ãƒ³ãƒãƒƒãƒã€‚
    - ãƒªã‚¹ãƒˆã«ã¯ `[x, y]` ã¨ã„ã†æ§‹æ–‡ã®ã€ç‰¹åˆ¥ãªå€¤ã‚³ãƒ³ã‚¹ãƒˆãƒ©ã‚¯ã‚¿ãƒ¼ãŒã‚ã‚‹ã€‚æœ¬æ¥ã¯`x : y : []`ã€‚
- åŸå‰‡2: é–¢æ•°ã®å¼•æ•°ã‚’å«ã‚ãŸã€å¤‰æ•°ã¸ã®ä»£å…¥ã‚’è¡Œã†ã‚ã‚‰ã‚†ã‚‹å ´é¢ã§ãƒ‘ã‚¿ãƒ¼ãƒ³ãƒãƒƒãƒã¯ä½¿ãˆã‚‹ã€‚

ã§ã‚‚ã€ã“ã‚Œã¯å±ãªã„ï¼

```
ghci> dangerous = \(Just x) -> x
```

ãƒ©ãƒ ãƒ€æŠ½è±¡ã¯

```
dangerous (Just x) = x
dangerous Nothing = "error!"
```

ã¿ãŸã„ã«ã€é–¢æ•°å®šç¾©ã®æ§‹æ–‡ã®ã‚ˆã†ã«å¼•æ•°ã§ãƒ‘ã‚¿ãƒ¼ãƒ³ãƒãƒƒãƒã—ã¦ã‚‚å ´åˆåˆ†ã‘ãŒã§ããªã„ã®ã§ã€

```
dangerous = \(Just x) -> x
```

ã¿ãŸã„ã«æ›¸ããŸããªã£ãŸã‚‰ã€â†“ã®ã‚ˆã†ãª`case`ã«å¤‰æ›ã™ã‚‹ã—ã‹ãªã„ï¼ˆ`LambdaCase`ã«ã¤ã„ã¦ã¯ã„ã¤ã‹è„šæ³¨ã«ï¼‰ã€‚

```
dangerous = \mx ->
    case mx of
        Just x  -> ...
        Nothing -> ...
```

çµæœã€ã†ã£ã‹ã‚Š`Nothing`ãŒæ¸¡ã•ã‚Œã¦ã‚¨ãƒ©ãƒ¼ã«ãªã£ã¦ã—ã¾ã†ã“ã¨ã‚‚

```
ghci> dangerous Nothing
*** Exception: <interactive>:8:2-15: Non-exhaustive patterns in lambda
```

è­¦å‘Šã‚’æœ‰åŠ¹ã«ã—ã¦ã‚‚æ•™ãˆã¦ãã‚Œãªã„ğŸ˜±

```
ghci> :set -Wall
ghci> dangerous = (\(Just x) -> x)
```

`-Wincomplete-uni-patterns`ã‚’æœ‰åŠ¹ã«ã—ãªã„ã¨ã„ã‘ãªã„ï¼

```
ghci> :set -Wincomplete-uni-patterns
ghci> dangerous = \(Just x) -> x

<interactive>:10:2: warning: [-Wincomplete-uni-patterns]
    Pattern match(es) are non-exhaustive
    In a lambda abstraction: Patterns not matched: Nothing
```

[GHCã®å°†æ¥ã®ãƒãƒ¼ã‚¸ãƒ§ãƒ³ã§ã€`-Wincomplete-uni-patterns`ãŒ`-Wall`ã«å«ã¾ã‚Œã‚‹][6]ã‹ã‚‚ã€‚

[6]: https://gitlab.haskell.org/ghc/ghc/issues/15656

`-Wall`ã‚’æœ‰åŠ¹ã«ã—ã¦ã‚‚æœ‰åŠ¹ã«ãªã‚‰ãªã„è­¦å‘Šã®ä¸€è¦§ã¯[GHC Users Guide][7]ã‚’å‚ç…§ã€‚

<https://functor.tokyo/blog/2017-07-28-ghc-warnings-you-should-enable>

[7]: https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/using-warnings.html#ghc-flag--Wall

## HLintã§æ”¹å–„ç‚¹ã‚’ã‚ã‚‹ç¨‹åº¦è‡ªå‹•ã§è¦‹ã¤ã‘ã‚‹

```bash
shell> cabal install hlint
# ã‚ã‚‹ã„ã¯...
shell> stack install hlint
```

ã“ã“ã§ç´¹ä»‹ã—ã¦ã„ãªã„`TupleSections`ã¨ã„ã†GHCã®æ‹¡å¼µã‚’ä½¿ã£ãŸã‚‚ã®ã‚‚ï¼ˆGHCã®æ‹¡å¼µã®è©±ã‚’å¾Œå›ã—ã«ã—ãŸã„ã®ã§æ•¢ãˆã¦ç´¹ä»‹ã—ã¦ã„ã¾ã›ã‚“... ã‚ã—ã‹ã‚‰ãšï¼‰ã€‚

```bash
shell> hlint assets/16.hs
assets/16.hs:18:14: Warning: Avoid lambda
Found:
  \ x y -> x + y
Perhaps:
  (+)

assets/16.hs:19:19: Suggestion: Use tuple-section
Found:
  \ w -> (w, 1)
Perhaps:
  (, 1)
Note: may require `{-# LANGUAGE TupleSections #-}` adding to the top of the file

2 hints
```

HLintã®ã•ã‚‰ã«ä¾¿åˆ©ãªä½¿ã„æ–¹ã¯[ç´ æ™´ã‚‰ã—ã HLint ã‚’ä½¿ã„ã“ãªã™][7]ã‚’ã€‚  
ã€Œã“ã®é–¢æ•°ã¯ã“ã®ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ä»¥å¤–ã§ã¯ä½¿ã‚ãªã„ã§ãã ã•ã„ã€ãªã©ã¨ã„ã†ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆå›ºæœ‰ã®ãƒ«ãƒ¼ãƒ«ã‚’è¨­å®šã™ã‚‹ã“ã¨ã‚‚ã§ãã¾ã™ã€‚

[7]: https://haskell.e-bigmoon.com/posts/2018-01-29-awesome-hlint.html
