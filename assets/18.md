# 引数名をなるべく書かない（ポイントフリースタイル）

課題16の回答を書き換えて、できるだけ簡潔に書いてみましょう。  
今回は純粋にリファクタリングをしてください。特に振る舞いを変える必要はありません。

## 必要な知識

### （カリー化された）関数の部分適用

`map`関数

```
ghci> :t map
map :: (a -> b) -> [a] -> [b]
```

関数`(a -> b)`とリスト`[a]`という、引数を二つ受け取る

```
ghci> map (\x -> x * 2) [3, 8, 9]
[6,16,18]
```

引数を一つだけ適用すると

```
ghci> map (\x -> x * 2)

<interactive>:5:1: error:
    ? No instance for (Show ([Integer] -> [Integer]))
        arising from a use of ‘print’
        (maybe you haven't applied a function to enough arguments?)
    ? In a stmt of an interactive GHCi command: print it
```

`No instance for (Show ([Integer] -> [Integer]))`: 「整数のリストを受け取って整数のリストを返す関数`[Integer] -> [Integer]`は、`Show`型クラスのインスタンスではない」というエラー

`map (\x -> x * 2)`は、`[Integer] -> [Integer]`という型の値！

```
ghci> :t map (\x -> x * 2)
map (\x -> x * 2) :: Num b => [b] -> [b]
```

言うとおりに`[Integer]`、整数のリストを渡してみよう！

```
ghci> doubles = map (\x -> x * 2)
ghci> doubles [3, 8, 9]
[6,16,18]
```

`map (\x -> x * 2) [3, 8, 9]`と同じ結果が返った！

なぜ

```
a -> b -> c
```

という2つの引数を受け取る関数は、実は、カッコを補うと...

```
a -> (b -> c)
```

という、`a`という一つの値を受け取って、`(b -> c)`という型の関数を返す関数。  
`a`型の値を1つ受け取ることによって、

```
(b -> c)
```

という、引数を（残り）一つ受け取る関数になる。

Haskellには（厳密な意味では）「一つの引数を受け取って一つの値を返す関数」しか存在しない。  
「関数を返す関数」を組み合わせることによって、「二つ（以上）の引数を返す関数」を表現する。

これを、関数が「カリー化」されているという。

※でも実際には「この関数は二つの引数を受け取る」みたいな言い方を普通にする。  
「Haskellには一つの引数を受け取る関数しかないのだから～」と思うのはよくある誤解。

これを利用すると、余計なラムダ式を書かずに済んだり、引数名を一つ考えなくてよくなったりする。

例えば「文字列のリストにおける、すべての文字を大文字にする」という処理を↓のように書いていたのを、

```
ghci> import Data.Char

ghci> map (\s -> map toUpper s) ["hello", "world!"]
["HELLO","WORLD!"]
```

↓と書き換えることができる。

```
ghci> map (map toUpper) ["hello", "world!"]
["HELLO","WORLD!"]
```

「引数を1個適用した新しい関数」を簡単に作れる！

ところで、これまで紹介した、「関数を受け取る関数」はこんな型だった↓

```
ghci> :t map
map :: (a -> b) -> [a] -> [b]
```

もし`(a -> b)`のカッコがない、

```
map :: a -> b -> [a] -> [b]
```

という型であれば「`a`、`b`、`[a]`という**三つの**引数を受け取り、`[b]`を返す関数」という意味になってしまう。

関数を表す`->`という型は、右結合（同じ優先順位の演算子を複数並べたとき、右辺に書かれた式が優先して結合される）なので、カッコを書かなければ「関数を受け取る関数」を宣言できない。

### 関数適用演算子`$`でカッコを減らす

関数適用演算子 `$`

```
ghci> :t ($)
($) :: (a -> b) -> a -> b
```

関数`(a -> b)`とその引数となる値`a`を受け取って、結果となる値`b`を返す。

使い方

```
ghci> words $ "abc def"
["abc","def"]
```

```
ghci> putStrLn $ "Hello, world!"
Hello, world!
```

普通に関数を実行するのと一緒！

```
ghci> words "abc def"
["abc","def"]
ghci> putStrLn "Hello, world!"
Hello, world!
```

#### `:i` コマンドで、演算子の優先順位を確認する

`:i`は型クラスの定義を確認する以外にも、いろいろ使える。

演算子をカッコで囲って渡すと、優先順位がわかる

```
ghci> :i ($)
($) :: (a -> b) -> a -> b       -- Defined in ‘GHC.Base’
infixr 0 $
```

`infixr 0 $`という部分が演算子の優先順位を示す。  
`infixr`で右結合の演算子、`infixl`で左結合の演算子。  
渡した`0`から`9`までの数字が大きければ大きいほど、結合の優先順位が高い。  
つまり、`infixr 0 $`は最弱。

他の演算子とも比べてみましょう。

```
ghci> :i (+)
-- ... 省略 ...
infixl 6 +

ghci> :i (-)
-- ... 省略 ...
infixl 6 -

ghci> :i (*)
-- ... 省略 ...
infixl 7 *

ghci> :i (/)
-- ... 省略 ...
infixl 7 /
```

足し算`(+)`引き算`(-)`よりかけ算`(*)`割り算`(/)`の方が優先順位が高く、左結合になっていることがわかります。  
いずれにしても`infixr 0 $`よりは強い

```
ghci> :i (++)
(++) :: [a] -> [a] -> [a]       -- Defined in ‘GHC.Base’
infixr 5 ++
```

こちらも`infixr 0 $`よりは強い

なので！

例えば

```
ghci> print (1 + 2 + 3)
6
```

を、

```
ghci> print $ 1 + 2 + 3
6
```

と書いたり

```
ghci> putStrLn ("aaa" ++ show 111)
aaa111
```

を、

```
ghci> putStrLn $ "aaa" ++ show 111
aaa111
```

と書いたり、課題4で書いていた

```
ghci> unlines (reverse (lines "aaa\nbbb\nccc"))
"ccc\nbbb\naaa\n"
```

を、

```
ghci> unlines $ reverse $ lines "aaa\nbbb\nccc"
"ccc\nbbb\naaa\n"
```

と書いたりできる。

要するに「`$`よりも後ろはカッコが自動で補われる」と考えるといい。

ただし、↓のように、`$`よりも結合の優先順位が高い演算子が左側にある場合はダメ:

```
ghci> "aaa" ++ show $ 1 + 110

<interactive>:9:1: error:
    ? Couldn't match expected type ‘Integer -> t’
                  with actual type ‘[Char]’
    ? The first argument of ($) takes one argument,
      but its type ‘[Char]’ has none
      In the expression: "aaa" ++ show $ 1 + 110
      In an equation for ‘it’: it = "aaa" ++ show $ 1 + 110
    ? Relevant bindings include it :: t (bound at <interactive>:9:1)

<interactive>:9:10: error:
    ? Couldn't match expected type ‘[Char]’
                  with actual type ‘() -> String’
    ? Probable cause: ‘show’ is applied to too few arguments
      In the second argument of ‘(++)’, namely ‘show’
      In the expression: "aaa" ++ show
      In the expression: "aaa" ++ show $ 1 + 110
```

カッコを補うと、↓のように解釈されてしまう。

```
ghci> ("aaa" ++ show) $ (1 + 110)
```

型エラーの原因に気づくコツ

- こういうときは上記のように、型エラーが波及するので、複数の型エラーが同じ箇所で発生することが多い。
  よくわからない型エラーが同じ箇所で複数でてきた場合は、演算子の優先順位を間違えたことを疑うといいかもしれない。
- `expected type`か`actual type`どちらか一方が関数になっているけど、もう片方が関数じゃない時（あるいは、引数の数がそれぞれで異なる）場合も疑うといいかも。
- これ以外にも同じような型エラーになることはありますが、いずれにしても、単純な間違いを一つ犯しているだけである場合が多いので、**型エラーがたくさん出ても慌てない**ことが大事。

### 関数合成演算子`.`で一番右の変数を消す

```
ghci> :t (.)
(.) :: (b -> c) -> (a -> b) -> a -> c
```

2つの関数`f`, `g`と1つの引数`x`があるとき、`(f . g) x`は`f (g x)`と一緒

`f . g`と書いて「`g`の後に`f`（"`f` after `g`"）」と読む。

```
ghci> map (\s -> show (length s)) ["aaa", "bb", "c"]
["3","2","1"]
```

あるいは

```
ghci> map (\s -> show $ length s) ["aaa", "bb", "c"]
["3","2","1"]
```

と書いていたのを、

```
ghci> map (show . length) ["aaa", "bb", "c"]
["3","2","1"]
```

と書き換えられる。

ただし、↓のようには書けないので注意

```
ghci> show . length "aaa"

<interactive>:3:8: error:
    ? Couldn't match expected type ‘a -> ()’ with actual type ‘Int’
    ? Possible cause: ‘length’ is applied to too many arguments
      In the second argument of ‘(.)’, namely ‘length "aaa"’
      In the expression: show . length "aaa"
      In an equation for ‘it’: it = show . length "aaa"
    ? Relevant bindings include
        it :: a -> String (bound at <interactive>:3:1)
```

```
show . (length "aaa")
```

と解釈されてしまうため。  
**関数呼び出しが一番優先**して結合される！

当然、関数定義を書く際にも使える

```
reverseLines input = unlines $ reverse $ lines input
```

を、`.`で書き換えて、一番右の引数をなくす！

```
reverseLines = unlines . reverse . lines
```

`.`は、**一番右の変数を消して、関数を続けて適用できるようにする**演算子と覚える

このように、`.`などの演算子を駆使して引数や（`let`で作られる）ローカル変数をできるだけ書かないようにする書き方を、「ポイントフリースタイル」という。

### `$`と`.`を組み合わせる

再び課題4から

```
ghci> unlines $ reverse $ lines "aaa\nbbb\nccc"
"ccc\nbbb\naaa\n"
```

は、

```
ghci> unlines . reverse $ lines "aaa\nbbb\nccc"
"ccc\nbbb\naaa\n"
```

と書き換えられる。

`.`と`$`の優先順位を思い出そう！

一般化すると↓のような手順に


```
f0 (f1 (f2 (f3 arg1 arg2)))
```

`$`を使ってカッコを消し去る

```
f0 $ f1 (f2 (f3 arg1 arg2))
```

```
f0 $ f1 $ f2 (f3 arg1 arg2)
```

```
f0 $ f1 $ f2 $ f3 arg1 arg2
```

最後**以外の**`$`を`.`に変える

```
f0 . f1 $ f2 $ f3 arg1 arg2
```

```
f0 . f1 . f2 $ f3 arg1 arg2
```

↓はやり過ぎ

```
f1 . f2 . f3 arg1 arg2
```

### 演算子を前置関数に変換する

```
ghci> :t (+)
(+) :: Num a => a -> a -> a
```

```
ghci> (+) 4 5
9
```

当然カリー化もされている

```
ghci> :t (+) 4
(+) 4 :: Num a => a -> a
ghci> plus4 = (+) 4
ghci> plus4 5
9
```

当然、そのまま他の関数に渡してもOK！

```
ghci> map plus4 [1, 2, 3]
[5,6,7]
ghci> map ((+) 4) [1, 2, 3]
[5,6,7]
```

### 演算子のセクション

```
ghci> :t (/ 2)
(/ 2) :: Fractional a => a -> a
```

「半分にする関数」ができる！

```
ghci> (/ 2) 10
5.0
```

先頭に`"Hello, "`をくっつける関数

```
ghci> :t ("Hello, " ++)
("Hello, " ++) :: [Char] -> [Char]
ghci> map ("Hello, " ++) ["Tom", "Bob", "Alice"]
["Hello, Tom","Hello, Bob","Hello, Alice"]
```

さっきの「演算子を前置関数に変換する」で紹介した

```
ghci> map ((+) 4) [1, 2, 3]
[5,6,7]
```

も、

```
ghci> map (+ 4) [1, 2, 3]
[5,6,7]
```

と書いていいし、足し算は右辺と左辺を入れ替えても結果が変わらないので、

```
ghci> map (4 +) [1, 2, 3]
[5,6,7]
```

と書いてもよい！

`yes`や`Yes`や`yEs`などを探す

```
import Data.Char
ghci> filter (\str -> map toLower str == "yes") ["no", "yes", "yES", "iie", "YES"]
["yes","yES","YES"]
```

「`toLower`した結果が`"yes"`と等しい」

```
ghci> filter ((== "yes") . map toLower) ["no", "yes", "yES", "iie", "YES"]
["yes","yES","YES"]
```

### やり過ぎ注意、あるいはどこまでやるか

さっきの、

```
ghci> map ("Hello, " ++) ["Tom", "Bob", "Alice"]
["Hello, Tom","Hello, Bob","Hello, Alice"]
```

に、末尾に「!」を加えたくなったとする。

```
ghci> map (("Hello, " ++) . (++ "!")) ["Tom", "Bob", "Alice"]
["Hello, Tom!","Hello, Bob!","Hello, Alice!"]
```

このくらいなら序の口？

さらにさらに

どんどんポイントフリースタイルにすると、読みにくくなってしまう例: [ポイントフリースタイルへの道 〜最大公約数編〜 - Qiita][1]  
これまでの課題で紹介していない機能も利用していますが参考までにどうぞ。  
大事なことは、[**短く書ける人を上級者と呼ぶな**][2]ということです。

[1]: https://qiita.com/necojackarc/items/1bccc9643857d3ce7896
[2]: https://wiki.haskell.jp/Hikers%20Guide%20to%20Haskell#%E3%83%9D%E3%82%A4%E3%83%B3%E3%83%88%E3%83%95%E3%83%AA%E3%83%BC%E3%82%B9%E3%82%BF%E3%82%A4%E3%83%AB%E3%81%82%E3%82%8B%E3%81%84%E3%81%AF%E6%A7%98%E3%80%85%E3%81%AA%E3%82%B9%E3%82%BF%E3%82%A4%E3%83%AB%E3%81%A8%E3%81%AE%E4%BB%98%E3%81%8D%E5%90%88%E3%81%84%E6%96%B9

### ラムダ式や関数の引数でのパターンマッチ

関数の引数で直接パターンマッチできる

課題11の`doubles`関数、数値のリストを受け取ってすべての要素を2倍にする関数の再実装

```haskell
doubles xs =
    case xs of
        [] -> []
        x : xsLeft -> x * 2 : doubles xsLeft
```

第1引数`xs`は直ちに`case`式で使われている！  
こんな時はこう書き換えられる:

```haskell
doubles [] = []
doubles (x : xsLeft) = x * 2 : doubles xsLeft
```

`->`の代わりに`=`でパターンとその定義を区切っている点と、`(x : xsLeft)`のように、パターン全体を**カッコで囲う**必要がある点に注意。

カッコで囲う必要があるのは、関数定義では複数の引数を扱うことがあるため。  
例えば`doubles`関数に引数を増やして、引数で指定した数以外を掛けられるようにした場合:

```haskell
times n [] = []
times n (x : xsLeft) = x * n : doubles xsLeft
```

おまけにかっこいい例: よく見かける（*でもすごく効率が悪い*）`n`番目のフィボナッチ数を計算する関数

```
fib n =
    case n of
        0 -> 0
        1 -> 1
        _ -> fib (n - 2) + fib (n - 1)
```

`case`で書くと↑のとおりなのを、

```
fib 0 = 0
fib 1 = 1
fib n = fib (n - 2) + fib (n - 1)
```

と書き換えることができる。  
[元々のフィボナッチ数の定義](https://ja.wikipedia.org/wiki/%E3%83%95%E3%82%A3%E3%83%9C%E3%83%8A%E3%83%83%E3%83%81%E6%95%B0#%E6%A6%82%E8%A6%81)っぽくてかっこいい！

自分で定義した型でもOK！

```
data Entry =
  Entry { category :: String, price :: Integer } deriving Show
```

こういう風にレコードラベルを用いたパターンマッチをすれば、フィールドの順番が違っていてもよい。

```

```

タプルでもOK！

```

```

引数でのパターンマッチは、ラムダ式でも使える。

```

```

課題8で↓のように書いていたのと同じようなもの。

```
-- ...
let (divResult, modResult) = divMod numerator denominator
-- ...
```

当然、タプル以外の型でも良い。

関数の引数を含めた、変数の代入ができるあらゆる場面で使える、と思って良い。

でも、これは危ない！

```
ghci> (\(Just x) -> x) $ Nothing
*** Exception: <interactive>:8:2-15: Non-exhaustive patterns in lambda
```

警告を有効にしても教えてくれない😱

```
ghci> :set -Wall
ghci> (\(Just x) -> x) $ Nothing
*** Exception: <interactive>:8:2-15: Non-exhaustive patterns in lambda
```

`-Wincomplete-uni-patterns`を有効にしないといけない！

```
ghci> :set -Wincomplete-uni-patterns
ghci> (\(Just x) -> x) $ Nothing

<interactive>:10:2: warning: [-Wincomplete-uni-patterns]
    Pattern match(es) are non-exhaustive
    In a lambda abstraction: Patterns not matched: Nothing
*** Exception: <interactive>:10:2-15: Non-exhaustive patterns in lambda
```

[GHCの将来のバージョンで、`-Wincomplete-uni-patterns`が`-Wall`に含まれる][3]かも。

[3]: https://gitlab.haskell.org/ghc/ghc/issues/15656
