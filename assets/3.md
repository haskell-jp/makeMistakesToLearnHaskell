# 複数の命令を並べる

下記のような簡単なアスキーアートを標準出力に書き込むプログラムを書きましょう。

**注: 表示が崩れる場合は、等幅フォントで再度表示してみてください。**

```
#     # ####### #       #        #####
#     # #       #       #       #     #
#     # #       #       #       #     #
####### #####   #       #       #     #
#     # #       #       #       #     #
#     # #       #       #       #     #
#     # ####### ####### #######  #####
```

## 必要な知識

今回の課題を解決する方法はいくつも考えられますが、ここでは2つの方法を紹介します。

### 文字列リテラルの中での改行文字

Haskellの文字列リテラルは、改行文字を直接含めることができません。  
下記のように、GHCiでダブルクォート`"`の中に改行を挟もうとすると、エラーになります。

```haskell
ghci>  "newline here:

<interactive>:11:5: error:
    lexical error in string/character literal at end of input
```

文字列リテラルの中での改行は、必ず `\n` というバックスラッシュ（環境によっては円マークに見えるかも知れません）で始まる、エスケープシーケンスを使用してください。  
ほかのプログラミング言語でも馴染みがある文字列かと思います。

```haskell
ghci> "newline here:\nafter newline"
"newline here:\nafter newline"
```

最初の課題で使用した`putStrLn`関数を使えば、改行が混ざったことがよりわかりやすいでしょう。

```haskell
ghci> putStrLn "newline here:\nafter newline"
newline here:
after newline
```

### `do`記法

最初の課題で使用した`putStrLn`関数は、渡した文字列の末尾に、自動的に改行文字を加えて出力します。  
この特徴を利用すれば、`putStrLn`関数を複数の行に渡って連続して実行することで、`\n` を使った場合よりも、視覚的に分かりやすく複数行の文字列を表示できます。

ただし、Haskellはちょっと変わっていて、`putStrLn`関数をそのまま複数行書いても、エラーになってしまいます。  
例えば、以下のようなソースを`no-do.hs`という名前のファイルに保存し、`runhaskell`で実行してみます。

```haskell
main =
  putStrLn "newline here:"
  putStrLn "after newline"
```

下記のようなエラーになるでしょう。

```
shell> stack exec runhaskell no-do.hs

test\assets\3\no-do.hs:2:3: error:
    • Couldn't match expected type ‘(String -> IO ()) -> [Char] -> t’
                  with actual type ‘IO ()’
    • The function ‘putStrLn’ is applied to three arguments,
      but its type ‘String -> IO ()’ has only one
      In the expression:
        putStrLn "newline here:" putStrLn "after newline"
      In an equation for ‘main’:
          main = putStrLn "newline here:" putStrLn "after newline"
    • Relevant bindings include
        main :: t (bound at test\assets\3\no-do.hs:1:1)
  |
2 |   putStrLn "newline here:"
  |   ^^^^^^^^^^^^^^^^^^^^^^^^...
```

わかりづらいのですが、エラーメッセージの

```
    • The function ‘putStrLn’ is applied to three arguments,
      but its type ‘String -> IO ()’ has only one
```

という箇所から、「`putStrLn`に渡した引数が多すぎる」ということが読み取れるでしょうか？  
実はHaskellは、最初の`putStrLn`に対して`"newline here:"`, `putStrLn`, `"after newline"`という、3つの引数を渡したと解釈しています。  
つまり他のプログラミング言語の構文で例えると、下記のように`putStrLn`関数を呼び出した、と解釈したのです。

```
putStrLn("newline here:", putStrLn, "after newline")
```

実際にはこれまでに使ってきたとおり、`putStrLn`は1つの引数しか受け取らない関数なので、これではエラーになってしまいます。

このエラーを解決する（一つの）方法が、`do`記法です。  
`do`記法は、`putStrLn`をはじめとする「命令」を、連続して実行するよう「つなげる」ための便利な構文です。  
ここでは詳細に立ち入りませんが、`putStrLn`だけでなく、Haskellのソースコードの様々な箇所で使われます。  
あの、「モナド(`Monad`)」を理解する上で非常に重要な機能となっていますので、お楽しみに。

そんな`do`記法は、下記のように使用します。

```haskell
main = do
  putStrLn "newline here:"
  putStrLn "after newline"
```

先ほどの間違った例と比べて違うのは、`main =`の後に`do`が書いてあるかないか、それだけです。  
後はほかのよくあるプログラミング言語と似たように、`putStrLn "newline here:"`などの連続して実行したい命令を改行で切って並べれば、並べた命令を続けて実行できます。  
それ故に書き忘れてしまい、先ほどのようなわかりづらいエラーになってしまうことも多いので、ご注意ください。

もちろん、3つ以上命令を並べたいときも同様です。

```haskell
main = do
  putStrLn "あ"
  putStrLn "い"
  putStrLn "う"
  putStrLn "え"
  putStrLn "お"
```

#### GHCi上で`do`記法を試す

ここまで読んですでに試した方もいらっしゃるかと思うので紹介しておきましょう。  
GHCi上で`do`記法をそのまま入力しようとすると、下記のようなエラーになります。

```haskell
ghci> do

<interactive>:4:1: error: Empty 'do' block
```

これを回避する方法はいくつかありますが、ここでは一番使いやすい`:set +m`を使った方法を紹介します。

GHCiの設定を変えるコマンド`:set`に`+m`という引数を渡すと、複数行のコマンドが入力できるようになります。

```
ghci> :set +m
ghci| do
ghci| putStrLn "aaa"
ghci| putStrLn "bbb"
ghci|
aaa
bbb
```

※上記の`ghci| `という表記は、行の続きを入力する際に表示されるプロンプトです。`ghci> `と同様、設定によって違う表示になるかと思います。

入力を終了させたい場合は、空行を入力してください。

`:set +m`を毎回入力するのが面倒だ、という場合は、`~/.ghci`というファイルに、`:set +m`を追記しましょう。

## 課題の解き方

Haskell固有の機能を覚えるため、今回は、必ず`do`記法を使用して解いてください。
