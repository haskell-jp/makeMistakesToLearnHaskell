# 自分で型を定義する・文字列を結合する

課題2.5で紹介したアプリケーション作りに向けて、「分類」と「金額」を持ったレコード型を作り、その内容を出力するプログラムを書きましょう。  
具体的には:

1. 標準入力から2行の入力を受け取ります。
1. 1行目は「分類」を表す文字列として解釈します。
1. 2行目は「金額」を表す整数として解釈します。
1. 「分類」に`Category: `というプレフィックスをつけて、標準出力に出力してください。
1. 「金額」に、`Price: `というプレフィックスをつけて、標準出力に出力してください。

## 必要な知識

下記については課題5と同様なので省略します。  
ただし1行目の「分類」はそのまま文字列として扱うので、`read`関数を使ってはいけない点に注意してください。

- `getLine`で標準入力から1行ずつ読み出す
- `read`で入力を数値に変換する

### 自分でレコード型を定義する

今回は後の学習のために、自分でオリジナルの型を定義する方法を学習しましょう。  
実際のところ、今回の課題の要件を満たすだけのプログラムでは、特に自分で型を定義する必要はありません。  
それでも敢えてここで型を定義する方法を説明するのは、次のメリットがあるためです。

- 作っているプログラムが対象としているデータを分類して、名前をつけて、意味を明確にすることができる。
- 対象としているデータに紐付いた複数の値を、まとめて1つの値として扱うことができる。

例えば、課題2.5で「これから作るアプリケーション」として掲げたものでは、ファイルの1行ごとに、「分類」と「金額」という複数の値が紐付いたものを、いくつも扱うことになります。  
「分類」と「金額」という複数の値に名前をつけてまとめて一つの値として扱えるようにすれば、幾分扱いやすくなるかと思います。  
ほかのオブジェクト指向のプログラミング言語に慣れた方にとっては、「分類」と「金額」を持つクラスを作る、という感覚で考えていただいて差し支えありません。

#### `data`宣言でレコード型を定義する

Haskellにおいて自分で型を定義する方法はいくつかありますが、今回はそのうち、「レコード型」を宣言する方法を紹介します。  
「分類」と「金額」という複数の値を持ったレコード型を定義するには、下記のように`data`宣言を使用しましょう。

```haskell
data Entry =
  Entry
  { category :: String
  , price :: Integer
  }
```

`data 型の名前 = 型の定義`で、新しい型を定義できます。  
`do`記法の範囲をインデントで示していたのと同様に、`data`以降の箇所が複数行にまたぐ場合は、以降の行をインデントして範囲を示します。  
上記の場合`Entry =`の`=`以降を改行していますね。

`型の定義`の箇所には、「値コンストラクター」の定義を書きます。  
「値コンストラクター」は、**定義しようとしている型の値が、どのような値を含んでいるのか**を定義したものです。  

「値コンストラクター」は次のような形式で、定義されます。

```haskell
値コンストラクターの名前
{ レコードラベルの名前1 :: レコードラベルに含まれる型1
, レコードラベルの名前2 :: レコードラベルに含まれる型2
, ...
, レコードラベルの名前N :: レコードラベルに含まれる型N
}
```

先ほどの`Entry`型で言うと、

```
  Entry
  { category :: String
  , price :: Integer
  }
```

の部分が該当します。

こちらもわかりやすさのために改行やスペースを挟んでいますが、実際には

```
  Entry { category :: String, price :: Integer }
```

と一行で書いてもいいですし、

```
  Entry {
    category :: String,
    price :: Integer
  }
```

のように、ブレース `{}` やカンマ `,` の位置を、お好みに合わせてずらしてみてもよいです。

さて、ここまで例として挙げた`Entry`型の値コンストラクターは、次のように定義されることとなります。

- 値コンストラクターの名前が（型の名前と同じ）`Entry`で、
- レコードラベルとしては、
    - 名前が`category`で、`String`型のレコードラベルと、
    - 名前が`price`で、`Intger`型のレコードラベルがあります。

型の名前が`Entry`で値コンストラクターの名前も同じ`Entry`であるため、少し混乱してしまうかもしれません。  
実際には型の名前と値コンストラクターの名前が同じである必要はないのですが、レコード型を定義する際は、慣習上同じ名前にすることが多いです。  
それぞれを違う名前にするケースについては、どうかこの先にご期待ください hask(\_ \_)eller。

#### レコード型を使う

続いて、`Entry`型が一体どのように使われるか確認するために、実際に使ってみましょう。  
ついでに、その際に便利なGHCiの機能をいくつか覚えましょう。

##### GHCiの`:{`と`:}`で、複数行の入力をできるようにする

先ほど書いた`Entry`型の定義をそのままGHCiに貼り付けると、エラーになってしまいます。

```haskell
ghci> data Entry =

<interactive>:15:13: error:
    parse error (possibly incorrect indentation or mismatched brackets)
ghci>   Entry

<interactive>:16:3: error: Data constructor not in scope: Entry
ghci>   { category :: String
Prelude|   , price :: Integer
Prelude|   }

<interactive>:18:3: error: parse error on input ‘,’
```

ずいぶんたくさんのエラーになってしまいましたが、これは、GHCiが改行を入力した時点で「入力が終わった！」と見なして、入力を評価しようとしてしまうからです。

例えば、`data Entry =`と入力した時点で出た

```
<interactive>:15:13: error:
    parse error (possibly incorrect indentation or mismatched brackets)
```

というエラーは、途中で`data`宣言が終わったとGHCiが見なしてしまったために出たエラーです。

これを回避するためにはGHCiに「これから複数行の入力が始まるよ！」と教えてあげましょう。  
そのためには`:{`というGHCi専用のコマンドを使います。

```
ghci> :{
Prelude| data Entry =
Prelude|   Entry
Prelude|   { category :: String
Prelude|   , price :: Integer
Prelude|   }
Prelude| :}
ghci>
```

`:{` で複数行の入力を始めて、`:}`で終了させます。
GHCiの特殊なコマンドなので、いずれもコロン`:`で始める点に注意してください！  
それから、`:{`で囲った場合も、最初に改行した後（`data Entry =`の後）の行において、インデントが必要な点にも注意しましょう。  
今度はちゃんとエラーがなく宣言できたようですね。

##### GHCiの`:t`で、関数や値の型を確かめる

`Entry`型が出来たことを確認するために、`:t`というコマンドを使ってみましょう。  
`:t`（`:type`の略）は、関数や値の型を確認するためのGHCiのコマンドです。  
`:t <Haskellの式>`と書くと、`<Haskellの式>`がどんな型になっているのか教えてくれます。

```haskell
ghci> :t Entry
Entry :: String -> Integer -> Entry

ghci> :t category
category :: Entry -> String

ghci> :t price
price :: Entry -> Integer
```

`:t`コマンドに渡せるようになっていることから察せられるとおり、先ほど`data`宣言で定義した`Entry`や`category`、`price`が、Haskellの式として利用できるようになりました！  
それでは`:t`コマンドが出した結果について説明しましょう。

まず、

```haskell
ghci> :t Entry
Entry :: String -> Integer -> Entry
```

の`:t Entry`ですが、これは先ほどの`Entry`型の定義で言うところの、値コンストラクターで宣言された`Entry`の型を示しています。  
「`Entry`は`String -> Integer -> Entry`という型だよ」と、`:t`コマンドは教えてくれています。
それで、`String -> Integer -> Entry`とはなんぞや、という話ですが、これは2つの引数を受け取る関数を表しています。  
最初の`String -> Integer ->`という部分までが関数の引数の型を表しています。  
そして、最後に出てきた`Entry`が戻り値の型を表しています。  
つまり、`Entry :: String -> Integer -> Entry`という表記は、**「`Entry`という関数は`String`型の値と`Integer`型の値を受け取って、`Entry`の値を返す関数だよ」**という意味です。

従って、`Entry`はそのまま関数として使えるようになっています。  
試してみましょう。

```haskell
Entry "あんパン" 120
```

##### GHCiで変数に値を代入する

```haskell
ghci> entry = Entry "Comic" 120
ghci> :t entry
entry :: Entry
```

#### レコードラベルを使って、レコードが持つ値を取得する

```haskell
ghci> price entry
120
ghci> category entry
"Comic"
```<`0`>

##### GHCiの`:i`で、型の定義を確かめる


### `let`で変数に純粋な値を代入する



### `++`で文字列を結合する


### `show`関数で数値を文字列に変換する


