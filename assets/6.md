# 自分で型を定義する・文字列を結合する

課題2.5で紹介したアプリケーション作りに向けて、「分類」と「金額」を持ったレコード型を作り、その内容を出力するプログラムを書きましょう。  
具体的には:

1. 標準入力から2行の入力を受け取ります。
2. 1行目は「分類」を表す文字列として解釈します。
3. 2行目は「金額」を表す整数として解釈します。
4. 「分類」に`Category: `というプレフィックスをつけて、標準出力に出力してください。
5. 「金額」に、`Price: `というプレフィックスをつけて、標準出力に出力してください。

## 必要な知識

下記については課題5と同様なので省略します。  
ただし1行目の「分類」はそのまま文字列として扱うので、`read`関数を使ってはいけない点に注意してください。

- `getLine`で標準入力から1行ずつ読み出す
- `read`で入力を数値に変換する

### 自分でレコード型を定義する

今回は後の学習のために、自分でオリジナルの型を定義する方法を学習しましょう。  
実際のところ、今回の課題の要件を満たすだけのプログラムでは、特に自分で型を定義する必要はありません。  
それでも敢えてここで型を定義する方法を説明するのは、次のメリットがあるためです。

- 作っているプログラムが対象としているデータを分類して、名前をつけて、意味を明確にすることができる。
- 対象としているデータに紐付いた複数の値を、まとめて1つの値として扱うことができる。

例えば、課題2.5で「これから作るアプリケーション」として掲げたものでは、ファイルの1行ごとに、「分類」と「金額」という複数の値が紐付いたものを、いくつも扱うことになります。  
「分類」と「金額」という複数の値に名前をつけてまとめて一つの値として扱えるようにすれば、幾分扱いやすくなるかと思います。  
ほかのオブジェクト指向のプログラミング言語に慣れた方にとっては、「分類」と「金額」を持つクラスを作る、という感覚で考えていただいて差し支えありません。

#### `data`宣言でレコード型を定義する

Haskellにおいて自分で型を定義する方法はいくつかありますが、今回はそのうち、「レコード型」を宣言する方法を紹介します。  
「分類」と「金額」という複数の値を持ったレコード型を定義するには、下記のように`data`宣言を使用しましょう。

```haskell
data Entry =
  Entry
  { category :: String
  , price :: Integer
  }
```

`data 型の名前 = 型の定義`で、新しい型を定義できます。  
`do`記法の範囲をインデントで示していたのと同様に、`data`以降の箇所が複数行にまたがる場合は、以降の行をインデントして範囲を示します。  
上記の場合`Entry =`の`=`以降を改行していますね。

`型の定義`の箇所には、「値コンストラクター」の定義を書きます。  
「値コンストラクター」は、**定義しようとしている型の値が、どのような値を含んでいるのか**を定義したものです。  

レコード型の「値コンストラクター」は次のような形式で定義されます。

```haskell
値コンストラクターの名前
{ レコードラベルの名前1 :: レコードラベルに含まれる型1
, レコードラベルの名前2 :: レコードラベルに含まれる型2
, ...
, レコードラベルの名前N :: レコードラベルに含まれる型N
}
```

先ほどの`Entry`型で言うと、

```haskell
  Entry
  { category :: String
  , price :: Integer
  }
```

の部分が値コンストラクターの定義に該当します。

こちらもわかりやすさのために改行やスペースを挟んでいますが、実際には

```
  Entry { category :: String, price :: Integer }
```

と一行で書いてもいいですし、

```haskell
  Entry {
    category :: String,
    price :: Integer
  }
```

のように、ブレース `{}` やカンマ `,` の位置を、お好みに合わせてずらしてよいです（慣習的にブレースやカンマを行頭に書く方が多いですが）。

さて、ここまで例として挙げた`Entry`型の値コンストラクターは、次のように定義されることとなります。

- 値コンストラクターの名前が（型の名前と同じ）`Entry`で、
- レコードラベルとしては、
    - 名前が`category`で、`String`型のレコードラベルと、
    - 名前が`price`で、`Intger`型のレコードラベルがあります。

型の名前が`Entry`で値コンストラクターの名前も同じ`Entry`であるため、ちょっと混乱してしまうかもしれません。  
実際には型の名前と値コンストラクターの名前が同じである必要はないのですが、レコード型を定義する際は、慣習上同じ名前にすることが多いです。  
それぞれを違う名前にするケースについては、どうかこの先にご期待ください hask(\_ \_)eller。

#### レコード型を使う

続いて、`Entry`型が一体どのように使われるか確認するために、実際に使ってみましょう。  
ついでに、その際に便利なGHCiの機能をいくつか覚えましょう。

##### GHCiの`:{`と`:}`で、複数行の入力をできるようにする

先ほど書いた`Entry`型の定義をそのままGHCiに貼り付けると、エラーになってしまいます。

```haskell
ghci> data Entry =

<interactive>:15:13: error:
    parse error (possibly incorrect indentation or mismatched brackets)
ghci>   Entry

<interactive>:16:3: error: Data constructor not in scope: Entry
ghci>   { category :: String
ghci|   , price :: Integer
ghci|   }

<interactive>:18:3: error: parse error on input ‘,’
```

ずいぶんたくさんのエラーになってしまいましたが、これは、GHCiが改行を入力した時点で「入力が終わった！」と見なして、入力を評価しようとしてしまうからです。

例えば、`data Entry =`と入力した時点で出た

```
<interactive>:15:13: error:
    parse error (possibly incorrect indentation or mismatched brackets)
```

というエラーは、`data Entry =`の時点で`data`宣言が終わったとGHCiが見なしてしまったために出たエラーです。

これを回避するためには、GHCiに「これから複数行の入力が始まるよ！」と教えてあげましょう。  
そのためには`:{`というGHCi専用のコマンドを使います。

```
ghci> :{
ghci| data Entry =
ghci|   Entry
ghci|   { category :: String
ghci|   , price :: Integer
ghci|   }
ghci| :}
ghci>
```

`:{` で複数行の入力を始めて、`:}`で終了させます。  
GHCiの特殊なコマンドなので、いずれもコロン`:`で始める点に注意してください！  
それから、`:{`で囲った場合も、最初に改行した後（`data Entry =`の後）の行において、インデントが必要な点にも注意しましょう。  
今度はちゃんとエラーがなく宣言できたようですね。

##### GHCiの`:t`で、関数や値の型を確かめる

`Entry`型が出来たことを確認するために、`:t`というコマンドを使ってみましょう。  
`:t`（`:type`の略）は、関数や値の型を確認するためのGHCiのコマンドです。  
`:t <Haskellの式>`と書くと、`<Haskellの式>`がどんな型になっているのか教えてくれます。

```haskell
ghci> :t Entry
Entry :: String -> Integer -> Entry

ghci> :t category
category :: Entry -> String

ghci> :t price
price :: Entry -> Integer
```

`:t`コマンドに渡せるようになっていることから察せられるとおり、先ほど`data`宣言で定義した`Entry`や`category`、`price`が、Haskellの式として利用できるようになりました！  
それでは`:t`コマンドが出した結果について説明しましょう。

まず、

```haskell
ghci> :t Entry
Entry :: String -> Integer -> Entry
```

における`:t Entry`の結果ですが、これは先ほどの`Entry`型の定義で言うところの、「値コンストラクター」で宣言された`Entry`の型を示しています。  
「`Entry`は`String -> Integer -> Entry`という型だよ」と、`:t`コマンドは教えてくれています。
それで、`String -> Integer -> Entry`とはなんぞや、という話ですが、これは2つの引数を受け取る関数を表しています。  
最初の`String -> Integer ->`という部分までが関数の引数の型を示しています。  
`String`型と`Integer`型の値を1つずつ受け取る、という意味です。  
そして、最後に出てきた`Entry`が戻り値の型に該当します。  
文字通り、`Entry`型の値を返す、ということですね。  
つまり、`Entry :: String -> Integer -> Entry`という表記は、**「`Entry`という関数は`String`型の値と`Integer`型の値を受け取って、`Entry`型の値を返す関数だよ」**という意味です。

なんと、`Entry`はそのまま関数として使えるようになっている、ということです！  
試してみましょう。

```haskell
ghci> Entry "Magazine" 120

<interactive>:8:1: error:
    • No instance for (Show Entry) arising from a use of ‘print’
    • In a stmt of an interactive GHCi command: print it
```

... おっと、型エラーになってしまいました。  
前の課題5でも触れたとおり、`No instance for ...`で始まるエラーは型エラーです。  
ここで注目していただきたいのは、`No instance for (Show Entry)`の`Show Entry`という箇所です。  
先ほど`data`で宣言した`Entry`型についてのエラーであることが読み取れますね！  
このエラーは、`Entry`型の値を`print`関数 --- 課題2で触れた、GHCiが式を評価した際に使用する関数ですね --- に渡したことによるエラーです。   
したがって、期待どおり`Entry`型の値はできているようです😌。  
それでは、次の節で作った`Entry`型の値を活用する方法を説明しましょう。

##### GHCiで変数に値を代入する

先ほどのエラーのとおり、残念ながら現状ではGHCiで直接`Entry`型の値を表示させることはできないようなので、一旦`Entry`型の値を変数に代入してみましょう。  
GHCiで変数に値を代入する場合、前の課題で学習した`let`を使うことができますが、実はGHCi上では`let`を省略することもできます[1]。  
と、言うわけで先ほどと同様に`Entry`型の値を作って、変数に代入してみましょう。

[1]: 昔のバージョンのGHCiでは省略できなくなっています。ご注意ください。

```haskell
ghci> magazine = Entry "Magazine" 120
```

今度は特にエラーが起こりませんでしたね。  
ちゃんと`Entry`型の値が作られていることを確認するために、`:t`を使いましょう。

```haskell
ghci> :t magazine
magazine :: Entry
```

「`magazine`は`Entry`という型だよ」と教えてくれました。確かに`Entry`型の値が作られましたね。  
先ほど使った`Entry`という関数の型が`String -> Integer -> Entry`、すなわち「`String`型の値と`Integer`型の値を受け取って、`Entry`型の値を返す関数」となっていたとおり、確かに`String`と`Integer`の値を渡したら`Entry`型の値が作られました。  
これが、先ほど`data`宣言で定義した「値コンストラクター」の役目です。  
「値コンストラクター」は「定義しようとしている型の値が、どのような値を含んでいるのか」宣言することで、自動的に宣言した型の値を作るための関数も提供してくれます。  
この「宣言した型の値を作るための関数」は、よくあるオブジェクト指向言語における、クラスのコンストラクターと似ています。  
クラスのコンストラクターを定義する際は、どの引数をどのフィールドに代入するか書かねばならず、しばしばボイラープレートになりがちです。  
一方、`data`宣言で値の構造を定義すると、それだけで対象の型を作る関数、つまり値コンストラクターまで提供してくれます。便利ですね！  
（もっと柔軟に値を作れるようにしたい場合や、値コンストラクターで定義した値の構造を隠蔽したい場合は、値コンストラクターのラッパー関数を書いて、それだけを使用させるようにしましょう。詳細はこの先の課題で。）

#### レコードラベルを使って、レコードが持つ値を取得する

`Entry`型の値を作って、変数に代入することまでできました。  
いよいよ、`Entry`型の値に入った「分類」や「金額」を取り出してみましょう。

先ほど`:t`コマンドを紹介したときに例示した、`:t category`と`:t price`を思い出してください。

```haskell
ghci> :t category
category :: Entry -> String

ghci> :t price
price :: Entry -> Integer
```

これらは、`Entry`の値コンストラクターの定義に書かれていた、「レコードラベル」です。  
上記のとおり、レコードラベルに対して`:t`コマンドを実行すると、「定義したレコード型の値を受け取って、レコードラベルに紐付いた型を返す関数だよ」と教えてくれます。  
例えば`category`の場合、`category`は`String`型のレコードラベルなので、「`Entry`型の値を受け取って、`String`を返す関数だよ」といった具合ですね。  
察しの良い方はこの時点で使い方が思い浮かぶことでしょう。

```haskell
ghci> category magazine
"Magazine"
ghci> price magazine
120
```

そう、レコードラベルは、そのまま、レコード型の値を受け取って対応する値を返す関数となっているのです！  
他の多くのプログラミング言語と比べると、これは結構変わっているでしょう。

#### レコード型の値を書き換える

今回の課題では特に必要がないですが、レコード型の値を書き換える方法についてもついでに学んでおきましょう。  
価格`price`を0にした、無料の雑誌を作ってみます。

```haskell
ghci> freeMagazine = magazine { price = 0 }

ghci> :t freeMagazine
freeMagazine :: Entry

ghci> price freeMagazine
0

ghci> category freeMagazine
"Magazine"
```

冒頭の`magazine { price = 0 }`という式が、`magazine`の`price`というレコードラベルの値を書き換える式です。  
一般化すると`レコード型の値 { レコードラベル名 = 新しい値 }`ですね。  
残念ながら、「セッター関数」のようなものは自動で作られず、こちらのとおり更新する専用の構文を使うことになります。

ここで何より注目していただきたいのは、`magazine { price = 0 }`という式は、`magazine`というレコードの値を**直接書き換えるのではなく**、`magazine`を元に`price`だけが異なる**新しいレコードを作って返す**、ただそれだけしかしない、と言う点です。  
その証拠として、`magazine`の`price`がどうなっているか確認してみましょう。

```
ghci> price magazine
120
```

最初に定義した`120`のままですね！120円だとすると安い！🤑

前の課題で触れた「純粋な計算」という概念を思い出してください。  
「純粋な計算」は、関数や演算子に渡した値からしか影響を受けないし、`let`で代入する変数以外に影響を与えることもないのでした。  
これはレコード型の値を書き換える式`magazine { price = 0 }`についても同様です。  
`magazine { price = 0 }`が影響を与えるべきなのは、あくまでも結果を代入する`freeMagazine`という変数に対して、であり、`magazine`という変数（が含むレコード）に対してではないのです！

なお、複数のレコードラベルの値を書き換えたい場合は、次のように、カンマで区切りましょう。  
今度はもう少し現実的な、アニメのBlu-rayでも想定してみます。

```haskell
ghci> ordinayBluray = magazine { category = "Blu-ray", price = 7344 }
ghci> category ordinayBluray
"Blu-ray"
ghci> price ordinayBluray
7344
```

ちゃんと、`category`と`price`、両方のレコードラベルの値を更新できていますね！

#### レコードラベルと値コンストラクターを使ってレコード型の値を作成する

またまた今回の課題では特に必要がないですが、ここではレコード型の値をもっとわかりやすく作る方法を紹介します。  
先ほどレコード型の値を作る際は、値コンストラクター（先ほど定義した型では`Entry`）をそのまま関数として使いました。

```haskell
ghci> entry = Entry "Magazine" 120
ghci> category entry
"Magazine"
ghci> price entry
120
```

この方法では、残念ながらレコードラベルの数が増えた場合、「何番目の引数が何番目のレコードラベルに該当するのか」がわかりづらくなってしまうでしょう。

そうしたケースに対応するため、下記のように、どのレコードラベルにどんな値を代入するか、明確にする方法があります。

```haskell
ghci> categoryFirst = Entry { category = "Glasses", price = 23000 }
ghci> category categoryFirst
"Glasses"
ghci> price categoryFirst
23000
```

先ほど、レコードラベルの値を書き換える際に使用した構文↓

```haskell
ghci> ordinayBluray = magazine { category = "Blu-ray", price = 7344 }
```

の、書き換える対象のレコードの箇所（上記の例では`magazine`）を、値コンストラクター（先ほどの例では`Entry`）に置き換えたバージョンだと考えると、理解しやすいのではないかと思います。

もちろん、レコードラベルの順番を入れ替えて書いても問題ありません。

```haskell
ghci> priceFirst = Entry { price = 110, category = "Drink" }
ghci> category priceFirst
"Drink"
ghci> price priceFirst
110
```

このような特徴から、この構文は、他のプログラミング言語で言うところの「関数の名前付きパラメーター」の代わりにしばしば使われます。  
「名前付きパラメーターのためにいちいち新しいレコード型を定義しないといけないの？」と感じる方もいらっしゃるかもしれませんが、「本当に必要になるぐらい引数が増えるまで名前付きパラメーターにしない」という運用でどうかご勘弁ください！ hask(\_ \_)eller

### `++`で文字列を結合する

さて、課題の実装方法に話を戻しましょう。  
ここまでで、自分で定義したレコード型の値に、入力を格納する方法を学びました。  
ここからは、レコード型に格納したそれぞれの値を出力する前に、プレフィックスとなる文字列を結合する方法を紹介します。

Haskellで文字列を結合するには、ズバリ、`++`という演算子を使ってください！

```haskell
ghci> "Hello, " ++ "world!"
"Hello, world!"
```

`+`は、あくまでも数値用の演算子となっています。  
文字列に対して使うと、型エラーになってしまいます。

```
ghci> "Hello, " + "world!"

<interactive>:40:1: error:
    • No instance for (Num [Char]) arising from a use of ‘+’
    • In the expression: "Hello, " + "world!"
      In an equation for ‘it’: it = "Hello, " + "world!"
```

ちなみに、実はHaskellの（標準の）文字列は、文字のリストになっています（リストについては課題4を参照）。  
`++`は実際のところ、文字列だけでなく、任意のリストを結合する関数となっています。  
なので、下記のように、`++`は数値のリストも結合することが出来ます。

```haskell
ghci> [1, 2, 3] ++ [9, 8, 7]
[1,2,3,9,8,7]
```

### `show`関数で数値を文字列に変換する

`++`で文字列を結合することに加え、もう一点課題を解くために知っておくとよい関数があります。  
それは、`show`関数です。

先ほど触れたとおり、文字列は文字のリストです。  
そして、課題4で触れたとおり、リストは、**同じ型の**複数の値を表すのに使用されます。  
つまり、一つのリストに入っている値は、すべて同じ型の値でないといけません。

ここで今回の課題の要件を思い出してください。  
今回の課題の要件上、「金額」は一旦整数として格納しないといけません。  
そして、その整数として格納された「金額」に対して`Price: `というプレフィックスをつけるには、文字列として結合する必要があります。  
数値と文字列（文字のリスト）は違う型なので、そのままでは結合できないのです。

```haskell
ghci> "My salary is " ++ 200000 ++ " yen!"

<interactive>:14:20: error:
    • No instance for (Num [Char]) arising from the literal ‘200000’
    • In the first argument of ‘(++)’, namely ‘200000’
      In the second argument of ‘(++)’, namely ‘200000 ++ " yen!"’
      In the expression: "My salary is " ++ 200000 ++ " yen!"
```

ちゃんと結合するには、一旦`show`関数で文字列に変換しましょう。

```haskell
ghci> "My salary is " ++ show 200000 ++ " yen!"
"My salary is 200000 yen!"
```

ちなみに、`print`関数が標準出力に書き込む際に使用しているのが、この`show`関数です。  
なので、`print`関数は数値も標準出力に書き込むことが出来ます。

## 課題の解き方

今回の課題は、工夫次第で実は`++`も`show`も使わずに解くことが出来ますが、使った方が読みやすいソースコードになると思いますので、少なくとも最初に解くときは`++`と`show`を使用してください。
