# 連想配列を扱う

指定したファイルに書かれた単語の出現回数をカウントするプログラムを書きましょう。

1. コマンドライン引数のリストを取得します。
2. コマンドライン引数のリストの各要素に対して、次の処理を実行します:
    1. 各要素である文字列をファイルのパスとして解釈し、その中身を読みます。
    2. 読んだファイルの中身を、空白で区切った、単語のリストに変換します。
3. コマンドライン引数で指定された各ファイルに含まれる単語の出現回数を数えます。
4. カウントしたそれぞれの単語について、  
  ```
  <単語> => <出現回数>
  ```

  という形式の行で表示します。

## 入出力例

`sample-input.txt`という、下記の内容のファイルがあったとき:

```
aaa	ddd
bbb	a
bbb	ddd
aaa	aaa
ccc	d
```

```
shell> stack exec runhaskell assets/16.hs sample-input.txt
```

と実行すると、

```
a => 1
aaa => 3
bbb => 2
ccc => 1
d => 1
ddd => 2
```

という結果を出力します。

同じファイルを2回与えると、結果も2倍になります:

```
shell> stack exec runhaskell assets/16.hs sample-input.txt sample-input.txt
a => 2
aaa => 6
bbb => 4
ccc => 2
d => 2
ddd => 4
```

## 必要な知識

ここでは、「単語ごとの出現回数」を効率よく記録するためのデータ構造として、`Map`という型を使用します。`Map`は長めの名前で言うと「連想配列」と呼ばれ、ほかのプログラミング言語では`Hash`とか`Dict`（「Dictionary（辞書）の略」と呼ばれているものとよく似ています。文字列などのキーとなる値と、別の値を対応づけることができるデータ構造です。※`map`関数と名前がそっくりなので紛らわしいですが、直接関係はないのでご注意ください。

`Map`型を利用するには`containers`というパッケージをインストールする必要があります。`cabal install --lib containers`か、`stackをお使いであれば`stack install containers`と実行しましょう。何も出力せずに終了した場合、すでにインストールできている証拠です（※パッケージのインストール方法の詳細は、課題hoge(14)をご覧ください）。

### `containers`パッケージにある`Data.Map.Strict`を使う

`containers`パッケージのインストールができたら、GHCiを起動して、`Data.Map.Strict`というモジュールを`import`してください。

```haskell
ghci> import Data.Map.Strict
```

これが特にエラーメッセージなく行えたら、`Map`型を使用する準備はOKです。

#### `Map`型の値を作る1: `fromList`関数

まずは、`Map`型の値を作る`fromList`関数の方を調べてみましょう:

```
ghci> :t fromList
fromList :: Ord k => [(k, a)] -> Map k a
```

戻り値の型が`Map k a`となっていることからして、確かに`fromList`関数は`Map`型の値を返すみたいですね。

`Map k a`と、型名の後に型変数が二つ続いている型をご覧になるのは初めてでしょう。`Map`型は、本入門コンテンツで初めて登場する、型引数を二つ受け取る型なので、`Map`の後に二つの型が現れます。`k`がキーの型で、`a`がキーに対応する値の型を表します。例えば`Map String Int`という型は`String`型の値（文字列）がキーで、`Int`型の値（整数）が（キーに対応する）値で、`Map Int Char`であれば、キーは`Int`型の値、キーに対応する値は`Char`型の値（文字）が相当します。

リストと同じように、一つの`Map`に入る値の型は同じでなければなりません。加えて、一つの`Map`に入るキーの値の型も同じでなければなりません。前の段落で例に挙げた`Map String Int`という型や`Map Int Char`という型の値でいうと、それぞれキーの値として文字列や整数の値しか持つことが出来ず、キーに対応する値としてはそれぞれ整数や文字しか持つことができないのです。

`fromList`の引数の型`[(k, a)]`にも注目しましょう。これは、`k`型と`a`型の値のタプルのリストです。具体的には、例えば次のような値です:

```haskell
-- 「文字列と数値のペア」のリスト
[("One point one", 1.1), ("Nine", 9), ("Million", 1000000)]

-- 「数値と真偽値のペア」のリスト
[(0, False), (1, True)]

-- 空のリストももちろんOK
[]
```

最後に、`fromList`の引数における冒頭、`Ord k =>`についても説明します。課題hoge(7)で紹介したとおり、この`=>`は「制約」を表しているのでした。`fromList :: Ord k => ...`で言えば、`=>`の左辺には、型変数`k`の型は`Ord`という型クラスのインスタンスでなければならない、ということが示されています。

`Ord`型クラスがどんな型クラスなのか、まだ紹介していませんでした。`Ord`型クラスは、`<=`や`>=`、`>`などの大小を比較する演算子で比較できる型を表す型クラスです。下記の例のように、Haskellでは文字列や数値など、多くの型が`Ord`型クラスのインスタンスとなっているため
、`<=`や`>`で大小比較できます。

```haskell
ghci> 1 <= 3
True
ghci> "abc" > "bcd"
False
```

そしてその上、前述のとおり`fromList`関数を使うことで`Map`型の値のキーとして使うことができます:

```
ghci> fromList [("one", 1), ("two", 2), ("three", 3)]
fromList [("one",1),("three",3),("two",2)]
```

hoge

```
ghci> fromList [("one", 1), ("two", 2), ("two", 3)]
fromList [("one",1),("two",3)]
```

hoge

#### `Map`型の値を作る2: `fromListWith`関数でキーの衝突に対処する

```
ghci> :t fromListWith
fromListWith :: Ord k => (a -> a -> a) -> [(k, a)] -> Map k a
```

キーが衝突した値2つを受け取り、変換する関数を受け取る

```
ghci> fromListWith (\v1 v2 -> v1 + v2) [("one", 1), ("two", 2), ("two", 3)]
fromList [("one",1),("two",5)]
```

#### `Map`型にあるキーと値すべてに関数を適用する

```
ghci> import Data.Foldable

ghci> keyValues = fromListWith (\v1 v2 -> v1 + v2) [("one", 1), ("two", 2), ("two", 3)]
ghci> for_ keyValues print
1
5
```

値だけ！

値とキー、両方を処理する方法もいくつかあるけど最も直感的に、一旦`toList`でリストに変換する方法を。

```
ghci> toList keyValues

<interactive>:21:1: error:
    Ambiguous occurrence ‘toList’
    It could refer to either ‘Data.Foldable.toList’,
                             imported from ‘Data.Foldable’
                          or ‘Data.Map.Strict.toList’,
                             imported from ‘Data.Map.Strict’
                             (and originally defined in ‘Data.Map.Internal’)
```

### `import`する関数・型の名前を指定する

`fromList`という名前は被りそう

同じcontainersパッケージに入っている、`Data.Set`モジュール

```
ghci> import Data.Map.Strict
ghci> import Data.Set

ghci> :t fromList

<interactive>:1:1: error:
    Ambiguous occurrence ‘fromList’
    It could refer to either ‘Data.Set.fromList’,
                             imported from ‘Data.Set’
                             (and originally defined in ‘Data.Set.Internal’)
                          or ‘Data.Map.Strict.fromList’,
                             imported from ‘Data.Map.Strict’
                             (and originally defined in ‘Data.Map.Strict.Internal’)
```

```
ghci> Map.toList keyValues
[("one",1),("two",5)]
```

```
ghci> import qualified Data.Map.Strict as Map

ghci> :t Map.fromList
Map.fromList :: Ord k => [(k, a)] -> Map.Map k a
ghci> Map.fromList [("one", 1), ("two", 2), ("three", 3)]
fromList [("one",1),("three",3),("two",2)]
```

（※すでに`qualified`なしで`Data.Map.Strict`を`import`している場合、出力される`Map`型の名前は`qualified`されてない`Map`となるはずです）

`Map.Map`はかっこ悪い

`Map`だけ`import`するには

```
ghci> import Data.Map.Strict (Map)
ghci> :t Map.fromList
Map.fromList :: Ord k => [(k, a)] -> Map k a
```

`qualified`と同時に使うこともできるので、同じファイルに、次のように書くと、きれいに使用できる

```
import           Data.Map.Strict (Map)
import qualified Data.Map.Strict as Map
```

```
ghci> import Data.Foldable
ghci> keyValues = Map.fromListWith (\v1 v2 -> v1 + v2) [("one", 1), ("two", 2), ("two", 3)]
ghci> for_ (Map.toList keyValues) print
("one",1)
("two",5)
```

#### （脱線）実際の`import`あるある

```
import           Data.Map.Strict (Map)
import qualified Data.Map.Strict as Map
```

と、逐一書くのは実際めんどうくさいので↓のように、1文字だけで済ますことが多い（個人の感想です）

```
import qualified Data.Map.Strict as M
```

#### `Map`型の値から、キーに対応する値を取り出す（その1）

これ以降、`Map`型については、今回の課題を解くだけでは必要ありません。

`!` という変わった名前の演算子を使う。

演算子も普通の関数と同じ定義され、モジュールから`import`できます。

演算子を`import`するときは、`(!)`のように、括弧で囲う。

```
ghci> import qualified Data.Map.Strict as Map
ghci> import           Data.Map.Strict (Map, (!))
ghci> keyValues = Map.fromList [("one", 1), ("two", 2)]
ghci> keyValues ! "one"
1
ghci> keyValues ! "two"
2
```

存在しないキーを指定すると例外になるので注意！

```
ghci> keyValues ! "non existing"
*** Exception: Map.!: given key is not an element in the map
CallStack (from HasCallStack):
  error, called at libraries\\containers\\Data\\Map\\Internal.hs:610:17 in containers-0.6.0.1:Data.Map.Internal
```

`read`関数に変な文字列を与えたときと同じようなもの

もっと良い方法はこの次の課題で！

#### `Map`型の値を更新する

```
ghci> import qualified Data.Map.Strict as Map
ghci> keyValues = Map.fromList [("one", 1), ("two", 2)]
ghci> Map.insert "four" 4 keyValues
fromList [("four",4),("one",1),("two",2)]
```

キーを追加した、新しい`Map`を作って返す。
`Map.insert "four" 4 keyValues`したあとでも、`keyValues`の中身が変わらないことに注意

```
ghci> keyValues
fromList [("one",1),("two",2)]
```

キーが衝突した場合は上書きされる

```
ghci> Map.insert "two" 3 keyValues
fromList [("one",1),("two",3)]
```

`fromList` / `fromListWith`と同様に`insertWith`も

```
ghci> Map.insertWith (\v1 v2 -> v1 + v2) "two" 3 keyValues
fromList [("one",1),("two",5)]
```

他にもたくさんあります。  
[`Data.Map.Strict`モジュールのドキュメント](http://hackage.haskell.org/package/containers-0.6.0.1/docs/Data-Map-Strict.html)をご覧ください。

### `concat`関数でリストのリストを結合する

```
ghci> concat [[1, 2, 3], [4, 5, 6], [7, 8], [9]]
[1,2,3,4,5,6,7,8,9]
```

## 課題のヒント

- ファイルの中身を、`words`関数で単語のリストに変換した後、`[(<単語>, 1)]`という内容の、ペアのリストに変換すると、`Map.insertWith (\v1 v2 -> v1 + v2)`できれいに「単語ごとの出現回数を含む`Map`」が作れます。
- `Data.Map.Strict`の`toList`を使うつもりが、`Data.Foldable`の`toList`を使ってしまっていないか注意してください。  
  `Data.Foldable`の`toList`は`Map`型に対しても使えますが、こちらは`Data.Map.Strict`の`toList`と異なり、**値しか列挙しません**。  
  結果、かなりわかりづらいエラーメッセージになる恐れがあります。
