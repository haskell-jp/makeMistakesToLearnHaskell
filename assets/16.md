# 連想配列を扱う

指定したファイルに書かれた単語の出現回数をカウントするプログラムを書きましょう。

1. コマンドライン引数のリストを取得します。
2. コマンドライン引数のリストの各要素に対して、次の処理を実行します:
    1. 各要素である文字列をファイルのパスとして解釈し、その中身を読みます。
    2. 読んだファイルの中身を、空白で区切った、単語のリストに変換します。
3. コマンドライン引数で指定された各ファイルに含まれる単語の出現回数を数えます。
4. カウントしたそれぞれの単語について、  
  ```
  <単語> => <出現回数>
  ```

  という形式の行で表示します。

## 入出力例

`sample-input.txt`という、下記の内容のファイルがあったとき:

```
aaa	ddd
bbb	a
bbb	ddd
aaa	aaa
ccc	d
```

```
shell> stack exec runhaskell assets/16.hs sample-input.txt
```

と実行すると、

```
a => 1
aaa => 3
bbb => 2
ccc => 1
d => 1
ddd => 2
```

という結果を出力します。

同じファイルを2回与えると、結果も2倍になります:

```
shell> stack exec runhaskell assets/16.hs sample-input.txt sample-input.txt
a => 2
aaa => 6
bbb => 4
ccc => 2
d => 2
ddd => 4
```

## 必要な知識

ここでは、「単語ごとの出現回数」を効率よく記録するためのデータ構造として、`Map`という型を使用します。`Map`は長めの名前で言うと「連想配列」と呼ばれ、ほかのプログラミング言語では`Hash`とか`Dict`（「Dictionary（辞書）の略」と呼ばれているものとよく似ています。文字列などのキーとなる値と、別の値を対応づけることができるデータ構造です。※`map`関数と名前がそっくりなので紛らわしいですが、直接関係はないのでご注意ください。

`Map`型を利用するには`containers`というパッケージをインストールする必要があります。`cabal install --lib containers`か、`stackをお使いであれば`stack install containers`と実行しましょう。何も出力せずに終了した場合、すでにインストールできている証拠です（※パッケージのインストール方法の詳細は、課題hoge(14)をご覧ください）。

### `containers`パッケージにある`Data.Map.Strict`を使う

`containers`パッケージのインストールができたら、GHCiを起動して、`Data.Map.Strict`というモジュールを`import`してください。

```haskell
ghci> import Data.Map.Strict
```

これが特にエラーメッセージなく行えたら、`Map`型を使用する準備はOKです。

#### `Map`型の値を作る1: `fromList`関数

まずは、`Map`型の値を作る`fromList`関数の方を調べてみましょう:

```
ghci> :t fromList
fromList :: Ord k => [(k, a)] -> Map k a
```

戻り値の型が`Map k a`となっていることからして、確かに`fromList`関数は`Map`型の値を返すみたいですね。

`Map k a`と、型名の後に型変数が二つ続いている型をご覧になるのは初めてでしょう。`Map`型は、本入門コンテンツで初めて登場する、型引数を二つ受け取る型なので、`Map`の後に二つの型が現れます。`k`がキーの型で、`a`がキーに対応する値の型を表します。例えば`Map String Int`という型は`String`型の値（文字列）がキーで、`Int`型の値（整数）が（キーに対応する）値で、`Map Int Char`であれば、キーは`Int`型の値、キーに対応する値は`Char`型の値（文字）が相当します。

リストと同じように、一つの`Map`に入る値の型は同じでなければなりません。加えて、一つの`Map`に入るキーの値の型も同じでなければなりません。前の段落で例に挙げた`Map String Int`という型や`Map Int Char`という型の値でいうと、それぞれキーの値として文字列や整数の値しか持つことが出来ず、キーに対応する値としてはそれぞれ整数や文字しか持つことができないのです。

`fromList`の引数の型`[(k, a)]`にも注目しましょう。これは、`k`型と`a`型の値のタプルのリストです。具体的には、例えば次のような値です:

```haskell
-- 「文字列と数値のペア」のリスト
[("One point one", 1.1), ("Nine", 9), ("Million", 1000000)]

-- 「数値と真偽値のペア」のリスト
[(0, False), (1, True)]

-- 空のリストももちろんOK
[]
```

最後に、`fromList`の引数における冒頭、`Ord k =>`についても説明します。課題hoge(7)で紹介したとおり、この`=>`は「制約」を表しているのでした。`fromList :: Ord k => ...`で言えば、`=>`の左辺には、型変数`k`の型は`Ord`という型クラスのインスタンスでなければならない、ということが示されています。

`Ord`型クラスがどんな型クラスなのか、まだ紹介していませんでした。`Ord`型クラスは、`<=`や`>=`、`>`などの、大小を比較する演算子で比較できる型を表す型クラスです。下記の例のように、Haskellでは文字列や数値など、多くの型が`Ord`型クラスのインスタンスとなっているため、`<=`や`>`で大小比較できます。

```haskell
ghci> 1 <= 3
True
ghci> "abc" > "bcd"
False
```

そしてその上、前述のとおり`fromList`関数を使うことで`Map`型の値のキーとして使うことができます:

```haskell
ghci> fromList [(1, "a"), (2, "b"), (3, "c")]
fromList [(1,"a"),(2,"b"),(3,"c")]

ghci> fromList [("one", 1), ("two", 2), ("three", 3)]
fromList [("one",1),("three",3),("two",2)]
```

もし、キーとして渡した値の中に、重複があった場合はどうなるのでしょう？最後の例を少し書き換えて`"two"`というキーを被らせてみると、リストにおける最後の値が優先されました:

```haskell
ghci> fromList [("one", 1), ("two", 2), ("two", 3)]
fromList [("one",1),("two",3)]
```

後で詳しく説明しますが、実はこうした挙動のため、`fromList`関数だと今回の課題は解きづらいです。代わりに次の節で紹介する、`fromListWith`関数を使ってキーの重複があった時の振る舞いをカスタマイズしてください。

#### `Map`型の値を作る2: `fromListWith`関数でキーの衝突に対処する

`fromListWith`関数は、`fromList`関数の機能に加えて、第一引数として「キーが重複した場合に、登録する値を返す関数」を受け取るようになっています。

例のごとく`ghci`の`:t`コマンドでチェックしてみましょう:

```haskell
ghci> :t fromListWith
fromListWith :: Ord k => (a -> a -> a) -> [(k, a)] -> Map k a
```

第一引数で指定する関数は、`a`型の値、つまり`Map k a`の値として使う値（「値」という単語がそれぞれ違う意味で使われているのでご注意）を二つ受け取って、`a`型の値を返します。

どのような関数を受け取るのか、実際に動かしながら確かめてみましょう。まずは比較対象として、先ほどの`fromList`関数を試します:

```haskell
ghci> fromListWith (\v1 v2 -> v1 + v2) [("one", 1), ("two", 2), ("two", 3)]
fromList [("one",1),("two",5)]
```

第一引数として足し算を行う関数を渡した結果、衝突するキー`"two"`に対応する値`2`・`3`が足されて`5`になりましたね！このように、`fromListWith`関数の第一引数にあたる関数は、キーが衝突した値2つを受け取り、該当するキーの新しい値を返します。

ちなみに、`fromListWith`関数の第一引数における関数の、二つの引数がそれぞれどのような順番で渡されるかは、上記の`(\v1 v2 -> v1 + v2)`では分かりませんよね？足し算は可換な演算ですし。気になる方は、値が文字列である`Map`を`fromListWith`で作って、文字列を結合する`++`を使った関数を渡して確かめてみてください！

#### 課題のヒント: `fromListWith`関数を使おう

今回の課題では、単語の出現回数を数える必要があるため、重複した単語を見つけた際に新しく見つけた方の単語の情報で上書きするのではなく、それまでに集めた単語の数と足し合わせる必要があります。

軽くネタばらしをすると、今回の課題は、よくある命令型スタイルで考えた場合にイメージするような、以下の疑似言語で表されるアルゴリズムをHaskellに直訳するのでは、**解けません**:

```javascript
単語毎の出現頻度 = 空のMap

for (単語 in 単語のリスト) {
  if (単語毎の出現頻度 has 単語) {
    単語毎の出現頻度[単語] += 1
  } else {
    単語毎の出現頻度[単語] = 1
  }
}
```

`単語のリスト`にある`単語`を一つずつ処理して、`単語毎の出現頻度`に登録済みであれば`単語毎の出現頻度`の該当する値に1追加して、登録済みでなければ`単語毎の出現頻度`の該当する値を1で初期化する、というアルゴリズムですね。これはいかにも命令型プログラミングスタイルといえるアルゴリズムで、Haskellではちょっとやりづらいです（これまで紹介していない機能を使えばできなくはないですが、割愛します）。

そこで、一旦単語のリストを`map`関数で`(単語, 1)`というタプルに変換した後、`fromListWith`で`Map`を組み立てましょう。その際、重複した単語が見つかった場合は「該当する単語の値として、それまでに保存されていた数」を足す、という処理を行ってください。次のようなコードです:

```haskell
wordAnd1s = map (\w -> (w, 1)) 単語のリスト
countsByWord = fromListWith (\x y -> x + y) wordAnd1s
```

試してみましょう:

```haskell
ghci> wordAnd1s = map (\w -> (w, 1)) ["a", "b", "a", "c", "c"]

<interactive>:6:13: error:
    Ambiguous occurrence ‘map’
    It could refer to
       either ‘Data.Map.Strict.map’,
              imported from ‘Data.Map.Strict’
              (and originally defined in ‘Data.Map.Strict.Internal’)
           or ‘Prelude.map’,
              imported from ‘Prelude’ (and originally defined in ‘GHC.Base’)
```

... が、1行目で見慣れないエラーにぶち当たってしまいました😰。次の節で解決方法をお話しします。

### `import`する関数・型の名前にプレフィックスを付ける

前節の最後に見たエラーメッセージを翻訳して分かりやすくすると、`map`という名前の関数が`Data.Map.Strict`モジュールと`Prelude`と言うモジュール両方に含まれているため曖昧になっている、という内容になります。`Data.Map.Strict`モジュールは先ほど`import`したもので、`Prelude`モジュールは課題hoge(13)で紹介した、「`import`しなくても利用できる」モジュールのことです。確かに`map`関数は課題hoge(15)で何も`import`しないで使ったとおり、`Prelude`に入っています。これらの名前が被ってしまっているため、「どっちの`map`関数を使っているのか分からないよ！」というエラーが発生したのです。

これを回避するための一つの手段として、`qualified`という機能が`import`文にはあります。`qualified`を使えば、指定したモジュールにある関数や型を、指定した名前のプレフィックス（prefix）を付けた場合のみ参照できるようにする機能です。

例えば、前述の`Data.Map.Strict`モジュールの関数を、`Map`というプレフィックスを付けた場合のみ参照できるようにするには、次のように書きます:

```haskell
ghci> import qualified Data.Map.Strict as Map
```

`import`の直後に`qualified`というキーワードを続けた後、モジュール名である`Data.Map.Strict`を指定して、最後に`as Map`と書くことで、`Data.Map.Strict`モジュールの関数や型を`Map.<関数の名前>`という形式で参照できるようになります:

```haskell
ghci> :t Map.fromList
Map.fromList :: Ord k => [(k, a)] -> Map.Map k a
ghci> Map.fromList [("one", 1), ("two", 2), ("three", 3)]
fromList [("one",1),("three",3),("two",2)]
```

上記のとおり、`Data.Map.Strict`の`fromList`関数は、`Map.fromList`という名前で参照できるようになりました。元のように単なる`fromList`として参照することはできません:

```haskell
ghci> :t fromList

<interactive>:1:1: error:
    ? Variable not in scope: fromList
    ? Perhaps you meant ‘Map.fromList’ (imported from Data.Map.Strict)
```

それから、先ほど`Ambiguous occurrence ‘map’`というエラーで参照できなかった`map`関数を`map`として参照すると、`Prelude`の`map`関数が使用されることが分かります:

```haskell
:t map
ghci> :t map
map :: (a -> b) -> [a] -> [b]

ghci> map (\x -> x * 2) [1, 2, 3]
[2,4,6]
```

リストに対する`map`関数が使われていますね！

先ほどエラーになってしまった例もこの通り:

```haskell
ghci> wordAnd1s = map (\w -> (w, 1)) ["a", "b", "a", "c", "c"]
ghci> countsByWord = Map.fromListWith (\x y -> x + y) wordAnd1s
ghci> countsByWord
fromList [("a",2),("b",1),("c",2)]
```

ちゃんと各単語がリストにいくつ含まれているか、カウントされているようです！

### `import`する関数・型の名前を指定する

ところで、先ほど`Map.fromList`の型を`:t`でチェックしたときのことを思い出してください:

```haskell
ghci> :t Map.fromList
Map.fromList :: Ord k => [(k, a)] -> Map.Map k a
ghci> Map.fromList [("one", 1), ("two", 2), ("three", 3)]
fromList [("one",1),("three",3),("two",2)]
```

`Map.fromList`の戻り値が、`Map.Map k a`という型になっていますね。`import qualified Data.Map.Strict as Map`と書いて`Data.Map.Strict`モジュールにおける関数や型すべてに`Map.`を付けて参照するようにしたのですから、`Map`型も`Map.Map`になるのは仕様上自然な振る舞いです。しかし、`Map.Map`という名前は同じ単語が繰り返されてちょっと不格好ですよね。

その解決策として、例えば`Map`型だけを`Map`としつつ、他の関数を`Map.`付きで参照するには、次のように`import Data.Map.Strict`の直後に`(Map)`と書いて`import`した上で、先ほどと同様`qualified`付きの`import`をしてください:

```
ghci> import Data.Map.Strict (Map)
ghci> import qualified Data.Map.Strict as Map
ghci> :t Map.fromList
Map.fromList :: Ord k => [(k, a)] -> Map k a
```

`import Data.Map.Strict (Map)`は、`Data.Map.Strict`モジュールにある`Map`（と言う名前の型）だけを利用できるようにするための宣言です。これと先ほどの`import qualified Data.Map.Strict as Map`と組み合わせることで、`Map`型だけは単なる`Map`という名前で参照できるようになり、そのほかの関数や型は、`Map.`と言うプレフィックスを付けた上でのみ参照できるようになります。

#### （脱線）実際の`import`あるある

一点余談です。私が観測している限り、実際のHaskellのソースコードでは、`import`を次のように書くことが多いようです:

```haskell
import qualified Data.Map.Strict as M
```

`import qualified`でモジュール`import`する際、`M`のように、対象のモジュール名からとった一文字をプレフィックスにする、という方法です。前述のように、一つのモジュールに対する`import`を2行に渡って書くのが煩雑な上`Map.Map`のような冗長な名前で参照したくない、という事情から、`M`のような短いプレフィックスが好まれるようです。

とは言え、本課題では今後も先ほど紹介したスタイルでの`import`を前提とします:

```haskell
ghci> import Data.Map.Strict (Map)
ghci> import qualified Data.Map.Strict as Map
```


#### `Map`型にあるキーと値すべてに関数を適用する

```haskell
ghci> import Data.Foldable

ghci> keyValues = fromListWith (\v1 v2 -> v1 + v2) [("one", 1), ("two", 2), ("two", 3)]
ghci> for_ keyValues print
1
5
```

値だけ！

値とキー、両方を処理する方法もいくつかあるけど最も直感的に、一旦`toList`でリストに変換する方法を。

```
ghci> Map.toList keyValues
```

```
ghci> import Data.Foldable
ghci> keyValues = Map.fromListWith (\v1 v2 -> v1 + v2) [("one", 1), ("two", 2), ("two", 3)]
ghci> for_ (Map.toList keyValues) print
("one",1)
("two",5)
```

#### `Map`型の値から、キーに対応する値を取り出す（その1）

これ以降、`Map`型については、今回の課題を解くだけでは必要ありません。

`!` という変わった名前の演算子を使う。

演算子も普通の関数と同じ定義され、モジュールから`import`できます。

演算子を`import`するときは、`(!)`のように、括弧で囲う。

```
ghci> import qualified Data.Map.Strict as Map
ghci> import           Data.Map.Strict (Map, (!))
ghci> keyValues = Map.fromList [("one", 1), ("two", 2)]
ghci> keyValues ! "one"
1
ghci> keyValues ! "two"
2
```

存在しないキーを指定すると例外になるので注意！

```
ghci> keyValues ! "non existing"
*** Exception: Map.!: given key is not an element in the map
CallStack (from HasCallStack):
  error, called at libraries\\containers\\Data\\Map\\Internal.hs:610:17 in containers-0.6.0.1:Data.Map.Internal
```

`read`関数に変な文字列を与えたときと同じようなもの

もっと良い方法はこの次の課題で！

#### `Map`型の値を更新する

```
ghci> import qualified Data.Map.Strict as Map
ghci> keyValues = Map.fromList [("one", 1), ("two", 2)]
ghci> Map.insert "four" 4 keyValues
fromList [("four",4),("one",1),("two",2)]
```

キーを追加した、新しい`Map`を作って返す。
`Map.insert "four" 4 keyValues`したあとでも、`keyValues`の中身が変わらないことに注意

```
ghci> keyValues
fromList [("one",1),("two",2)]
```

キーが衝突した場合は上書きされる

```
ghci> Map.insert "two" 3 keyValues
fromList [("one",1),("two",3)]
```

`fromList` / `fromListWith`と同様に`insertWith`も

```
ghci> Map.insertWith (\v1 v2 -> v1 + v2) "two" 3 keyValues
fromList [("one",1),("two",5)]
```

他にもたくさんあります。  
[`Data.Map.Strict`モジュールのドキュメント](http://hackage.haskell.org/package/containers-0.6.0.1/docs/Data-Map-Strict.html)をご覧ください。

### `concat`関数でリストのリストを結合する

```
ghci> concat [[1, 2, 3], [4, 5, 6], [7, 8], [9]]
[1,2,3,4,5,6,7,8,9]
```

## 課題のヒント

- ファイルの中身を、`words`関数で単語のリストに変換した後、`[(<単語>, 1)]`という内容の、ペアのリストに変換すると、`Map.insertWith (\v1 v2 -> v1 + v2)`できれいに「単語ごとの出現回数を含む`Map`」が作れます。
- `Data.Map.Strict`の`toList`を使うつもりが、`Data.Foldable`の`toList`を使ってしまっていないか注意してください。  
  `Data.Foldable`の`toList`は`Map`型に対しても使えますが、こちらは`Data.Map.Strict`の`toList`と異なり、**値しか列挙しません**。  
  結果、かなりわかりづらいエラーメッセージになる恐れがあります。
