# 連想配列を扱う

指定したファイルに書かれた単語の出現回数をカウントするプログラムを書きましょう。

1. コマンドライン引数のリストを取得します。
2. コマンドライン引数のリストの各要素に対して、次の処理を実行します:
    1. 各要素である文字列をファイルのパスとして解釈し、その中身を読みます。
    2. 読んだファイルの中身を、空白で区切った、単語のリストに変換します。
3. コマンドライン引数で指定された各ファイルに含まれる単語の出現回数を数えます。
4. カウントしたそれぞれの単語について、  
  ```
  <単語> => <出現回数>
  ```

  という形式の行で表示します。

## 入出力例

`sample-input.txt`という、下記の内容のファイルがあったとき、

```
aaa	ddd
bbb	a
bbb	ddd
aaa	aaa
ccc	d
```

```
shell> stack exec runhaskell assets/16.hs sample-input.txt
```

と実行すると、

```
a => 1
aaa => 3
bbb => 2
ccc => 1
d => 1
ddd => 2
```

という結果を出力する。

同じファイルを2回与えると、結果も2倍になる。

```
shell> stack exec runhaskell assets/16.hs sample-input.txt sample-input.txt
a => 2
aaa => 6
bbb => 4
ccc => 2
d => 2
ddd => 4
```

## 必要な知識

「単語ごとの出現回数」を効率よく記録するためのデータ構造として、`Map`という型を使用します。  
`Map`は長めの名前で言うと「連想配列」と呼ばれ、ほかのプログラミング言語では`Hash`とか`Dict`（「Dictionary（辞書）の略」と呼ばれるものとよく似ています。  
※`map`関数と名前がそっくりなので紛らわしいですが、直接関係はないのでご注意ください。  
文字列などのキーとなる値と、別の値を対応づけることができるデータ構造です。

`containers`パッケージを確実に利用できるようにするためには

```
shell> stack install containers
```

とあらかじめ実行しておけば良いでしょう。  
パッケージのインストール方法については課題14をご覧ください。  
何も出力せずに終了した場合、すでにインストールできている証拠です。

### containersパッケージにある`Data.Map.Strict`を使う

#### `Map`型を作る

```
ghci> import Data.Map.Strict
```

```
ghci> :t fromList
fromList :: Ord k => [(k, a)] -> Map k a
```

`Map k a`の型引数を2つ受け取り、`k`がキーの型で、`a`が値の型を表します。

リストと同じように、一つの`Map`に入る値の型は同じでなければならない。  
加えて、キーの型も同じでなければならない。

`Ord`は`=<`や`>=`、`>`などの大小を比較する演算子で比較できる型を表す型クラス

```
ghci> fromList [("one", 1), ("two", 2), ("three", 3)]
fromList [("one",1),("three",3),("two",2)]
```

```
ghci> fromList [("one", 1), ("two", 2), ("two", 3)]
fromList [("one",1),("two",3)]
```

```
ghci> :t fromListWith
fromListWith :: Ord k => (a -> a -> a) -> [(k, a)] -> Map k a
```

キーが衝突した値2つを受け取り、変換する関数を受け取る

```
ghci> fromListWith (\v1 v2 -> v1 + v2) [("one", 1), ("two", 2), ("two", 3)]
fromList [("one",1),("two",5)]
```

#### `Map`型にあるキーと値すべてに関数を適用する

```
ghci> import Data.Foldable

ghci> keyValues = fromListWith (\v1 v2 -> v1 + v2) [("one", 1), ("two", 2), ("two", 3)]
ghci> for_ keyValues print
1
5
```

値だけ！

値とキー、両方を処理する方法もいくつかあるけど最も直感的に、一旦`toList`でリストに変換する方法を。

```
ghci> toList keyValues

<interactive>:21:1: error:
    Ambiguous occurrence ‘toList’
    It could refer to either ‘Data.Foldable.toList’,
                             imported from ‘Data.Foldable’
                          or ‘Data.Map.Strict.toList’,
                             imported from ‘Data.Map.Strict’
                             (and originally defined in ‘Data.Map.Internal’)
```

### `import`する関数・型の名前を指定する

`fromList`という名前は被りそう

同じcontainersパッケージに入っている、`Data.Set`モジュール

```
ghci> import Data.Map.Strict
ghci> import Data.Set

ghci> :t fromList

<interactive>:1:1: error:
    Ambiguous occurrence ‘fromList’
    It could refer to either ‘Data.Set.fromList’,
                             imported from ‘Data.Set’
                             (and originally defined in ‘Data.Set.Internal’)
                          or ‘Data.Map.Strict.fromList’,
                             imported from ‘Data.Map.Strict’
                             (and originally defined in ‘Data.Map.Strict.Internal’)
```

```
ghci> Map.toList keyValues
[("one",1),("two",5)]
```

```
ghci> import qualified Data.Map.Strict as Map

ghci> :t Map.fromList
Map.fromList :: Ord k => [(k, a)] -> Map.Map k a
ghci> Map.fromList [("one", 1), ("two", 2), ("three", 3)]
fromList [("one",1),("three",3),("two",2)]
```

（※すでに`qualified`なしで`Data.Map.Strict`を`import`している場合、出力される`Map`型の名前は`qualified`されてない`Map`となるはずです）

`Map.Map`はかっこ悪い

`Map`だけ`import`するには

```
ghci> import Data.Map.Strict (Map)
ghci> :t Map.fromList
Map.fromList :: Ord k => [(k, a)] -> Map k a
```

`qualified`と同時に使うこともできるので、同じファイルに、次のように書くと、きれいに使用できる

```
import           Data.Map.Strict (Map)
import qualified Data.Map.Strict as Map
```

```
ghci> import Data.Foldable
ghci> keyValues = Map.fromListWith (\v1 v2 -> v1 + v2) [("one", 1), ("two", 2), ("two", 3)]
ghci> for_ (Map.toList keyValues) print
("one",1)
("two",5)
```

#### （脱線）実際の`import`あるある

```
import           Data.Map.Strict (Map)
import qualified Data.Map.Strict as Map
```

と、逐一書くのは実際めんどうくさいので↓のように、1文字だけで済ますことが多い（個人の感想です）

```
import qualified Data.Map.Strict as M
```

#### `Map`型の値から、キーに対応する値を取り出す（その1）

これ以降、`Map`型については、今回の課題を解くだけでは必要ありません。

`!` という変わった名前の演算子を使う。

演算子も普通の関数と同じ定義され、モジュールから`import`できます。

演算子を`import`するときは、`(!)`のように、括弧で囲う。

```
ghci> import qualified Data.Map.Strict as Map
ghci> import           Data.Map.Strict (Map, (!))
ghci> keyValues = Map.fromList [("one", 1), ("two", 2)]
ghci> keyValues ! "one"
1
ghci> keyValues ! "two"
2
```

存在しないキーを指定すると例外になるので注意！

```
ghci> keyValues ! "non existing"
*** Exception: Map.!: given key is not an element in the map
CallStack (from HasCallStack):
  error, called at libraries\\containers\\Data\\Map\\Internal.hs:610:17 in containers-0.6.0.1:Data.Map.Internal
```

`read`関数に変な文字列を与えたときと同じようなもの

もっと良い方法はこの次の課題で！

#### `Map`型の値を更新する

```
ghci> import qualified Data.Map.Strict as Map
ghci> keyValues = Map.fromList [("one", 1), ("two", 2)]
ghci> Map.insert "four" 4 keyValues
fromList [("four",4),("one",1),("two",2)]
```

キーを追加した、新しい`Map`を作って返す。
`Map.insert "four" 4 keyValues`したあとでも、`keyValues`の中身が変わらないことに注意

```
ghci> keyValues
fromList [("one",1),("two",2)]
```

キーが衝突した場合は上書きされる

```
ghci> Map.insert "two" 3 keyValues
fromList [("one",1),("two",3)]
```

`fromList` / `fromListWith`と同様に`insertWith`も

```
ghci> Map.insertWith (\v1 v2 -> v1 + v2) "two" 3 keyValues
fromList [("one",1),("two",5)]
```

他にもたくさんあります。  
[`Data.Map.Strict`モジュールのドキュメント](http://hackage.haskell.org/package/containers-0.6.0.1/docs/Data-Map-Strict.html)をご覧ください。

### `concat`関数でリストのリストを結合する

```
ghci> concat [[1, 2, 3], [4, 5, 6], [7, 8], [9]]
[1,2,3,4,5,6,7,8,9]
```
