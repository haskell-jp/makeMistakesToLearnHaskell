# 連想配列を扱う

指定したファイルに書かれた単語の出現回数をカウントするプログラムを書きましょう。

1. コマンドライン引数のリストを取得します。
2. コマンドライン引数のリストの各要素に対して、次の処理を実行します:
    1. 各要素である文字列をファイルのパスとして解釈し、その中身を読みます。
    2. 読んだファイルの中身を、空白で区切った、単語のリストに変換します。
3. コマンドライン引数で指定された各ファイルに含まれる単語の出現回数を数えます。
4. カウントしたそれぞれの単号について、  
  ```
  <単語> => <出現回数>
  ```

  という形式の行で表示します。

## 入出力例

`sample-input.txt`という、下記の内容のファイルがあったとき、

```
aaa	ddd
bbb	a
bbb	ddd
aaa	aaa
ccc	d
```

```
shell> stack exec runhaskell assets/16.hs sample-input.txt
```

と実行すると、

```
a => 1
aaa => 3
bbb => 2
ccc => 1
d => 1
ddd => 2
```

という結果を出力する。

同じファイルを2回与えると、結果も2倍になる。

```
shell> stack exec runhaskell assets/16.hs sample-input.txt sample-input.txt
a => 2
aaa => 6
bbb => 4
ccc => 2
d => 2
ddd => 4
```

## 必要な知識

「単語ごとの出現回数」を効率よく記録するためのデータ構造として、`Map`という型を使用します。  
｀Map`は長めの名前で言うと「連想配列」と呼ばれ、ほかのプログラミング言語では`Hash`とか`Dict`（「Dictionary（辞書）の略」と呼ばれるものとよく似ています。  
文字列などのキーとなる値と、別の値を対応づけることができるデータ構造です。

`containers`パッケージを確実に利用できるようにするためには

```
shell> stack install containers
```

とあらかじめ実行しておけば良いでしょう。  
パッケージのインストール方法については課題14をご覧ください。  
何も出力せずに終了した場合、すでにインストールできている証拠です。

### containersパッケージにある`Data.Map.Strict`を使う

#### `Map`型を作る

```
ghci> import Data.Map.Strict
```

```
ghci> :t fromList
fromList :: Ord k => [(k, a)] -> Map k a
```

`Ord`は`=<`や`>=`、`>`などの大小を比較する演算子で比較できる型を表す型クラス

```
ghci> fromList [("one", 1), ("two", 2), ("three", 3)]
fromList [("one",1),("three",3),("two",2)]
```

```
ghci> fromList [("one", 1), ("two", 2), ("two", 3)]
fromList [("one",1),("two",3)]
```

```
ghci> :t fromListWith
fromListWith :: Ord k => (a -> a -> a) -> [(k, a)] -> Map k a
```

```
ghci> fromListWith (\v1 v2 -> v1 + v2) [("one", 1), ("two", 2), ("two", 3)]
fromList [("one",1),("two",5)]
```

#### `Map`型にあるキーと値すべてに関数を適用する

```
ghci> import Data.Foldable

ghci> keyValues = fromListWith (\v1 v2 -> v1 + v2) [("one", 1), ("two", 2), ("two", 3)]
ghci> for_ keyValues print
1
5
```

値だけ！

値とキー、両方をいくつかあるけど最も直感的に、一旦`toList`でリストに変換する方法を。

```
ghci> :t toList
toList :: Map k a -> [(k, a)]
```

```
ghci> toList keyValues
[("one",1),("two",5)]
```

```
ghci> for_ (toList keyValues) print
("one",1)
("two",5)
```

#### `Map`型を更新する

今回の課題を解くだけでは必要ありません。

```
ghci> keyValues = fromList [("one", 1), ("two", 2)]
ghci> insert "four" 4 keyValues
fromList [("four",4),("one",1),("two",2)]
```

キーが衝突した場合は上書きされる

```
ghci> insert "two" 3 keyValues
fromList [("one",1),("two",3)]
```

`fromList` / `fromListWith`と同様に`insertWith`も

```
ghci> insertWith (\v1 v2 -> v1 + v2) "two" 3 keyValues
fromList [("one",1),("two",5)]
```

他にもたくさんあります。  
[`Data.Map.Strict`モジュールのドキュメント](http://hackage.haskell.org/package/containers-0.6.0.1/docs/Data-Map-Strict.html)をご覧ください。

### `import`する関数・型の名前を指定する

今回の課題を解くだけでは必要ありません。

`fromList`という名前は被りそう

同じcontainersパッケージに入っている、`Data.Set`モジュール

```
ghci> import Data.Map.Strict
ghci> import Data.Set

ghci> :t fromList

<interactive>:1:1: error:
    Ambiguous occurrence ‘fromList’
    It could refer to either ‘Data.Set.fromList’,
                             imported from ‘Data.Set’
                             (and originally defined in ‘Data.Set.Internal’)
                          or ‘Data.Map.Strict.fromList’,
                             imported from ‘Data.Map.Strict’
                             (and originally defined in ‘Data.Map.Strict.Internal’)
```

```
ghci> import qualified Data.Map.Strict as Map

ghci> :t Map.fromList
Map.fromList :: Ord k => [(k, a)] -> Map.Map k a
ghci> Map.fromList [("one", 1), ("two", 2), ("three", 3)]
fromList [("one",1),("three",3),("two",2)]
```

（※すでに`qualified`なしで`Data.Map.Strict`を`import`している場合、出力される`Map`型の名前は`qualified`されてない`Map`となるはずです）

`Map.Map`はかっこ悪い

`Map`だけ`import`するには

```
ghci> import Data.Map.Strict (Map)
ghci> :t Map.fromList
Map.fromList :: Ord k => [(k, a)] -> Map k a
```

### （脱線）実際の`import`あるある

```
import           Data.Map.Strict (Map)
import qualified Data.Map.Strict as Map
```

と、逐一書くのは実際めんどうくさいので↓のように、1文字だけで済ますことが多い（個人の感想です）

```
import qualified Data.Map.Strict as M
```
