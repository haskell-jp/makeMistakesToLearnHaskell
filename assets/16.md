# 連想配列を扱う

指定したファイルに書かれた単語の出現回数をカウントするプログラムを書きましょう。

1. コマンドライン引数のリストを取得します。
2. コマンドライン引数のリストの各要素に対して、次の処理を実行します:
    1. 各要素である文字列をファイルのパスとして解釈し、その中身を読みます。
    2. 読んだファイルの中身を、空白で区切った、単語のリストに変換します。
3. コマンドライン引数で指定された各ファイルに含まれる単語の出現回数を数えます。
4. カウントしたそれぞれの単語について、  
  ```
  <単語> => <出現回数>
  ```

  という形式の行で表示します。

## 入出力例

`sample-input.txt`という、下記の内容のファイルがあったとき:

```
aaa	ddd
bbb	a
bbb	ddd
aaa	aaa
ccc	d
```

```bash
shell> stack exec runhaskell assets/16.hs sample-input.txt
```

と実行すると、

```
a => 1
aaa => 3
bbb => 2
ccc => 1
d => 1
ddd => 2
```

という結果を出力します。

同じファイルを2回与えると、結果も2倍になります:

```bash
shell> stack exec runhaskell assets/16.hs sample-input.txt sample-input.txt
a => 2
aaa => 6
bbb => 4
ccc => 2
d => 2
ddd => 4
```

## 必要な知識

ここでは、「単語ごとの出現回数」を効率よく記録するためのデータ構造として、`Map`という型を使用します。`Map`は長めの名前で言うと「連想配列」と呼ばれ、ほかのプログラミング言語では`Hash`とか`Dict`（「Dictionary（辞書）の略」と呼ばれているものとよく似ています。文字列などのキーとなる値と、別の値を対応づけることができるデータ構造です。※`map`関数と名前がそっくりなので紛らわしいですが、直接関係はないのでご注意ください。

`Map`型を利用するには`containers`というパッケージをインストールする必要があります。`cabal install --lib containers`か、`stackをお使いであれば`stack install containers`と実行しましょう。何も出力せずに終了した場合、すでにインストールできている証拠です（※パッケージのインストール方法の詳細は、課題hoge(14)をご覧ください）。

### `containers`パッケージにある`Data.Map.Strict`を使う

`containers`パッケージのインストールができたら、GHCiを起動して、`Data.Map.Strict`というモジュールを`import`してください。

```haskell
ghci> import Data.Map.Strict
```

これが特にエラーメッセージなく行えたら、`Map`型を使用する準備はOKです。

#### `Map`型の値を作る1: `fromList`関数

まずは、`Map`型の値を作る`fromList`関数の方を調べてみましょう:

```haskell
ghci> :t fromList
fromList :: Ord k => [(k, a)] -> Map k a
```

戻り値の型が`Map k a`となっていることからして、確かに`fromList`関数は`Map`型の値を返すみたいですね。

`Map k a`と、型名の後に型変数が二つ続いている型をご覧になるのは初めてでしょう。`Map`型は、本入門コンテンツで初めて登場する、型引数を二つ受け取る型なので、`Map`の後に二つの型が現れます。`k`がキーの型で、`a`がキーに対応する値の型を表します。例えば`Map String Int`という型は`String`型の値（文字列）がキーで、`Int`型の値（整数）が（キーに対応する）値で、`Map Int Char`であれば、キーは`Int`型の値、キーに対応する値は`Char`型の値（文字）が相当します。

リストと同じように、一つの`Map`に入る値の型は同じでなければなりません。加えて、一つの`Map`に入るキーの値の型も同じでなければなりません。前の段落で例に挙げた`Map String Int`という型や`Map Int Char`という型の値でいうと、それぞれキーの値として文字列や整数の値しか持つことが出来ず、キーに対応する値としてはそれぞれ整数や文字しか持つことができないのです。

`fromList`の引数の型`[(k, a)]`にも注目しましょう。これは、`k`型と`a`型の値のタプルのリストです。具体的には、例えば次のような値です:

```haskell
-- 「文字列と数値のペア」のリスト
[("One point one", 1.1), ("Nine", 9), ("Million", 1000000)]

-- 「数値と真偽値のペア」のリスト
[(0, False), (1, True)]

-- 空のリストももちろんOK
[]
```

最後に、`fromList`の引数における冒頭、`Ord k =>`についても説明します。課題hoge(7)で紹介したとおり、この`=>`は「制約」を表しているのでした。`fromList :: Ord k => ...`で言えば、`=>`の左辺には、型変数`k`の型は`Ord`という型クラスのインスタンスでなければならない、ということが示されています。

`Ord`型クラスがどんな型クラスなのか、まだ紹介していませんでした。`Ord`型クラスは、`<=`や`>=`、`>`などの、大小を比較する演算子で比較できる型を表す型クラスです。下記の例のように、Haskellでは文字列や数値など、多くの型が`Ord`型クラスのインスタンスとなっているため、`<=`や`>`で大小比較できます。

```haskell
ghci> 1 <= 3
True
ghci> "abc" > "bcd"
False
```

そしてその上、前述のとおり`fromList`関数を使うことで`Map`型の値のキーとして使うことができます:

```haskell
ghci> fromList [(1, "a"), (2, "b"), (3, "c")]
fromList [(1,"a"),(2,"b"),(3,"c")]

ghci> fromList [("one", 1), ("two", 2), ("three", 3)]
fromList [("one",1),("three",3),("two",2)]
```

もし、キーとして渡した値の中に、重複があった場合はどうなるのでしょう？最後の例を少し書き換えて`"two"`というキーを被らせてみると、リストにおける最後の値が優先されました:

```haskell
ghci> fromList [("one", 1), ("two", 2), ("two", 3)]
fromList [("one",1),("two",3)]
```

後で詳しく説明しますが、実はこうした挙動のため、`fromList`関数だと今回の課題は解きづらいです。代わりに次の節で紹介する、`fromListWith`関数を使ってキーの重複があった時の振る舞いをカスタマイズしてください。

#### `Map`型の値を作る2: `fromListWith`関数でキーの衝突に対処する

`fromListWith`関数は、`fromList`関数の機能に加えて、第一引数として「キーが重複した場合に、登録する値を返す関数」を受け取るようになっています。

例のごとく`ghci`の`:t`コマンドでチェックしてみましょう:

```haskell
ghci> :t fromListWith
fromListWith :: Ord k => (a -> a -> a) -> [(k, a)] -> Map k a
```

第一引数で指定する関数は、`a`型の値、つまり`Map k a`の値として使う値（「値」という単語がそれぞれ違う意味で使われているのでご注意）を二つ受け取って、`a`型の値を返します。

どのような関数を受け取るのか、実際に動かしながら確かめてみましょう。まずは比較対象として、先ほどの`fromList`関数を試します:

```haskell
ghci> fromListWith (\v1 v2 -> v1 + v2) [("one", 1), ("two", 2), ("two", 3)]
fromList [("one",1),("two",5)]
```

第一引数として足し算を行う関数を渡した結果、衝突するキー`"two"`に対応する値`2`・`3`が足されて`5`になりましたね！このように、`fromListWith`関数の第一引数にあたる関数は、キーが衝突した値2つを受け取り、該当するキーの新しい値を返します。

ちなみに、`fromListWith`関数の第一引数における関数の、二つの引数がそれぞれどのような順番で渡されるかは、上記の`(\v1 v2 -> v1 + v2)`では分かりませんよね？足し算は可換な演算ですし。気になる方は、値が文字列である`Map`を`fromListWith`で作って、文字列を結合する`++`を使った関数を渡して確かめてみてください！

#### 課題のヒント: `fromListWith`関数を使おう

今回の課題では、単語の出現回数を数える必要があるため、重複した単語を見つけた際に新しく見つけた方の単語の情報で上書きするのではなく、それまでに集めた単語の数と足し合わせる必要があります。

軽くネタばらしをすると、今回の課題は、よくある命令型スタイルで考えた場合にイメージするような、以下の疑似言語で表されるアルゴリズムをHaskellに直訳するのでは、**解けません**:

```javascript
単語毎の出現頻度 = 空のMap

for (単語 in 単語のリスト) {
  if (単語毎の出現頻度 has 単語) {
    単語毎の出現頻度[単語] += 1
  } else {
    単語毎の出現頻度[単語] = 1
  }
}
```

`単語のリスト`にある`単語`を一つずつ処理して、`単語毎の出現頻度`に登録済みであれば`単語毎の出現頻度`の該当する値に1追加して、登録済みでなければ`単語毎の出現頻度`の該当する値を1で初期化する、というアルゴリズムですね。これはいかにも命令型プログラミングスタイルといえるアルゴリズムで、Haskellではちょっとやりづらいです（これまで紹介していない機能を使えばできなくはないですが、割愛します）。

そこで、一旦単語のリストを`map`関数で`(単語, 1)`というタプルに変換した後、`fromListWith`で`Map`を組み立てましょう。その際、重複した単語が見つかった場合は「該当する単語の値として、それまでに保存されていた数」を足す、という処理を行ってください。次のようなコードです:

```haskell
wordAnd1s = map (\w -> (w, 1)) 単語のリスト
countsByWord = fromListWith (\x y -> x + y) wordAnd1s
```

試してみましょう:

```haskell
ghci> wordAnd1s = map (\w -> (w, 1)) ["a", "b", "a", "c", "c"]

<interactive>:6:13: error:
    Ambiguous occurrence ‘map’
    It could refer to
       either ‘Data.Map.Strict.map’,
              imported from ‘Data.Map.Strict’
              (and originally defined in ‘Data.Map.Strict.Internal’)
           or ‘Prelude.map’,
              imported from ‘Prelude’ (and originally defined in ‘GHC.Base’)
```

... が、1行目で見慣れないエラーにぶち当たってしまいました😰。次の節で解決方法をお話しします。

### `import`する関数・型の名前にプレフィックスを付ける

前節の最後に見たエラーメッセージを翻訳して分かりやすくすると、`map`という名前の関数が`Data.Map.Strict`モジュールと`Prelude`と言うモジュール両方に含まれているため曖昧になっている、という内容になります。`Data.Map.Strict`モジュールは先ほど`import`したもので、`Prelude`モジュールは課題hoge(13)で紹介した、「`import`しなくても利用できる」モジュールのことです。確かに`map`関数は課題hoge(15)で何も`import`しないで使ったとおり、`Prelude`に入っています。これらの名前が被ってしまっているため、「どっちの`map`関数を使っているのか分からないよ！」というエラーが発生したのです。

これを回避するための一つの手段として、`qualified`という機能が`import`文にはあります。`qualified`を使えば、指定したモジュールにある関数や型を、指定した名前のプレフィックス（prefix）を付けた場合のみ参照できるようにする機能です。

例えば、前述の`Data.Map.Strict`モジュールの関数を、`Map`というプレフィックスを付けた場合のみ参照できるようにするには、次のように書きます:

```haskell
ghci> import qualified Data.Map.Strict as Map
```

`import`の直後に`qualified`というキーワードを続けた後、モジュール名である`Data.Map.Strict`を指定して、最後に`as Map`と書くことで、`Data.Map.Strict`モジュールの関数や型を`Map.<関数の名前>`という形式で参照できるようになります:

```haskell
ghci> :t Map.fromList
Map.fromList :: Ord k => [(k, a)] -> Map.Map k a
ghci> Map.fromList [("one", 1), ("two", 2), ("three", 3)]
fromList [("one",1),("three",3),("two",2)]
```

上記のとおり、`Data.Map.Strict`の`fromList`関数は、`Map.fromList`という名前で参照できるようになりました。元のように単なる`fromList`として参照することはできません:

```haskell
ghci> :t fromList

<interactive>:1:1: error:
    ? Variable not in scope: fromList
    ? Perhaps you meant ‘Map.fromList’ (imported from Data.Map.Strict)
```

それから、先ほど`Ambiguous occurrence ‘map’`というエラーで参照できなかった`map`関数を`map`として参照すると、`Prelude`の`map`関数が使用されることが分かります:

```haskell
:t map
ghci> :t map
map :: (a -> b) -> [a] -> [b]

ghci> map (\x -> x * 2) [1, 2, 3]
[2,4,6]
```

リストに対する`map`関数が使われていますね！

先ほどエラーになってしまった例もこの通り:

```haskell
ghci> wordAnd1s = map (\w -> (w, 1)) ["a", "b", "a", "c", "c"]
ghci> countsByWord = Map.fromListWith (\x y -> x + y) wordAnd1s
ghci> countsByWord
fromList [("a",2),("b",1),("c",2)]
```

ちゃんと各単語がリストにいくつ含まれているか、カウントされているようです！

### `import`する関数・型の名前を指定する

ところで、先ほど`Map.fromList`の型を`:t`でチェックしたときのことを思い出してください:

```haskell
ghci> :t Map.fromList
Map.fromList :: Ord k => [(k, a)] -> Map.Map k a
ghci> Map.fromList [("one", 1), ("two", 2), ("three", 3)]
fromList [("one",1),("three",3),("two",2)]
```

`Map.fromList`の戻り値が、`Map.Map k a`という型になっていますね。`import qualified Data.Map.Strict as Map`と書いて`Data.Map.Strict`モジュールにおける関数や型すべてに`Map.`を付けて参照するようにしたのですから、`Map`型も`Map.Map`になるのは仕様上自然な振る舞いです。しかし、`Map.Map`という名前は同じ単語が繰り返されてちょっと不格好ですよね。

その解決策として、例えば`Map`型だけを`Map`としつつ、他の関数を`Map.`付きで参照するには、次のように`import Data.Map.Strict`の直後に`(Map)`と書いて`import`した上で、先ほどと同様`qualified`付きの`import`をしてください:

```haskell
ghci> import Data.Map.Strict (Map)
ghci> import qualified Data.Map.Strict as Map
ghci> :t Map.fromList
Map.fromList :: Ord k => [(k, a)] -> Map k a
```

`import Data.Map.Strict (Map)`は、`Data.Map.Strict`モジュールにある`Map`（と言う名前の型）だけを利用できるようにするための宣言です。これと先ほどの`import qualified Data.Map.Strict as Map`と組み合わせることで、`Map`型だけは単なる`Map`という名前で参照できるようになり、そのほかの関数や型は、`Map.`と言うプレフィックスを付けた上でのみ参照できるようになります。

なお、本課題ではこれ以降、上記のように`import Data.Map.Strict (Map)`と`import qualified Data.Map.Strict as Map`をGHCiに入力した前提で例を記述します。

#### `Map`型の値が持つすべての値に対して関数を適用する

本課題では、ここまで紹介した`fromListWith`関数で`Map`型の値を作った後、`Map`型の値にある、すべての値について「命令」を実行する必要があります。と、言えば、課題hoge(15?)で学習した`for_`関数や`for`関数がそうした機能を備えていますね（正確には、「命令を返す関数をリストの各要素に適用する」ですが、便宜的にこれ以降も「命令を返す関数に値を適用する」という意味で「値に対して命令を実行する」といった表現を用います）。

実はこの`for`や`for_`は、ともに`Map`型の値に対しても利用できるようになっています！以下は`for_`を`Map`型の値に使った例です:

```haskell
ghci> import Data.Foldable

ghci> keyValues = Map.fromListWith (\v1 v2 -> v1 + v2) [("one", 1), ("two", 2), ("three", 3)]
ghci> for_ keyValues print
1
3
2
```

実行結果に注目してください。`1`, `2`, `3`という、`keyValues`に含まれている**値**がそれぞれの行に表示されました。このことからして、`for_`に渡した関数、`print`は、`Map`型の値における値のみを受け取って呼ばれたようです。

#### `Map`型の値が持つキーと値すべてに関数を適用する

しかし実際のところ本課題では、「カウントしたそれぞれの単語について、`<単語> => <出現回数>`」という形式の行を表示するために、`Map`型の値が持つキーと値、すべてに対して同じ処理を行う必要があります。ファイルの中に含まれている単語をキー、単語が出現した回数を値として保存しているわけですから、キーと値の両方が必要なんですね。なので、`Map`型の値に対する`for_`では不十分です。

キーと値、両方に対して「命令」を実行する方法はいくつかありますが、ここでは`Map.toList`関数を使って一旦リストに変換してからリストの`for_`関数を使う、と言う方法を紹介します:

```haskell
ghci> Map.toList keyValues
[("one",1),("three",3),("two",2)]
```

上記の例の通り、`Map.toList`関数を`Map`型の値に適用すると、キーと値を含んだタプルのリストが返ってきます。`Map.fromList`関数とちょうど逆の操作を行う関数となっております。

後は、これまで何度も登場している`for_`関数を使えば、キーと値両方に対して命令を実行できます:

```haskell
ghci> import Data.Foldable
ghci> keyValues = Map.fromListWith (\v1 v2 -> v1 + v2) [("one", 1), ("two", 2), ("two", 3)]
ghci> for_ (Map.toList keyValues) print
("one",1)
("two",5)
```

`print`関数の出力を見ると、ちゃんとキーと値両方が渡されているようですね！

#### `Map`型の値から、キーに対応する値を取り出す（その1）

※これ以降における`Map`型について知識は、今回の課題を解くだけでは必要ありません。

ここでは、`Map`型のような、一般的な連想配列（ほかのプログラミング言語では`Hash`とか`Dict`などと呼ばれているデータ構造ですね）なら備えているべき、「指定したキーに対応する値を取り出す」演算子を紹介します。

Haskellの`Map`型の値において、「指定したキーに対応する値を取り出す」`!` という変わった名前の演算子を使います。なぜ感嘆符`!`（いわゆる「びっくりマーク」）を使ったのか定かではありませんが、`Map`の一点を刺すピンに見立てればそれっぽく見えるかも知れませんね。

さてこの`!`も、`Map`型に関する他の関数などと同様に、`Data.Map.Strict`モジュールを`import`しないと使えません。`!`のように、演算子を`import`する場合は次のように`!`をカッコで囲ってください:

```haskell
ghci> import Data.Map.Strict ((!))
```

カッコに二重に包まれていて冗長に感じられますが、これはHaskellのコンパイラーの都合です。ご容赦を。

カッコで囲い忘れた場合、次のようなエラーになります。参考までに見ておきましょう:

```haskell
ghci> import Data.Map.Strict (!)

<interactive>:6:25: error: parse error on input ‘!’
```

これまでの話を総合して、`Data.Map.Strict`モジュールの関数などを`Map.`というプレフィックス付きで参照しつつ、`Map`型や`!`演算子をプレフィックスなしで参照したい場合、次のように二つの`import`を書いてください:

```haskell
ghci> import qualified Data.Map.Strict as Map
ghci> import Data.Map.Strict (Map, (!))
```

それでは、いよいよ`!`演算子を使ってみましょう。左辺に対象となる`Map`型の値を、右辺に値を取り出したいキーを指定してください:

```haskell
ghci> keyValues = Map.fromList [("one", 1), ("two", 2)]
ghci> keyValues ! "one"
1
ghci> keyValues ! "two"
2
```

確かに、`keyValues`における、指定したキー`"one"`や`"two"`に該当する値を取得できましたね！

⚠️ただしこの`!`演算子、存在しないキーを指定すると例外が発生するのでご注意ください！

```haskell
ghci> keyValues ! "non existing"
*** Exception: Map.!: given key is not an element in the map
CallStack (from HasCallStack):
  error, called at libraries\\containers\\Data\\Map\\Internal.hs:610:17 in containers-0.6.0.1:Data.Map.Internal
```

これは、`read`関数に不正な文字列を与えた場合（例えば、整数をパースしたいのに`"not a number"`のような文字列を与えた場合）とよく似た振る舞いです。課題hoge(12?)で解説したとおり、例外が発生すると、プログラムがその場で終了してしまう恐れがあり、あまり好ましくありません。そのため、実際のところ`Data.Map.Strict`モジュールは`!`演算子より優れた関数を提供してくれています。詳細はこの次の課題でで紹介しますので、乞うご期待！

#### `Map`型の値を更新する

もう一つ、`Map`型のような値が一般的な連想配列と同様に備えているべき、「`Map`型の値を更新（あるいは新しい値を追加する）する」`insert`関数を紹介しましょう。

`insert`関数は、次のとおり3つの関数を受け取ります:

1. 第一引数に更新（あるいは値を追加したい）したいキー
1. 第二引数に更新した後の（あるいは追加したい）値
1. 第三引数に対象の`Map`型の値

指定したキーが`Map`型の値に存在しなかった場合、指定した値をキーに紐付く値として追加します:

```haskell
ghci> keyValues = Map.fromList [("one", 1), ("two", 2)]
ghci> Map.insert "four" 4 keyValues
fromList [("four",4),("one",1),("two",2)]
```

`insert`関数は、キーを追加した、新しい`Map`を作って返す点にご注意ください。`Map.insert "four" 4 keyValues`したあとでも、`keyValues`の中身が変わっていないのです:

```haskell
-- `Map.insert`を実行した後も`keyValues`の中身は変わっていない！
ghci> keyValues
fromList [("one",1),("two",2)]
```

指定したキーが`Map`型の値にすでに存在していた場合、指定した値でキーに紐付く値を書き換えます:

```haskell
ghci> Map.insert "two" 3 keyValues
fromList [("one",1),("two",3)]
```

ちなみに、指定したキーが`Map`型の値にすでに存在していた場合の挙動をカスタマイズする、`insertWith`関数もあります。`insert`と`insertWith`関数の関係は`fromList`と`fromListWith`関数の関係とよく似ています。`Map`型の値においてキーに紐付いた値がすでに存在していた場合`insertWith`関数は、ユーザーが指定した関数に「元々キーに紐付いていた値」と「新たに`insert`しようとした値」の二つを渡すことで、どのような値を新たに紐付けるか決めさせます。

下記は、`(\v1 v2 -> v1 + v2)`という関数を`insertWith`に渡すことで、`"two"`というキーに紐付く値が`keyValues`にすでに存在していた場合、元々あった値と新しい値`3`を足し合わせる処理です:

```
ghci> Map.insertWith (\v1 v2 -> v1 + v2) "two" 3 keyValues
fromList [("one",1),("two",5)]
```

`insert`や`insertWith`のように`Map`型の値を更新する関数は、他にもたくさんあります。詳しくは[`Data.Map.Strict`モジュールのドキュメント](http://hackage.haskell.org/package/containers-0.6.0.1/docs/Data-Map-Strict.html)をご覧ください。

### `concat`関数でリストのリストを結合する

```
ghci> concat [[1, 2, 3], [4, 5, 6], [7, 8], [9]]
[1,2,3,4,5,6,7,8,9]
```

## 課題のヒント

- ファイルの中身を、`words`関数で単語のリストに変換した後、`[(<単語>, 1)]`という内容の、ペアのリストに変換すると、`Map.insertWith (\v1 v2 -> v1 + v2)`できれいに「単語ごとの出現回数を含む`Map`」が作れます。
- `Data.Map.Strict`の`toList`を使うつもりが、`Data.Foldable`の`toList`を使ってしまっていないか注意してください。  
  `Data.Foldable`の`toList`は`Map`型に対しても使えますが、こちらは`Data.Map.Strict`の`toList`と異なり、**値しか列挙しません**。  
  結果、かなりわかりづらいエラーメッセージになる恐れがあります。
