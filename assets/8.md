# タプルを扱う

`Integral`型クラスのメソッド`divMod`と`quotRem`は、どちらも整数の割り算の商と余りを求めるためのものです。  
それぞれの違いを確かめるために次のようなプログラムを書きましょう。

1. 標準入力から2行の入力を受け取ります。
2. 1行目は「分子」を表す整数として解釈します。
3. 2行目は「分母」を表す整数として解釈します。
4. 「分子」と「分母」を`divMod`関数と`quotRem`関数それぞれに渡し、それぞれの商と余りを別々に表示してください。

## 実行結果例

```bash
shell> stack exec runhaskell 8.hs
9 -- ユーザーによる入力
7 -- ユーザーによる入力
div: 1
mod: 2
quot: 1
rem: 2
```

## 必要な知識

### タプルを作る

タプルというのは、Haskellに標準で存在する、複数の値をまとめる「お手軽な型」です。  
複数の値を返す関数を書きたい、でもそれだけのために新しいレコード型を定義したりするのは面倒だなぁ、と言うときに使うのが主なユースケースです。  
今回の課題で使う`divMod`関数や`quotRem`関数も、まさにそうした用途にタプルを使用しています。

例えば、2つの文字列を持つタプルは、次のように書くことが出来ます。

```haskell
ghci> ("1st element", "2nd element")
("1st element","2nd element")
```

3つの文字列を持つタプル、4つの文字列を持つタプルはこう:

```haskell
ghci> ("1st element", "2nd element", "3rd element")
("1st element","2nd element","3rd element")
ghci> ("1st element", "2nd element", "3rd element", "4rd element")
("1st element","2nd element","3rd element","4rd element")
```

一つのタプルの中にはいろいろな型の値を含めることができます。  

```haskell
-- 数値・文字列のタプル
ghci> (1, "2nd element")
(1,"2nd element")

-- 数値・文字列・文字列のリストのタプル
ghci> (1, "2nd element", ["3rd", "element"])
(1,"2nd element",["3rd","element"])

-- 数値・文字列・文字列のリスト・数値のリストのタプル
ghci> (1, "2nd element", ["3rd", "element"], [3.14, 159.2])
(1,"2nd element",["3rd","element"],[3.14,159.2])
```

タプルの中にタプルを入れることも問題ありません。

```haskell
-- 「数値・文字列のタプル」・文字列のタプル
((1, "2nd element in the inner tuple"), "2nd element in the outer tuple")

-- 「数値・文字列のタプル」・文字列のリストのタプル
((1, "2nd element in the inner tuple"), ["2nd", "element", "in", "the", "outer", "tuple"])
```

おなじみ`:t`コマンドで、タプルの型を見てみましょう。

```haskell
-- 文字列・文字列のタプル
ghci> :t ("1st element", "2nd element")
("1st element", "2nd element") :: ([Char], [Char])

-- 文字列・真偽値のタプル
ghci> :t ("1st element", True)
("1st element", True) :: ([Char], Bool)

-- 真偽値・文字列のタプル
ghci> :t (False, "2nd element")
(False, "2nd element") :: (Bool, [Char])

-- 真偽値・文字列・真偽値のタプル
ghci> :t (True, "2nd element", False)
(True, "2nd element", False) :: (Bool, [Char], Bool)
```

これらの結果のように、**すべての要素の型が型定義に**現れるのが特徴です。  
例えば、`:t ("1st element", True)`の結果、`([Char], Bool)`は、コメントのとおり、

- 一つ目の要素の型が文字のリスト `[Char]`、つまり文字列（課題6の「`++`で文字列を結合する」を参照）であり、
- 二つ目の要素の型が真偽値 `Bool`である

ことを表しています。  
少し紛らわしいですが、

- タプル型は（値と同様に）要素を丸カッコ `()` で囲ってカンマで区切って列挙する
- 「文字のリスト」が`[Char]`で表されるとおり、リスト型は要素の型を角括弧 `[]`で囲う

という点に注目してください。

リストは、あくまでも一つの型の値を複数入れるための型なので、型定義にも一つの型しか現れません。  
リストが、中に入った値の数が不定（0個の時も1個の時もそれ以上の時もある）である代わりに一つの型の値しか入れられないのに対して、タプルは、中に入る値の数を決めて「何番目にどの型の値が入っているか」を型定義に含めることにしました。  
なぜこのように分かれているのかというと、「いろいろな型の値」が「何番目に含まれているかわからない」という型が仮にあったとすると、「関数は一つの決まった型の値しか受け取れない」という静的型付け言語の原則に反してしまうからです。  
例えばリストの「すべての値に3を足す」という処理を行いたい場合、「いろいろな型の値」が「何番目に含まれているかわからない」と、間違って文字列や真偽値など、「3を足す」ことができない値に出くわすかも知れません。  
他のプログラミング言語の中には、このような場合にエラーを起こしたり（3を文字列に変換するなど）値を強引に変換したりするといった対応を行うものもありますが、Haskellは型に対して厳格なので、そうしたことは行いません。  
そうした強引な変換を行わず、確実に処理できるようにするために、

- リストは一つの型の値を不定個（0個の時も1個の時もそれ以上の時もある）入れて、
- タプルはいろいろな型の値を決まった数だけ入れる

という役割分担をしているのです。

#### リストとタプルと整数のリテラルの理解を深める

次のように角括弧`[]`を丸括弧`()`に変えることで、リストからタプルに変えると、リストとタプルの違いがさらにわかります。

```haskell
ghci> :t [1, 2, 3]
[1, 2, 3] :: Num a => [a]
```

```haskell
ghci> :t (1, 2, 3)
(1, 2, 3) :: (Num a, Num b, Num c) => (a, b, c)
```

おっと... また少し見慣れない記法が出てきましたね。  
課題7でも出てきた`Num a => `と、今回初対面の`(Num a, Num b, Num c) => `という部分は一旦脇に置いて、それより後ろの`[a]`と`(a, b, c)`という部分を理解しましょう。  
まず、`a`や`b`、`c`といったアルファベットの小文字で始まる名前で表されているものは「型変数」です。  
これは課題7でも取り上げましたね。「何かの型」を表す変数なのでした。

そして先ほども触れたとおり、タプル型は丸カッコ`()`で囲ってカンマで区切って要素の型を列挙し、リスト型は要素の型を角括弧`[]`で囲う、という表記で表されるので、

- `[a]`は何かの型`a`の値が入ったリスト型
- `(a, b, c)`は何かの型`a`、`b`、`c`が入ったタプル型

をそれぞれ表しています。

何かの型`a`、`b`、`c`は違う名前で表されていることから察する方もいらっしゃるでしょう。  
そう、型変数が異なる文字で表されている場合、それぞれ別々の型を表しています[^diff-abc]。

[^diff-abc]: 絶対に違う型でなければならない、というわけではなく、型推論した結果、結局同じ型になることはあります。  
なので厳密には「それぞれ別々かも知れない型」という方が正しいです。

このように、`[1, 2, 3]`を`(1, 2, 3)`に変える、つまりリストからタプルに変えると、中に入っている値の型も異なった方法で推論されるようになります。  
リスト型は一つの型の値しか入れることができないので要素`1`・`2`・`3`はすべて同じ型`a`と見なされる一方、タプル型はそれぞれの要素の型が異なるかも知れないので、要素`1`・`2`・`3`はそれぞれ別の型`a`・`b`・`c`と見なされるのです。

課題7で触れたとおり、Haskellでは、整数リテラルの型はあくまでも「`Num`型クラスのインスタンスである型のうちの何か」と推論されます。  
加えて、`(1, 2, 3)`における`1`・`2`・`3`のように、特に足し算やかけ算など他の計算に使用されていない整数リテラルは、そのままそれぞれが別々の型、として推論されます。  
なので`(1, 2, 3)`における`1`・`2`・`3`は「`Num`型クラスのインスタンスである、それぞれ別の型`(a, b, c)`」として推論されたのです。  
一方リストの場合は、すべての要素の型が一致していないといけないので、`[1, 2, 3]`における`1`・`2`・`3`は「`Num`型クラスのインスタンスである、一つの型`[a]`」として推論されたわけですね。

ここまで説明すれば、

```haskell
(Num a, Num b, Num c) =>
```

という部分の意味も大体推測できるのではないでしょうか。  
これは課題7で出てきた`Num p => `という記法の発展版です。  
`Num p =>`書くと「`p`が`Num`型クラスのインスタンスである場合の～」という意味であったように、`(Num a, Num b, Num c) =>`は、「型`a`・`b`・`c`の**すべてが**`Num`型クラスである場合の～」という意味となります。

従って、`(Num a, Num b, Num c) => (a, b, c)`という型定義は「型`a`・`b`・`c`の**すべてが**`Num`型クラスである場合の`a`・`b`・`c`のタプル型」、言い換えると「`Num`型クラスのインスタンスである三つの型`a`・`b`・`c`のタプル型」を表しています。  
`=>`の左辺に「どの型変数の型がどんな型クラスのインスタンスであるべきか」という条件（Haskellの仕様では「制約(constraint)」と呼ばれています）をカッコで囲ってカンマで区切って列挙することで、列挙した**すべての**条件を、右辺にある型変数の型が満たしている、と表現することができます。

#### タプルの要素数について少し

ちなみに、1要素、つまり値の数が一つだけのタプルというのはありません。  
試しに値を1個だけカッコで囲ったものを書いてみると良くわかります。

```haskell
ghci> :t ("one element tuple?")
("one element tuple?") :: [Char]
ghci> ("one element tuple?")
"one element tuple?"
```

ご覧のとおり、`("one element tuple?")`の型は`[Char]`、つまり単なる`[Char]`型となっています。  
カッコで囲われてないことからして、タプル型ではないことがわかります。  
それから`("one element tuple?")`を評価した結果も単なる`"one element tuple?"`、つまりカッコに囲われていない、タプルでない単一の値になっています。  
これは単純に、Haskellでは値が一つだけのタプルなんて特に何も用途がないためです。

それから、最大の要素数は62個と決まっています。  
これは単純に大きすぎると判断したんでしょう。

```haskell
ghci> (1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63)

<interactive>:5:1: error:
    A 63-tuple is too large for GHC
      (max size is 62)
      Workaround: use nested tuples or define a data type
```

タプルは要素数が異なれば別々の型として見なされるため、要素を一つ増やすごとに新しい型を定義しなければならないのです。  
なので無制限に増やすことはできないので、62個もあれば十分多いと判断し、それを最大としたのでしょう。

### ここまでの型に関するまとめ

ここまで、タプル型の特徴を理解するにあたり、関連する、様々な型に関わる構文や記法を学習しました。  
いろいろな方向に飛んだのでここでまとめます。

- タプルはHaskellに標準で存在する、複数の値をまとめる「お手軽な型」。
    - 複数のいろいろな型の値を簡単にまとめることができる。
        - 例: `("abc", 123, True)`
    - 値の数が決まっていて、何番目に何の型の値が入っているかが決まっている。
        - 例: `("abc", 123, True)`の型は`Num a => ([Char], a, Bool)`
    - 一方リストは値の数が決まっていないため、必ず一種類の型の値のみ入ることが決まっている。
        - 例: `[True, False, True]`の型は`[Bool]`
- 型定義における`=>`の左側に、「どの型変数の型がどんな型クラスのインスタンスであるべきか」という条件（制約）をカッコで囲ってカンマで区切って列挙すると、列挙した**すべての**条件を右辺にある型が満たしている、という意味になる。
    - 例: `(1, 2)` の型は`(Num a, Num b) => (a, b)`
- 型定義において型変数が異なる名前で表される場合、それらはすべて異なる（かも知れない）型として推論される。
    - 例: `(1, 2)` の型は`(Num a, Num b) => (a, b)`で、`a`・`b`はそれぞれ`Integer`・`Double`かも知れないし、両方`Integer`かも知れない
- タプルの要素数は2個から62個まで。

### タプルから個別の要素の値を取り出す

タプルの個別の要素にアクセスしたい場合、`let`などで代入するときに、パターンマッチという機能を使って各要素をどの変数に代入するか指定することで、アクセスしたい個別の要素を指定した変数に代入することができます。

```haskell
ghci> (a, b, c) = ("aaa", 'b', 9)
ghci> a
"aaa"
ghci> b
'b'
ghci> c
9
```

上記の例では、変数`a`・`b`・`c`にそれぞれタプルの第1要素、第2要素、第3要素の値が代入されましたね。  
このように、パターンマッチを使ってタプルからそれぞれの要素を取り出す場合は、`=`の左辺において（タプルを作る際と同様に）丸カッコ `()` で囲ってカンマで区切って代入したい変数を列挙します。

それから、パターンマッチでそれぞれの要素の値を変数に代入すると同時に、タプル全体も別の変数に代入したい、なんて時がたまにあります。  
そんなときは、下記のように左辺でタプル全体を代入したい変数の直後にアットマーク`@`を書きましょう:

```haskell
ghci> d@(a, b, c) = ("aaa", 'b', 9)
ghci> d
("aaa",'b',9)
```

これは「asパターン」と呼ばれている機能です。  
使用頻度はあまり高くないですが、`@`が`as`の略だと覚えれば覚えやすい、ですよね？

パターンマッチは、このようにタプルの個別の要素を変数に対応させて代入する以外にも、もっともっといろいろなことができます。  
詳細は次の課題で。

#### 要素数が2のタプルに特化した関数

要素数が2のタプルは非常によく使われるので、`fst`と`snd`という、1つめの要素と2つめの要素にアクセスするための関数が、標準で定義されています。  
これらの関数は`:t`で型を確認してみると、それだけで振る舞いが想像できるものとなっています。

```haskell
ghci> :t fst
fst :: (a, b) -> a
ghci> :t snd
snd :: (a, b) -> b
```

小文字で始まる名前の型、型変数`a`・`b`がまた出てきました。  
これらは特定の型を指しているワケではなく、「任意の型」に変わりうることを表しているのでしたね。

一つの型定義において、異なる名前の型変数が異なる（かも知れない）型を表していた一方、同じ名前の型変数は、すべて同じ型でないといけないことになっています。  
そのため、例えば`fst`関数はその型定義`(a, b) -> a`のとおり、必ずタプルの一つ目の要素の型と同じ値を返さないといけません。  
`snd`関数も同様、`(a, b) -> b`のとおり、必ずタプルの二つ目の要素の型と同じ値を返すこととなっています。

そして動作もやっぱりその名前、その型定義のとおりとなっています。

```haskell
ghci> fst ("foo", "bar")
"foo"
ghci> snd ("foo", "bar")
"bar"
```

`fst`と`snd`はあくまでも要素数が2のタプル専用なので、要素数が3以上のタプルに対して使うと型エラーになります。  

```haskell
ghci> fst ("foo", "bar", "baz")

<interactive>:6:5: error:
    • Couldn't match expected type ‘(a, b0)’
                  with actual type ‘([Char], [Char], [Char])’
    • In the first argument of ‘fst’, namely ‘("foo", "bar", "baz")’
      In the expression: fst ("foo", "bar", "baz")
      In an equation for ‘it’: it = fst ("foo", "bar", "baz")
    • Relevant bindings include it :: a (bound at <interactive>:6:1)

ghci> snd ("foo", "bar", "baz")

<interactive>:7:5: error:
    • Couldn't match expected type ‘(a0, b)’
                  with actual type ‘([Char], [Char], [Char])’
    • In the first argument of ‘snd’, namely ‘("foo", "bar", "baz")’
      In the expression: snd ("foo", "bar", "baz")
      In an equation for ‘it’: it = snd ("foo", "bar", "baz")
    • Relevant bindings include it :: b (bound at <interactive>:7:1)
```

タプルは要素数が異なれば異なる型として扱われるので、要素数が2のタプル専用の関数は、要素数2のタプルにしか使えませんし、要素数が3のタプル専用の関数は要素数3のタプルにしか使えません。  
型クラスを使えばあらゆる要素数のタプルに対する`fst`や`snd`が作れますが、残念ながら標準ではそのような関数は提供されていません。  
まぁ、要素数3以上のタプルをそんなに頻繁に使うな、と言うことでしょう。

### `Integral`型クラス

今回の課題で欠かせない`quotRem`関数`divMod`関数を提供する、`Integral`型クラスについても深掘りしましょう。  
`Integral`型クラスは「整数っぽい」型をまとめた型クラスです。  
早速`:i`コマンドで詳細を見てみましょう。

```haskell
ghci> :i Integral
class (Real a, Enum a) => Integral a where
  quot :: a -> a -> a
  rem :: a -> a -> a
  div :: a -> a -> a
  mod :: a -> a -> a
  quotRem :: a -> a -> (a, a)
  divMod :: a -> a -> (a, a)
  toInteger :: a -> Integer
  {-# MINIMAL quotRem, toInteger #-}
        -- Defined in ‘GHC.Real’
instance Integral Word -- Defined in ‘GHC.Real’
instance Integral Integer -- Defined in ‘GHC.Real’
instance Integral Int -- Defined in ‘GHC.Real’
```

`(Real a, Enum a) => Integral a`という表記は「`Integral`型クラスのインスタンスである型は、`Real`型クラスと`Enum`型クラスのインスタンスでもある必要がある」という意味です。  
「スーパークラス」と呼ばれています。  
タプルの節で紹介した`(Num a, Num b, Num c) => (a, b, c)`と同じ構文を利用していることに注目してください。  
`(Real a, Enum a) => Integral a`における`=>`の左側では、`Real a`と`Enum a`を列挙することで、型変数`a`が表す型が`Real`型クラスと`Enum`型クラス、両方のインスタンスでなければならないことを示しています（`Real`型クラスと`Enum`型クラスの詳細は割愛します）。  
このように書くことで、`Integral`型クラスのインスタンスである型は、前提として`Real`型クラスと`Enum`型クラスのインスタンスでなければならないことを示すことができるのです。  
いわゆるよくあるオブジェクト指向言語における「スーパークラス」ともちょっと似ていますね。

`:i Integral`の結果の最後の3行、`instance ...`で始まる行は、`Integral`型クラスのインスタンスを列挙しています。  
おなじみの`Integer`型に加え、`Word`型、`Int`型という型も`Integral`型クラスのインスタンスだそうです。

ついでなんで、それぞれの特徴をここでまとめておきます。

- `Word`: 符号なし固定長の整数。C言語で言うところの`unsigned int`。実際の長さ（ビット数）はHaskellの実装に依存します。現在よく使われている64ビットOSでは64ビットであるはずです。
- `Integer`: 符号あり多倍長の整数。これまで我々が使ってきたもの。
- `Int`: 符号あり固定長の整数。C言語で言うところの`int`。こちらも`Word`と同様に、実際の長さはHaskellの実装に依存しますし、64ビットであることが多いです。

それからメインディッシュ、`class (Real a, Enum a) => Integral a where`の次の行からインデントして列挙された、`Integral`型クラスのメソッドに注目しましょう。

```haskell
  quot :: a -> a -> a
  rem :: a -> a -> a
  div :: a -> a -> a
  mod :: a -> a -> a
  quotRem :: a -> a -> (a, a)
  divMod :: a -> a -> (a, a)
  toInteger :: a -> Integer
```

上記のとおり7つのメソッドが定義されておりますが、今回注目するのは`toInteger`以外の6つです。  
これらは整数の割り算における商と余りを計算します。

そのうち`quot`と`div`は割り算の商を、`rem`と`mod`は割り算の余りを計算します。

```haskell
-- 14 / 5 = 2
ghci> quot 14 5
2
ghci> div 14 5
2

-- 14 / 5 の余りは4
ghci> mod 14 5
4
ghci> rem 14 5
4
```

そして`quotRem`と`divMod`は、商と余りをまとめてタプルにして返してくれます。

```haskell
ghci> quotRem 9 5
(1,4)
ghci> divMod 9 5
(1,4)
```

`quot`と`rem`、`div`と`mod`、それから`quotRem`と`divMod`は、一見同様に商や余りを計算しますが、計算結果がちょっと異なることがあります。  
どう異なるかは、課題を解いて動かしてからのお楽しみ、ということで！

## 課題の解き方

`div`・`mod`と`quot`・`rem`を別々に適用しても今回の課題は解けますが、今回はタプルの操作に慣れるために、`divMod`と`quotRem`を使って解いてください。
