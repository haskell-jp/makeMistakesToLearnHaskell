# タプルを扱う

`Integral`型クラスのメソッド`divMod`と`quotRem`は、どちらも整数の割り算の商と余りを求めるためのものです。  
それぞれの違いを確かめるために次のようなプログラムを書きましょう。

1. 標準入力から2行の入力を受け取ります。
2. 1行目は「分子」を表す整数として解釈します。
3. 2行目は「分母」を表す整数として解釈します。
4. 「分子」と「分母」を`divMod`関数と`quotRem`関数それぞれに渡し、それぞれの商と余りを別々に表示してください。

## 実行結果例

```bash
shell> stack exec runhaskell 8.hs
9
7
div: 1
mod: 2
quot: 1
rem: 2
```

## 必要な知識

### タプルを作る

タプルというのは、Haskellに標準で存在する、複数の値をまとめる「お手軽な型」です。  
複数の値を返す関数を書きたい、でもそれだけのために新しいレコード型を定義したりするのは面倒だなぁ、と言うときに使うのが主なユースケースです。  
今回の課題で使う`divMod`関数や`quotRem`関数も、まさにそうした用途にタプルを使用しています。

例えば、2つの文字列を持つタプルは、次のように書くことが出来ます。

```haskell
ghci> ("1st element", "2nd element")
("1st element","2nd element")
```

3つの文字列を持つタプル、4つの文字列を持つタプルはこう:

```haskell
ghci> ("1st element", "2nd element", "3rd element")
("1st element","2nd element","3rd element")
ghci> ("1st element", "2nd element", "3rd element", "4rd element")
("1st element","2nd element","3rd element","4rd element")
```

一つのタプルの中にはいろいろな型の値を含めることができます。  

```haskell
-- 数値・文字列のタプル
ghci> (1, "2nd element")
(1,"2nd element")

-- 数値・文字列・文字列のリストのタプル
ghci> (1, "2nd element", ["3rd", "element"])
(1,"2nd element",["3rd","element"])

-- 数値・文字列・文字列のリスト・数値のリストのタプル
ghci> (1, "2nd element", ["3rd", "element"], [3.14, 159.2])
(1,"2nd element",["3rd","element"],[3.14,159.2])
```

タプルの中にタプルを入れることも問題ありません。

```haskell
-- 「数値・文字列のタプル」・文字列のタプル
((1, "2nd element in the inner tuple"), "2nd element in the outer tuple")

-- 「数値・文字列のタプル」・文字列のリストのタプル
((1, "2nd element in the inner tuple"), ["2nd", "element", "in", "the", "outer", "tuple"])
```

おなじみ`:t`コマンドで、タプルの型を見てみましょう。

```haskell
-- 文字列・文字列のタプル
ghci> :t ("1st element", "2nd element")
("1st element", "2nd element") :: ([Char], [Char])

-- 文字列・真偽値のタプル
ghci> :t ("1st element", True)
("1st element", True) :: ([Char], Bool)

-- 真偽値・文字列のタプル
ghci> :t (False, "2nd element")
(False, "2nd element") :: (Bool, [Char])

-- 真偽値・文字列・真偽値のタプル
ghci> :t (True, "2nd element", False)
```

これらの結果のように、**すべての要素の型が型宣言に**現れるのが特徴です。  
例えば、`:t ("1st element", True)`の結果、`([Char], Bool)`は、コメントのとおり、

- 一つ目の要素の型が文字のリスト `[Char]`、つまり文字列（課題6の「`++`で文字列を結合する」を参照）であり、
- 二つ目の要素の型が真偽値 `Bool`である

ことを表しています。  
似たような名前の型でわかりづらいですが、

- タプル型は（値と同様に）要素を丸カッコ `()` で囲ってカンマで区切って列挙する
- 「文字のリスト」が`[Char]`で表されるとおり、リスト型は要素の型を角括弧 `[]`で囲う

という点に注目してください。

hoge

一方リストは、あくまでも一つの型の値を複数入れるための型なので、型宣言にも一つの型しか現れません。  
リストは、中に入った値の数が不定（0個の時も1個の時もそれ以上の時もある）である代わりに、一つの型の値しか入れられないのに対して、タプルは、中に入る値の数を決めて「何番目にどの型の値が入っているか」を型宣言に含めることにしました。  
そのためいろいろな型の値を決まった数だけ入れることができるんですね。

以下のように角括弧 `[]`を丸括弧 `()`に変えることで、リストからタプルに変えると、違いがよくわかります。

```haskell
ghci> :t [1, 2, 3]
[1, 2, 3] :: Num a => [a]
```

```haskell
ghci> :t (1, 2, 3)
(1, 2, 3) :: (Num a, Num b, Num c) => (a, b, c)
```

これは課題7で出てきた`Num p => p`という型宣言の発展版です。

hoge

なお、1要素のタプルというのはありません。  
それから、最大の長さは62個と決まっています。  
単純に大きすぎると判断したんでしょう。

```haskell
ghci> (1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63)

<interactive>:5:1: error:
    A 63-tuple is too large for GHC
      (max size is 62)
      Workaround: use nested tuples or define a data type
```

### タプルから値を取り出す

タプルの個別の要素にアクセスするには、`let`などで代入するときに、パターンマッチという機能を使って各要素をどの変数に代入するか指定します。

```haskell
ghci> (a, b, c) = ("aaa", 'b', 9)
ghci> a
"aaa"
ghci> b
'b'
ghci> c
9
```

```haskell
ghci> d@(a, b, c) = ("aaa", 'b', 9)
ghci> d
("aaa",'b',9)
```

「asパターン」という機能です。

パターンマッチは、タプルの要素を変数に対応づけて代入する以外にも、もっといろいろなことができます。  
詳細は次の課題で。

要素数が2のタプルは非常によく使われるので、`fst`と`snd`という、1つめの要素と2つめの要素にアクセスするための関数が、標準で定義されています。  
これらの関数は、`:t`で型を確認してみると、それだけで振る舞いが想像できるものとなっています。

```haskell
ghci> :t fst
fst :: (a, b) -> a
ghci> :t snd
snd :: (a, b) -> b
```

小文字で始まる名前の型、型変数`a`・`b`が出てきました。  
課題7で紹介したとおり、これらは特定の型を指しているワケではなく、「任意の型」に変わりうることを表しています。

それからここで、型変数について新たに情報を追加します。  
一つの型注釈において同じ名前の型変数は、すべて同じ型でないといけないことになっています。  
そのため、例えば`fst`関数はその型注釈`(a, b) -> a`のとおり、必ずタプルの一つ目の要素の型と同じ値を返さないといけません。  
`snd`関数も同様に、`(a, b) -> b`のとおり、必ずタプルの二つ目の要素の型と同じ値を返すこととなっています。

そして動作もやっぱりその名前、その型のとおりとなっています。

```haskell
ghci> fst ("foo", "bar")
"foo"
ghci> snd ("foo", "bar")
"bar"
```

`fst`と`snd`はあくまでも要素数が2のタプル専用なので、要素数が3以上のタプルに対して使うと型エラーになります。  

```haskell
ghci> fst ("foo", "bar", "baz")

<interactive>:6:5: error:
    • Couldn't match expected type ‘(a, b0)’
                  with actual type ‘([Char], [Char], [Char])’
    • In the first argument of ‘fst’, namely ‘("foo", "bar", "baz")’
      In the expression: fst ("foo", "bar", "baz")
      In an equation for ‘it’: it = fst ("foo", "bar", "baz")
    • Relevant bindings include it :: a (bound at <interactive>:6:1)

ghci> snd ("foo", "bar", "baz")

<interactive>:7:5: error:
    • Couldn't match expected type ‘(a0, b)’
                  with actual type ‘([Char], [Char], [Char])’
    • In the first argument of ‘snd’, namely ‘("foo", "bar", "baz")’
      In the expression: snd ("foo", "bar", "baz")
      In an equation for ‘it’: it = snd ("foo", "bar", "baz")
    • Relevant bindings include it :: b (bound at <interactive>:7:1)
```

タプルは要素数が違えば異なる型として扱われるので、要素数が2のタプル専用の関数は要素数2のタプルにしか使えませんし、要素数が3のタプル専用の関数は要素数3のタプルにしか使えません。  
型クラスを使えばあらゆる要素数のタプルに対する`fst`や`snd`が作れますが、残念ながら標準ではそのような機能は提供されていません。  
まぁ、要素数3以上のタプルをそんなに頻繁に使うな、と言うことでしょう。

### `Integral`型クラス

hoge

「整数っぽい」型の型クラス。

```haskell
ghci> :i Integral
class (Real a, Enum a) => Integral a where
  quot :: a -> a -> a
  rem :: a -> a -> a
  div :: a -> a -> a
  mod :: a -> a -> a
  quotRem :: a -> a -> (a, a)
  divMod :: a -> a -> (a, a)
  toInteger :: a -> Integer
  {-# MINIMAL quotRem, toInteger #-}
        -- Defined in ‘GHC.Real’
instance Integral Word -- Defined in ‘GHC.Real’
instance Integral Integer -- Defined in ‘GHC.Real’
instance Integral Int -- Defined in ‘GHC.Real’
```

`(Real a, Enum a) => Integral a`と言う表記で、`Integral`型クラスのインスタンスである型は、`Real`型クラスと`Enum`型クラスのインスタンスでもある必要がある、と表しています。  
「スーパークラス」と呼ばれています。

- `Word`: 符号なし固定長の整数。C言語で言うところの`unsigned int`。実際の長さ（ビット数）は実装に依存します。
- `Integer`: 符号あり多倍長の整数。これまで我々が使ってきたもの。
- `Int`: 符号あり固定長の整数。C言語で言うところの`int`。実際の長さ（ビット数）は実装に依存します。

```haskell
ghci> div 9 5
1
ghci> mod 9 5
4
ghci> quot 9 5
1
ghci> rem 9 5
4
ghci> divMod 9 5
(1,4)
ghci> quotRem 9 5
(1,4)
```

## 課題の解き方

`div`・`mod`と`quot`・`rem`を別々に適用しても今回の課題は解けますが、タプルの操作に慣れるために、`divMod`と`quotRem`を使って解いてください。
