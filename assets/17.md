# 取り得る値を型で明示する・エラーを型宣言で明示する

以下のコマンドを持つ、簡単なインメモリーのデータベース（？）のプロトタイプを作りましょう。

```
add <keyとなる文字列> <整数>
get <keyとなる文字列>
quit
```

1. 「keyとなる文字列ごとに、整数を値として持つ連想配列`(A)`」を初期化します。
2. 以下の処理を繰り返し実行します。
    1. 標準入力から、文字列を1行分取得します。
    2. 受け取った行を空白で分割し、分割した結果に応じて、下記のような処理を実行します。
        - 分割した結果のリストの内容が「`add`という文字列で始まる、3つの要素を持つリスト」であった場合、3つめの要素の内容に応じて、以下のいずれかの処理を行います。
            - 2つめの要素を「keyとなる文字列」、3つめの要素を「値となる整数」として解釈し、連想配列`(A)`の、keyに対応する値として追加します。
                - その後、`Adding <3つめの要素となる整数> to <keyとなる文字列>.`という形式の文字列を標準出力に出力します。
            - 3つめの要素が「値となる整数」として解釈できない文字列であった場合、`Error: Invalid Command`という文字列を標準出力に出力します。
        - 分割した結果のリストの内容が「`get`という文字列で始まる、2つの要素を持つリスト」であった場合、以下のいずれかの処理を行います。
            - 2つめの要素を「keyとなる文字列」として解釈し、連想配列`(A)`における、keyに対応する値が存在する場合、連想配列`(A)`から、keyに対応する整数を取り出します。
                - そして、<keyとなる文字列> => <対応する整数>`という形式の文字列を標準出力に出力します。
            - 一方、keyに対応する値が存在しない場合、`Error: no item found`という文字列を標準出力に出力します。
        - 分割した結果のリストの内容が「`quit`という文字列のみを持つリスト」であった場合、繰り返しをやめ、プログラム全体を終了します。
        - それ以外の場合、`Error: Invalid Command`という文字列を標準出力に出力します。

## 必要な知識

今回の課題で習う新しい知識に加えて、これまでに習ったいろいろなことを再利用します。主なものは次のとおりです。読み飛ばしたものがあれば戻って復習しましょう:

- 再帰処理
- `Map`型の値に対する`insertWith`

### 値の種類によって、保持できる値を切り替えられる型（直和型）を作る

課題16で紹介した「`Map`型の値から、キーに対応する値を取り出す」演算子 `!` には、「存在しないキーを指定すると例外が発生する」という問題がありました。これでは、今回の課題の「keyに対応する値が存在しない場合、`Error: no item found`という文字列を標準出力に出力」する処理が実装しにくいでしょう。

この問題を解決するためには`Maybe`という型を使います。`Maybe`型は、本課題の後半で紹介する、`Map`型の値からキーに対応する値を探す関数の、結果の型として用いられます。`Maybe`型を使うことで、例外を発生させることなく、キーに対応する値が「見つかった場合」・「見つからなかった場合」それぞれの結果を表すことができます。ここでは、その`Maybe`型をしっかり理解するために、その原型ともいえる「列挙型」と呼ばれる型を作るところから説明します。

Haskellでは、`data`宣言を使って取り得る値を複数列挙すると、列挙型ができます。例えば下記の場合、`Found`か`NotFound`という2つの値を取り得る型が作られます。

```haskell
data FoundOrNot = Found | NotFound
```

`|`で区切って、取り得る値を表す「値コンストラクター」を列挙することで、列挙した値コンストラクターの値のみを取り得る型ができます。「値コンストラクター」の名前はアルファベット大文字で始めなければならない点にご注意ください。

上の例の場合は、`Found`と`NotFound`を列挙することで、「`Found`という値か、`NotFound`という値どちらか一方の値をとる型`FoundOrNot`」ができるのです。

課題7でレコード型に対して行ったのと同様に、列挙型も`deriving`で簡単に`Show`型クラスのインスタンスにすることができます。

```haskell
data FoundOrNot = Found | NotFound deriving Show
```

早速、GHCiに上記の`FoundOrNot`の定義を入力した上で、`Found`という値コンストラクターを変数に代入してみましょう:

```haskell
ghci> f = Found
```

`FoundOrNot`型の値コンストラクターである`Found`を代入した変数`f`は、当然ながら`FoundOrNot`型の値であることが分かります:

```haskell
ghci> :t f
f :: FoundOrNot
```

そして、`FoundOrNot`型は`Show`型クラスのインスタンスなので、値を`print`関数の引数として渡すこともできます:

```haskell
ghci> print f
Found
```

課題9でリスト型に対して行ったように、`case`式を使って「どの値コンストラクターか」に応じて処理を分けることもできます。

```haskell
ghci> :{
ghci| case f of
ghci|   Found -> "Yeah, found!"
ghci|   NotFound -> "Oh, not found..."
ghci| :}
"Found!"
```

※もう一つの値コンストラクター、`NotFound`に対しても同じことが出来るはずです。試してみましょう。

しかし、このように列挙型として定義した`FoundOrNot`型には、大きな欠点があります。それは、`Found`値コンストラクターが単に「見つかった」という情報しか持っておらず、何が見つかったのか分からない、という点です。これでは、「`Map`型の値からキーに対応する値を探す関数」が値を見つけても、戻り値にその値を含めることができません。せっかく見つけたのが無駄になってしまいます！

では、`Found`値コンストラクターが、見つかった値を含められるようにするにはどうすればよいでしょうか？ひとまず話を単純にするために、`Found`値コンストラクターに整数（`Integer`型の値）を含めてみましょう。次のように書きます:

```haskell
data FoundOrNot = Found Integer | NotFound deriving Show
--                      ^^^^^^^
--               値コンストラクターのパラメーター
```

`Found`の直後にスペースを挟んで、`Found`が受け取る型（上記の場合`Integer`）を書きます。これによって、`Found`値コンストラクターは、整数を一つ受け取るように鳴りました。

早速GHCiに入力してみましょう:

```haskell
ghci> data FoundOrNot = Found Integer | NotFound deriving Show
```

新たにできた`Found`値コンストラクターの型をチェックしてみると、今度は「`Integer`を受け取って`FoundOrNot`型の値を返す」関数になったことが分かります:

```haskell
ghci> :t Found
Found :: Integer -> FoundOrNot
```

一方、何も加えていない`NotFound`は、ただの`FoundOrNot`型の値のままです:

```haskell
ghci> :t NotFound
NotFound :: FoundOrNot
```

上記の、`Found`値コンストラクターを定義したことによって`FoundOrNot`型の値を返す関数が作られたことは、課題6で次の`Entry`型を定義した際、

```haskell
data Entry =
  Entry
  { category :: String
  , price :: Integer
  }
```

次のように`Entry`という名前の関数が作られたのと、同じ仕組みによるものです:

```haskell
ghci> :t Entry
Entry :: String -> Integer -> Entry
```

`Entry`型では`String`型の`category`というフィールドと`Integer`型の`price`というフィールドを作ったことにより、`String`と`Integer`型の値を受け取って`Entry`型の値を返す値コンストラクター、`Entry`ができました。それと同様に、`FoundOrNot`型では`Integer`型の（名前のない）フィールドを作ったことにより、`Integer`型の値を受け取って`FoundOrNot`型の値を返す値コンストラクター、`Found`ができたのです。

そんなわけで、今回新たに作った`Found`値コンストラクターは、先程確認したとおり「`Integer`を受け取って`FoundOrNot`型の値を返す」関数なので、適当な整数を渡せば利用できます:

```haskell
ghci> Found 42
Found 42
```

当然、`Found`に引数を渡さなければ型エラーとなります:

```haskell
ghci> Found

<interactive>:25:1: error:
    ? No instance for (Show (Integer -> FoundOrNot))
        arising from a use of ‘print’
        (maybe you haven't applied a function to enough arguments?)
    ? In a stmt of an interactive GHCi command: print it
```

一方、`FoundOrNot`型のもう一つの値コンストラクター、`NotFound`にはフィールドを定義していないので、そんな引数はありません。誤って渡すとやはり型エラーになります:

```haskell
ghci> NotFound 42

<interactive>:13:1: error:
    ? Couldn't match expected type ‘Integer -> t’
                  with actual type ‘FoundOrNot’
    ? The function ‘NotFound’ is applied to one argument,
      but its type ‘FoundOrNot’ has none
      In the expression: NotFound 42
      In an equation for ‘it’: it = NotFound 42
    ? Relevant bindings include it :: t (bound at <interactive>:13:1)
```

`NotFound`値コンストラクターを使いたい場合は、次のように引数を渡さないようにしましょう:

```haskell
ghci> NotFound
NotFound
```

こうして作成された`FoundOrNot`型の値コンストラクター、`Found`と`NotFound`は、パターンマッチで中の値を取り出すこともできます。次のように`lifeUniverseAndEverything`という変数に`FoundOrNot`型の値を入れて、`case`式で覗いてみましょう:

```haskell
ghci> lifeUniverseAndEverything = Found 42
ghci> :{
ghci| case lifeUniverseAndEverything of
ghci|     Found theAnswer -> print theAnswer
ghci| --       ^^^^^^^^^^^
ghci| --      ここで値コンストラクターの引数を取り出す
ghci|     NotFound -> putStrLn "Unknown"
ghci| :}
42
```

上のコードでは、`lifeUniverseAndEverything`という変数の値に対してパターンマッチしています。`FoundOrNot`型には`Found`と`NotFound`という値コンストラクターがあるので、それぞれの値の場合に行う処理を書いています。

最初に注目すべきは`Found`値コンストラクターにマッチしている、

```haskell
ghci|     Found theAnswer -> print theAnswer
```

という行です。`case`式でパターンマッチングを行うと、対象の値がどのような値をとっているかで分岐するだけでなく、対象の値コンストラクターが含んでいる値を新しい変数に代入して利用できるようにしてくれます。上記の場合、`Found`値コンストラクターが持っている`Integer`型の値を`theAnswer`という変数に代入してそのまま`print`関数に渡しています。

その結果、`lifeUniverseAndEverything`は`Found 42`という値なので、前述の`case`式を評価した結果`print`関数が実行されて`42`が出力されたんですね。

一方、もう一つの、`NotFound -> putStrLn "Unknown"`という行では、`NotFound`という値コンストラクターにマッチさせていますが、`NotFound`には何も値が含まれていないため、特に変数に代入させてはいません。なのでそのまま`putStrLn "Unknown"`と実行しています（気が向いたら`lifeUniverseAndEverything`に`NotFound`を代入して先ほどの`case`式を再度試してみてください！）。

もし間違って`NotFound`から値を取り出して変数に代入しようとしても、当然エラーになります:

```haskell
ghci> :{
ghci| case lifeUniverseAndEverything of
ghci|     Found theAnswer -> print theAnswer
ghci|     NotFound theAnswerTwo -> print theAnswerTwo
ghci| :}

<interactive>:24:5: error:
    ? The constructor ‘NotFound’ should have no arguments, but has been given 1
    ? In the pattern: NotFound theAnswerTwo
      In a case alternative: NotFound theAnswerTwo -> print theAnswerTwo
      In the expression:
        case lifeUniverseAndEverything of
          Found theAnswer -> print theAnswer
          NotFound theAnswerTwo -> print theAnswerTwo
```

以上のとおり、保持するフィールドが異なる値コンストラクターを複数設定することで、場合によって異なる型の値を持った型を作ることができます。この性質を利用することで、`FoundOrNot`型のように、見つからなかった場合には`NotFound`を（引数なしで）返し、見つかった場合には`Found`を見つかった値とともに返せば、失敗した場合でも例外を起こさずに済む、という使い方ができます。

#### 型引数を追加して、`Integer`以外にも使えるようにする

前節で紹介した方法により、`FoundOrNot`型は「値が見つかった場合」を表す値コンストラクターと「値が見つからなかった場合」の値コンストラクターを定義することで、それぞれの場合を素直に扱えるようになりました。しかし、ちょっとまだ不便なところがあります。`Found`が、`Integer`型しか扱えないという点です。次のように`Found`に文字列を渡すと当然型エラーになります:

```haskell
ghci> Found "Life, the Universe and Everything"

<interactive>:39:10: error:
    ? Couldn't match expected type ‘Integer’ with actual type ‘[Char]’
    ? In the first argument of ‘Found’, namely
        ‘"Life, the Universe and Everything"’
      In the expression: Found "Life, the Universe and Everything"
      In an equation for ‘it’:
          it = Found "Life, the Universe and Everything"
```

今回の課題は「整数が見つかったかどうか」さえ扱えればよいので十分と言えば十分なのですが、それでは他の似た問題で応用が利かないですし、ちゃんと解決方法もあるので紹介します。

ズバリその解決方法とは、`FoundOrNot`型を「型引数」を持った型にすることです。次のように`FoundOrNot`型を定義し直してみてください:

```haskell
ghci> data FoundOrNot typeArgument = Found typeArgument | NotFound deriving Show
```

`data FoundOrNot`の後に`typeArgument`という単語が現れました。これが`typeArgument`という名前の型引数です。「型引数」は「型変数」のように「とある一つの型」を表す型で、普通の関数における引数のように、具体的な型を渡すことによって渡した型に置き換えられます。

`FoundOrNot`型の場合、「型引数」として渡した型は`Found`型のフィールドの型として使用しているので、`FoundOrNot`型の型引数として適当な型を渡すと、`Found`型のフィールドとして使われるようになります。

```haskell
ghci> data FoundOrNot typeArgument = Found typeArgument | NotFound deriving Show
ghci> --             ^^^^^^^^^^^^^^       ^^^^^^^^^^^^^^
ghci> --              型引数の宣言       実際に型引数を使う
```

型引数を受け取る型は、具体的な型が渡されることによって初めて、具体的な型になります。`FoundOrNot`型では`Found`値コンストラクターのフィールドの型に型引数が用いられているので、`Found`値コンストラクターに具体的な型の値を渡すと、具体的な`FoundOrNot`型の値ができあがります:

```haskell
ghci> :t Found "a sock missing another"
Found "a sock missing another" :: FoundOrNot [Char]
--                                          ^^^^^^^^
--                                         具体的な型
```

`:t`コマンドの結果の通り、`Found "a sock missing another"`という値は、`Found`に文字列を渡すことで作られているので、`FoundOrNot [Char]`という型になりました。これはつまり文字列（文字のリスト、`[Char]`型）に対する`FoundOrNot`型です。ここでは`typeArgument`という型引数は`[Char]`で置き換えられたんですね。

当然、型引数を受け取る型は、型注釈に該当の型を記述する際も、型引数として適当な型を渡す必要があります。`FoundOrNot`型に型引数を渡さなかった場合、次のようなエラーになります:

```haskell
ghci> :{
ghci| findSomething :: String -> FoundOrNot
ghci| findSomething = error "the type annotation is illegal!"
ghci| :}

<interactive>:51:28: error:
    ? Expecting one more argument to ‘FoundOrNot’
      Expected a type, but ‘FoundOrNot’ has kind ‘* -> *’
    ? In the type signature: findSomething :: String -> FoundOrNot
```

「kindエラー」という、ちょっと変わった種類の型エラーが起こります。エラーメッセージも読く読むと「`kind`」という単語が書かれてますね。「kind」というのは、「型の型」とも言うべき概念です。ひとまず当面は、当面は「型引数をいくつ受け取るか」を表すものだという理解で構いません。

具体的にどんなkindがあるのか見てみましょう。GHCiの`:k`（`:kind`の略）コマンドを使うと、指定した型がどのようなkindなのかがわかります。

最初に紹介するkindは、単なる型を表す「`*`」です。「`*`」は`Bool`（真偽値型）や`Integer`（整数型）、`Char`（文字型）、それから文字のリストである`[Char]`（文字列型）など、これまでに紹介した多くの型が該当します。

```haskell
ghci> :k Bool
Bool :: *
ghci> :k Integer
Integer :: *
ghci> :k Char
Char :: *
ghci> :k [Char]
[Char] :: *
```

上記のとおり、GHCiの`:k`コマンドを使った結果、いずれの型も「`*`」、すなわち「単なる型」として扱われていることが分かります。これらの型は、いずれもこれ以上型引数を受け取らない「単なる型」なのです。「単なる型`*`」は関数の引数や戻り値の型として使用できる唯一の型であり、次に紹介する`FoundOrNot`型のkindは、そのままでは関数の引数や戻り値の型になれません。

※注意: GHCの将来のバージョンで、`*`が`Type`という名前に置き換わる可能性があります。もしお使いのGHCiが`Bool :: Type`などと表示した場合でも慌てず、適宜読み替えてください。

ではその、型引数を追加した`FoundOrNot`型はいかがでしょうか？

```haskell
ghci> :k FoundOrNot
FoundOrNot :: * -> *
```

`* -> *`という、何やら関数のような表記のkindが表示されました。こちらは確かに関数と似ていて、「『普通の型`*`』を一つ受け取って、『普通の型 `*`』を返す型」を表します。

実際に`FoundOrNot`に普通の型`*`を型引数として渡すと、確かに普通の型`*`となることが分かります:

```haskell
ghci> :k FoundOrNot Integer
FoundOrNot Integer :: *
```

このように、`* -> *`という矢印を用いたkindは「『普通の型`*`』を一つ受け取って、『普通の型 `*`』を返す型」となっています。

ちなみに、`FoundOrNot`型については説明のために`typeArgument`という長い名前の型引数を作りましたが、実際のところ**アルファベット小文字で始まる、一文字以上の名前**であれば何でもOKです。慣習上、`a`のように、一文字のアルファベットで済ますことが多いです:

```haskell
ghci> data FoundOrNot a = Found a | NotFound deriving Show
```

### 実はすでにある: `Maybe`型

`FoundOrNot`型とそっくりな形の型は、実は標準で存在しています。その名も`Maybe`です。`:i Maybe`とGHCiに入力すれば、`Maybe`型がどのような値コンストラクターを持っているか見ることができますので、`FoundOrNot`と比較してみましょう:

```haskell
ghci> :i Maybe
type Maybe :: * -> *
data Maybe a = Nothing | Just a
        -- Defined in ‘GHC.Maybe’
instance Applicative Maybe -- Defined in ‘GHC.Base’
-- ... 省略 ...
```

※これ以降で実行するものも含め、`:i`コマンドの実行結果はGHCのバージョンによって結果が異なる場合があります。ここではGHC 9.2.5の場合です。

`Maybe`型がインスタンスとなっている型クラスの一覧なども一緒に表示されたので少し分かりづらいかも知れませんが、

```haskell
data Maybe a = Nothing | Just a
```

と書かれている行で`Maybe`型がどのような値コンストラクターを持っているか、どのような値を取り得るか示しています。`Maybe`型は`Nothing`というフィールドを持たない値コンストラクターと、`Just`という、`a`型、すなわち型引数で指定される型のフィールドを一つ持った値コンストラクターを備えていることが読み取れるでしょうか？

これを先ほど定義した`FoundOrNot`型と比べてみましょう:

```haskell
ghci> :i FoundOrNot
type FoundOrNot :: * -> *
data FoundOrNot typeArgument = Found typeArgument | NotFound
        -- Defined at <interactive>:5:1
instance [safe] Show typeArgument => Show (FoundOrNot typeArgument)
  -- Defined at <interactive>:5:71
```

肝心の`data FoundOrNot`で始まる行だけを取り出した上で、`typeArgument`という型引数は名前が長いので、`Maybe`型に揃えて`a`にしちゃいましょう。するとこのように並べられます:

```haskell
-- 比較しやすいようにイコール = の間の空白を調整しています
data Maybe      a = Nothing | Just a
data FoundOrNot a = Found a | NotFound
```

両方の型のフィールドのない値コンストラクター`Nothing`・`NotFound`と、`a`型のフィールドを持った値コンストラクター`Just`・`Found`が、それぞれお互いに対応していますね。`Maybe`型では`Nothing`が先に定義され、`FoundOrNot`型では`Just`が先に定義されているので順番こそ逆ですが、これら二つの型の値コンストラクターは全く同じように使えるようになっています。

なお、単に「全く同じように使える」だけでなく、`Maybe`型はHaskellの世界における「値がある場合とない場合を表現する型」の標準であり、世の中には`Maybe`型を前提としたコードがたくさんあります。次の節で紹介する`Map`型の新しい関数もその一つです。なのでこれ以降は`FoundOrNot`型ではなく`Maybe`型を使いましょう。

余談:

- 実は`Maybe`型において`Nothing`が先に定義されているのにはちゃんとした理由があります。詳しくはどこかで補足するかも知れません。待ちきれないならHaskell-jpのSlackで聞いてみてください
- `Maybe`型と`FoundOrNot`型のように、お互いを一切の情報を失うことなく変換できる関係を「同型」といいます。多分この先出てくることがない用語です

### `Map`型の値から、キーに対応する値を取り出す（その2）

ここでは、`Map`型の値における「指定したキーに対応する値を取り出す」もう一つの関数、`lookup`関数を紹介します。`lookup`関数は、前の節で紹介した`Maybe`型を活用することで、課題hoge(16)に登場した`!`と異なり例外が発生させることなく利用できます。

それでは、次のように`Data.Map.Strict`モジュールを`import`して`lookup`関数を試してみましょう:

```haskell
ghci> import qualified Data.Map.Strict as M
```

何事もなく`import`できたら、次は恒例の`:t`コマンドによる型の確認です:

```haskell
ghci> :t M.lookup
M.lookup :: Ord k => k -> M.Map k a -> Maybe a
```

戻り値として確かに`Maybe a`、すなわち`Maybe`型が現れました！ご覧のとおり`lookup`関数は結果に`Maybe`型を使っているので、値が存在している場合と存在していない場合両方の結果を過不足なく表現することができます。

戻り値だけでなく引数にも注目してみましょう。第一引数はキーとなる値です。`Ord k =>`と制約されている通り、キーの型は`Ord`型クラスのインスタンスである必要があります。`Map`型の値を作る`fromList`関数と同様ですね。第二引数は対象となる`Map`型の値です。キー、`Map`の順で渡すんですね。

続いて、次のように適当な`Map`型の値を作って試してみましょう:

```haskell
ghci> keyValues = M.fromList [("one", 1), ("two", 2)]
```

ここまでできたら、いよいよ実際に`lookup`関数を呼んでみましょう。`:t`コマンドで確認したとおり、キーとなる値、`Map`型の値、という順番で引数を渡してください:

```haskell
ghci> M.lookup "one" keyValues
Just 1
ghci> M.lookup "two" keyValues
Just 2
```

上記の例の通り、`"one"`や`two`といった、keyに対応する値が存在するときは、`Just`に値をくるんで返すようになっています。

一方、次のようにkeyに対応する値が存在しないときは、`Nothing`を返します。

```haskell
ghci> M.lookup "non existing" keyValues
Nothing
```

このように、`Maybe`型を活用して「keyに対応する値が存在する場合」と「key対応する値が存在しない場合」を適切に網羅することで、`lookup`関数は課題hoge(16)で紹介した`!`のように、例外を起こさないようになっています。

ただし、`lookup`関数が返すような`Maybe a`型の値は、単なる型`a`とは異なる点に注意してください。値が見つかったときに取得できた`a`型の値を実際に使いたいときは、`FoundOrNot`型の説明でも触れたように、`case`式を使って`Just`の場合と`Nothing`の場合両方を想定した処理を書く必要があります:

```haskell
ghci> :{
ghci| case M.lookup "one" keyValues of
ghci|     Just v -> show v
ghci|     Nothing -> "not found!"
ghci| :}
"1"

ghci> :{
ghci| case M.lookup "none" keyValues of
ghci|     Just v -> show v
ghci|     Nothing -> "not found!"
ghci| :}
"not found!"
```

次のように`lookup`関数で取得した値同士を足し合わせようとしても、`Maybe a`型のままでは型エラーになります:

```haskell
ghci> one = M.lookup "one" keyValues
ghci> two = M.lookup "two" keyValues
ghci> one + two

<interactive>:21:1: error:
    ? Non type-variable argument in the constraint: Num (Maybe a)
      (Use FlexibleContexts to permit this)
    ? When checking the inferred type
        it :: forall a. (Num a, Num (Maybe a)) => Maybe a
```

次のように、`one`・`two`両方に対して`case`式によるチェックを行いましょう:

```haskell
ghci> :{
ghci| case one of
ghci|     Just valOne ->
ghci|         case two of
ghci|             Just valTwo -> valOne + valTwo
ghci|             Nothing -> -99999
ghci|     Nothing -> -99999
ghci| :}
3
```

何度も`case`式を書くのが面倒くさい！と感じた方は、課題hoge(21)で以降で紹介する`do`記法を使ったテクニックまでお待ちください！

### `readMaybe`関数で、`read`関数の失敗に備える

今回の課題では、結果として`Maybe`型の値を返す関数をもう一つ扱う必要があります。具体的には次の`add`コマンドを実装する場面です。

> - 分割した結果のリストの内容が「`add`という文字列で始まる、3つの要素を持つリスト」であった場合、3つめの要素の内容に応じて、以下のいずれかの処理を行います。
>     - 2つめの要素を「keyとなる文字列」、3つめの要素を「値となる整数」として解釈し、連想配列`(A)`の、keyに対応する値として追加します。
>         - その後、`Adding <3つめの要素となる整数> to <keyとなる文字列>.`という形式の文字列を標準出力に出力します。
>     - 3つめの要素が「値となる整数」として解釈できない文字列であった場合、`Error: Invalid Command`という文字列を標準出力に出力します。

「`add`という文字列で始まる、3つの要素を持つリスト」における、3つめの要素は整数として解釈できければなりません。これまでの課題であれば`read`関数を使いたくなるところですが、`read`関数だと文字列が「整数として解釈できない文字列」であった場合に、例外が発生してプログラム**全体が終了**してしまいます。本課題ではそれは望ましいことではなく、単に「`Error: Invalid Command`という文字列を標準出力に出力」しなければなりません。

この問題を解決するには、引数の値が「整数として解釈できない文字列」であった場合を例外として扱わず、（例えば）`Maybe`型の`Nothing`にして返すことで、文字列が整数として解釈できる場合とできない場合、両方を想定した`read`関数が必要です。

それがこの節で紹介する`readMaybe`関数です。`Text.Read`モジュールを`import`することで使えるようになります:

```haskell
ghci> import Text.Read
ghci> :t readMaybe
readMaybe :: Read a => String -> Maybe a
```

いつものように`:t`コマンドで型を見てみると、確かに戻り値が`Maybe`型になっていますね。

（特にGHCi上で）使用する際は、普通の`read`関数と同様に、戻り値に型注釈を付けるのを忘れないでください:

```haskell
ghci> readMaybe "1" :: Maybe Integer
Just 1
ghci> readMaybe "not integer" :: Maybe Integer
Nothing
```

上記のように、`readMaybe`関数は（整数を返すことを期待された箇所で使うと）、整数として解釈できない文字列を受け取った場合でも、例外を起こす代わりに`Nothing`を返すようになります。安心して使えますね！

### `mapMaybe`関数で、成功した値のみのリストに変換する

今回の課題では使用しませんが、`Maybe`を使った便利な関数を一つ紹介します。`Data.Maybe`というモジュールに入った`mapMaybe`関数です。

GHCiの`:t`コマンドで型を調べると、`mapMaybe`関数は次のような型となっています:

```haskell
ghci> import Data.Maybe
ghci> :t mapMaybe
mapMaybe :: (a -> Maybe b) -> [a] -> [b]
```

とある型`a`の引数を受け取ってもう一つの型`b`を`Maybe`型で来るんで返す関数と、`a`型の値のリストを受け取り、`b`型の値のリストを関数です。どうやら課題hoge(15)で学習した`map`関数のように、第一引数として渡した関数で第二引数のリストの各要素を変換する関数のようです。

具体例で詳しく見てみましょう。引数を一つ受け取って`Maybe`型の値を返す関数として、先ほどの`readMaybe`関数を用います。`readMaybe`関数は文字列を受け取るので、第二引数のリストは文字列のリストですね:

```haskell
ghci> mapMaybe readMaybe ["12", "not a number", "34"] :: [Integer]
[12,34]
```

`["12", "not a number", "34"]`というリストが`[12, 34]`というリストに変わりました。これは、`readMaybe`関数が**`Just`に値をくるんで返した要素のみ**を含んだリストとなっています。各要素に対して個別に実行してみるとよく分かるでしょう:

```haskell
ghci> readMaybe "12" :: Maybe Integer
Just 12
ghci> readMaybe "not a number" :: Maybe Integer
Nothing
ghci> readMaybe "34" :: Maybe Integer
Just 34
```

このような特徴から`mapMaybe`関数は、「リストにおける各要素を変換する」と、「リストにおける特定の条件を満たす要素のみ抽出する」という、ありふれた操作をまとめて行うのに便利です。

```haskell
-- 10より大きい整数だけに3足す
ghci> mapMaybe (\i -> if i > 10 then Just (i + 3) else Nothing) [1, 11, 5, 20, 10]
[14,23]
```

### 発展編: 詳しいエラー情報を持つ、`Either`型

こちらも今回の課題では使用しませんが、`Maybe`型に関連とよく似た、もう一つ重要な型を紹介します。`Either`という名前の型で、文字通り「どちらか一方」の値を表現するための型です。早速定義をGHCiの`:i`コマンドで見てみましょう:

```haskell
ghci> :i Either
type Either :: * -> * -> *
data Either a b = Left a | Right b
        -- Defined in ‘Data.Either’
instance Applicative (Either e) -- Defined in ‘Data.Either’
-- ... 省略 ...
```

`Maybe`型と異なり、`Either`型は異なる2つの型引数`a`・`b`をとることによって、結果が`a`型の値だった場合`Left`と`b`型の値だった場合`Right`を、素直に表現できます。

慣習上、`Right`が成功した場合に返す値として使われ、`Left`が失敗した場合に返す値として使われます。詳細は課題hoge(22)で解説するので乞うご期待。

### 模範解答の一部 1: ループから抜けるときは何もしない、渡す引数を変えることで状態を更新する

今回の課題を、事前に筆者の知人数名に解いていただいた所、難しすぎるという声がありました。そこでこの節では、模範解答の一部を紹介することで、一緒に解いていきましょう。

今回の課題の難しさは、「受け取った文字列を命令として解釈して、命令の内容に応じて連想配列を更新し、またそれらを繰り返す」という一連の処理を、関数型プログラミングスタイルに翻訳するのが難しい、という点にあります。とりわけ「連想配列を更新し」「繰り返す」という部分が分解しづらいのではないでしょうか？

まずは、「連想配列を更新し」などの部分は無視して、受け取った文字列による命令によって、処理を繰り返したり繰り返さなかったりしてみましょう。課題hoge(11?)で紹介したとおり、処理を繰り返す際は繰り返したい関数をもう一度呼ぶ、すなわち再帰呼び出しを行う必要があります:

```haskell
import Text.Read (readMaybe)
import qualified Data.Map.Strict as M

main = do
  putStrLn "Enter command:"
  command <- getLine
  case words command of
      ["add", k, mv] -> do
        main
      ["get", k] -> do
        main
      ["quit"] -> do
        putStrLn "Bye."
        -- ここで何もしないので、繰り返さずに実行が終わる！
      _ -> do
        putStrLn "Error: Invalid Command"
        main
```

`main`関数を一行ずつ見ていきましょう。最初に
