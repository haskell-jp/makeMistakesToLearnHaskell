# 取り得る値を型で明示する・エラーを型宣言で明示する

以下のコマンドを持つ、簡単なインメモリーのデータベース（？）のプロトタイプを作りましょう。

```
add <keyとなる文字列> <整数>
get <keyとなる文字列>
quit
```

1. 「keyとなる文字列ごとに、整数を値として持つ連想配列`(A)`」を初期化します。
2. 以下の処理を繰り返し実行します。
    1. 標準入力から、文字列を1行分取得します。
    2. 受け取った行を空白で分割し、分割した結果に応じて、下記のような処理を実行します。
        - 分割した結果のリストの内容が「`add`という文字列で始まる、3つの要素を持つリスト」であった場合、3つめの要素の内容に応じて、以下のいずれかの処理を行います。
            - 2つめの要素を「keyとなる文字列」、3つめの要素を「値となる整数」として解釈し、連想配列`(A)`の、keyに対応する値として追加します。
                - その後、`Adding <3つめの要素となる整数> to <keyとなる文字列>.`という形式の文字列を標準出力に出力します。
            - 3つめの要素が「値となる整数」として解釈できない文字列であった場合、`Error: Invalid Command`という文字列を標準出力に出力します。
        - 分割した結果のリストの内容が「`get`という文字列で始まる、2つの要素を持つリスト」であった場合、以下のいずれかの処理を行います。
            - 2つめの要素を「keyとなる文字列」として解釈し、連想配列`(A)`における、keyに対応する値が存在する場合、連想配列`(A)`から、keyに対応する整数を取り出します。
                - そして、<keyとなる文字列> => <対応する整数>`という形式の文字列を標準出力に出力します。
            - 一方、keyに対応する値が存在しない場合、`Error: no item found`という文字列を標準出力に出力します。
        - 分割した結果のリストの内容が「`quit`という文字列のみを持つリスト」であった場合、繰り返しをやめ、プログラム全体を終了します。
        - それ以外の場合、`Error: Invalid Command`という文字列を標準出力に出力します。

## 必要な知識

今回の課題で習う新しい知識に加えて、これまでに習ったいろいろなことを再利用します。主なものは次のとおりです。読み飛ばしたものがあれば戻って復習しましょう:

- 再帰処理
- `Map`型の値に対する`insertWith`

### 値の種類によって、保持できる値を切り替えられる型（直和型）を作る

課題16で紹介した「`Map`型の値から、キーに対応する値を取り出す」演算子 `!` には、「存在しないキーを指定すると例外が発生する」という問題がありました。これでは、今回の課題の「keyに対応する値が存在しない場合、`Error: no item found`という文字列を標準出力に出力」する処理が実装しにくいでしょう。

この問題を解決するためには`Maybe`という型を使います。`Maybe`型は、本課題の後半で紹介する、`Map`型の値からキーに対応する値を探す関数の、結果の型として用いられます。`Maybe`型を使うことで、例外を発生させることなく、キーに対応する値が「見つかった場合」・「見つからなかった場合」それぞれの結果を表すことができます。ここでは、その`Maybe`型をしっかり理解するために、その原型ともいえる「列挙型」と呼ばれる型を作るところから説明します。

Haskellでは、`data`宣言を使って取り得る値を複数列挙すると、列挙型ができます。例えば下記の場合、`Found`か`NotFound`という2つの値を取り得る型が作られます。

```haskell
data FoundOrNot = Found | NotFound
```

`|`で区切って、取り得る値を表す「値コンストラクター」を列挙することで、列挙した値コンストラクターの値のみを取り得る型ができます。「値コンストラクター」の名前はアルファベット大文字で始めなければならない点にご注意ください。

上の例の場合は、`Found`と`NotFound`を列挙することで、「`Found`という値か、`NotFound`という値どちらか一方の値をとる型`FoundOrNot`」ができるのです。

課題7でレコード型に対して行ったのと同様に、列挙型も`deriving`で簡単に`Show`型クラスのインスタンスにすることができます。

```haskell
data FoundOrNot = Found | NotFound deriving Show
```

早速、GHCiに上記の`FoundOrNot`の定義を入力した上で、`Found`という値コンストラクターを変数に代入してみましょう:

```haskell
ghci> f = Found
```

`FoundOrNot`型の値コンストラクターである`Found`を代入した変数`f`は、当然ながら`FoundOrNot`型の値であることが分かります:

```haskell
ghci> :t f
f :: FoundOrNot
```

そして、`FoundOrNot`型は`Show`型クラスのインスタンスなので、値を`print`関数の引数として渡すこともできます:

```haskell
ghci> print f
Found
```

課題9でリスト型に対して行ったように、`case`式を使って「どの値コンストラクターか」に応じて処理を分けることもできます。

```haskell
ghci> :{
ghci| case f of
ghci|   Found -> "Yeah, found!"
ghci|   NotFound -> "Oh, not found..."
ghci| :}
"Found!"
```

※もう一つの値コンストラクター、`NotFound`に対しても同じことが出来るはずです。試してみましょう。

しかし、このように列挙型として定義した`FoundOrNot`型には、大きな欠点があります。それは、`Found`値コンストラクターが単に「見つかった」という情報しか持っておらず、何が見つかったのか分からない、という点です。これでは、「`Map`型の値からキーに対応する値を探す関数」が値を見つけても、戻り値にその値を含めることができません。せっかく見つけたのが無駄になってしまいます！

では、`Found`値コンストラクターが、見つかった値を含められるようにするにはどうすればよいでしょうか？ひとまず話を単純にするために、`Found`値コンストラクターに整数（`Integer`型の値）を含めてみましょう。次のように書きます:

```haskell
data FoundOrNot = Found Integer | NotFound deriving Show
--                      ^^^^^^^
--               値コンストラクターのパラメーター
```

`Found`の直後にスペースを挟んで、`Found`が受け取る型（上記の場合`Integer`）を書きます。これによって、`Found`値コンストラクターは、整数を一つ受け取るように鳴りました。

早速GHCiに入力してみましょう:

```haskell
ghci> data FoundOrNot = Found Integer | NotFound deriving Show
```

新たにできた`Found`値コンストラクターの型をチェックしてみると、今度は「`Integer`を受け取って`FoundOrNot`型の値を返す」関数になったことが分かります:

```haskell
ghci> :t Found
Found :: Integer -> FoundOrNot
```

一方、何も加えていない`NotFound`は、ただの`FoundOrNot`型の値のままです:

```haskell
ghci> :t NotFound
NotFound :: FoundOrNot
```

上記の、`Found`値コンストラクターを定義したことによって`FoundOrNot`型の値を返す関数が作られたことは、課題6で次の`Entry`型を定義した際、

```haskell
data Entry =
  Entry
  { category :: String
  , price :: Integer
  }
```

次のように`Entry`という名前の関数が作られたのと、同じ仕組みによるものです:

```haskell
ghci> :t Entry
Entry :: String -> Integer -> Entry
```

`Entry`型では`String`型の`category`というフィールドと`Integer`型の`price`というフィールドを作ったことにより、`String`と`Integer`型の値を受け取って`Entry`型の値を返す値コンストラクター、`Entry`ができました。それと同様に、`FoundOrNot`型では`Integer`型の（名前のない）フィールドを作ったことにより、`Integer`型の値を受け取って`FoundOrNot`型の値を返す値コンストラクター、`Found`ができたのです。

そんなわけで、今回新たに作った`Found`値コンストラクターは、先程確認したとおり「`Integer`を受け取って`FoundOrNot`型の値を返す」関数なので、適当な整数を渡せば利用できます:

```haskell
ghci> Found 42
Found 42
```

当然、`Found`に引数を渡さなければ型エラーとなります:

```haskell
ghci> Found

<interactive>:25:1: error:
    ? No instance for (Show (Integer -> FoundOrNot))
        arising from a use of ‘print’
        (maybe you haven't applied a function to enough arguments?)
    ? In a stmt of an interactive GHCi command: print it
```

一方、`FoundOrNot`型のもう一つの値コンストラクター、`NotFound`にはフィールドを定義していないので、そんな引数はありません。誤って渡すとやはり型エラーになります:

```haskell
ghci> NotFound 42

<interactive>:13:1: error:
    ? Couldn't match expected type ‘Integer -> t’
                  with actual type ‘FoundOrNot’
    ? The function ‘NotFound’ is applied to one argument,
      but its type ‘FoundOrNot’ has none
      In the expression: NotFound 42
      In an equation for ‘it’: it = NotFound 42
    ? Relevant bindings include it :: t (bound at <interactive>:13:1)
```

`NotFound`値コンストラクターを使いたい場合は、次のように引数を渡さないようにしましょう:

```haskell
ghci> NotFound
NotFound
```

こうして作成された`FoundOrNot`型の値コンストラクター、`Found`と`NotFound`は、パターンマッチで中の値を取り出すこともできます。次のように`lifeUniverseAndEverything`という変数に`FoundOrNot`型の値を入れて、`case`式で覗いてみましょう:

```haskell
ghci> lifeUniverseAndEverything = Found 42
ghci> :{
ghci| case lifeUniverseAndEverything of
ghci|     Found theAnswer -> print theAnswer
ghci| --       ^^^^^^^^^^^
ghci| --      ここで値コンストラクターの引数を取り出す
ghci|     NotFound -> putStrLn "Unknown"
ghci| :}
42
```

上のコードでは、`lifeUniverseAndEverything`という変数の値に対してパターンマッチしています。`FoundOrNot`型には`Found`と`NotFound`という値コンストラクターがあるので、それぞれの値の場合に行う処理を書いています。

最初に注目すべきは`Found`値コンストラクターにマッチしている、

```haskell
ghci|     Found theAnswer -> print theAnswer
```

という行です。`case`式でパターンマッチングを行うと、対象の値がどのような値をとっているかで分岐するだけでなく、対象の値コンストラクターが含んでいる値を新しい変数に代入して利用できるようにしてくれます。上記の場合、`Found`値コンストラクターが持っている`Integer`型の値を`theAnswer`という変数に代入してそのまま`print`関数に渡しています。

その結果、`lifeUniverseAndEverything`は`Found 42`という値なので、前述の`case`式を評価した結果`print`関数が実行されて`42`が出力されたんですね。

一方、もう一つの、`NotFound -> putStrLn "Unknown"`という行では、`NotFound`という値コンストラクターにマッチさせていますが、`NotFound`には何も値が含まれていないため、特に変数に代入させてはいません。なのでそのまま`putStrLn "Unknown"`と実行しています（気が向いたら`lifeUniverseAndEverything`に`NotFound`を代入して先ほどの`case`式を再度試してみてください！）。

もし間違って`NotFound`から値を取り出して変数に代入しようとしても、当然エラーになります:

```haskell
ghci> :{
ghci| case lifeUniverseAndEverything of
ghci|     Found theAnswer -> print theAnswer
ghci|     NotFound theAnswerTwo -> print theAnswerTwo
ghci| :}

<interactive>:24:5: error:
    ? The constructor ‘NotFound’ should have no arguments, but has been given 1
    ? In the pattern: NotFound theAnswerTwo
      In a case alternative: NotFound theAnswerTwo -> print theAnswerTwo
      In the expression:
        case lifeUniverseAndEverything of
          Found theAnswer -> print theAnswer
          NotFound theAnswerTwo -> print theAnswerTwo
```

以上のとおり、保持するフィールドが異なる値コンストラクターを複数設定することで、場合によって異なる型の値を持った型を作ることができます。この性質を利用することで、`FoundOrNot`型のように、見つからなかった場合には`NotFound`を（引数なしで）返し、見つかった場合には`Found`を見つかった値とともに返せば、失敗した場合でも例外を起こさずに済む、という使い方ができます。

#### 型引数を追加して、`Integer`以外にも使えるようにする

前節で紹介した方法により、`FoundNot`型は「値が見つかった場合」を表す値コンストラクターと「値が見つからなかった場合」の値コンストラクターを定義することで、それぞれの場合を素直に扱えるようになりました。しかし、ちょっとまだ不便なところがあります。`Found`が、`Integer`型にしか使えないのです。次のように`Found`に文字列を渡すと当然型エラーになります:

```haskell
ghci> Found "Life, the Universe and Everything"

<interactive>:39:10: error:
    ? Couldn't match expected type ‘Integer’ with actual type ‘[Char]’
    ? In the first argument of ‘Found’, namely
        ‘"Life, the Universe and Everything"’
      In the expression: Found "Life, the Universe and Everything"
      In an equation for ‘it’:
          it = Found "Life, the Universe and Everything"
```

今回の課題は「整数が見つかったかどうか」さえ扱えればよいので十分と言えば十分なのですが、それでは他の似た問題で応用が利かないですし、ちゃんと解決方法もあるので紹介します。

ズバリその解決方法は、`FoundOrNot`型を「型引数」を持った型にすることです。次のように`FoundOrNot`型を定義し直してみてください:

```haskell
ghci> data FoundOrNot typeArgument = Found typeArgument | NotFound deriving Show
```

`data FoundOrNot`の後に`typeArgument`という単語が現れました。これが`typeArgument`という名前の型引数です。「型引数」は「型変数」のように「とある一つの型」を表す型で、普通の関数における引数のように、具体的な型を渡すことによって渡した型に置き換えられます。

`FoundOrNot`型の場合、「型引数」として渡した型は`Found`型のフィールドの型として使用しているので、`FoundOrNot`型の型引数として適当な型を渡すと、`Found`型のフィールドとして使われるようになります。

```haskell
ghci> data FoundOrNot typeArgument = Found typeArgument | NotFound deriving Show
ghci> --             ^^^^^^^^^^^^^^       ^^^^^^^^^^^^^^
ghci> --              型引数の宣言       実際に型引数を使う
```

型引数を受け取る型は、具体的な型が渡されることによって初めて、具体的な型になる。

```
ghci> :t Found "a sock missing another"
Found "a sock missing another" :: FoundOrNot [Char]
--                                          ^^^^^^^^
--                                         具体的な型
```

`FoundOrNot [Char]` は`[Char]`（つまり文字列）に対する`FoundOrNot`型。

`Found`値コンストラクターの引数の型は文字列となる。

型引数に言及しない値コンストラクターでは、型引数のままになる。でも使える

```
ghci> :t NotFound
NotFound :: FoundOrNot typeArgument
ghci> print NotFound
NotFound
```

アルファベット小文字で始まっていれば何でも型引数として扱われる。  
実際にはアルファベット小文字一文字で済ますことが多い。

```
ghci> data FoundOrNot a = Found a | NotFound deriving Show
```

型引数によって具体的な型が割り当てられないと、関数の引数や戻り値として型注釈に書けない

```
ghci> :{
ghci| findSomething :: String -> FoundOrNot
ghci| findSomething = error "the type annotations is illegal!"
ghci| :}

<interactive>:51:28: error:
    ? Expecting one more argument to ‘FoundOrNot’
      Expected a type, but ‘FoundOrNot’ has kind ‘* -> *’
    ? In the type signature: findSomething :: String -> FoundOrNot
```

「kindエラー」というエラーが起こる。

kind: 「型の型」みたいなもの。当面は「型引数をいくつ受け取るか」という理解で十分。

型引数をいくつとる型かは`:k`（`:kind`の略）というGHCiのコマンドでわかる。

```
ghci> :k FoundOrNot
FoundOrNot :: * -> *
```

`*` が「普通の型」。関数の引数や戻り値になることができる型。  
`* -> *`で、「『普通の型』を一つ受け取って、『普通の型』を返す型」になる。

※余談ですがGHCの将来のバージョンで、`*`が`Type`という名前に置き換わる可能性があります。

### 実はすでにある: `Maybe`型

```
ghci> :i Maybe
data Maybe a = Nothing | Just a         -- Defined in ‘GHC.Maybe’
instance Applicative Maybe -- Defined in ‘GHC.Base’
-- ... 省略 ...
```

### `Map`型の値から、キーに対応する値を取り出す（その2）

`lookup`関数で、連想配列から例外を回避しつつ値を取り出す

```
ghci> import qualified Data.Map.Strict as M
ghci> :t M.lookup
M.lookup :: Ord k => k -> M.Map k a -> Maybe a
```

`Maybe a`を返している！

```
ghci> import qualified Data.Map.Strict as M
ghci> import           Data.Map.Strict ((!))
ghci> keyValues = M.fromList [("one", 1), ("two", 2)]
```

keyに対応する値が存在するときは、`Just`に値をくるんで返す。

```
ghci> M.lookup "one" keyValues
Just 1
ghci> M.lookup "two" keyValues
Just 2
```

keyに対応する値が存在しないときは、`Nothing`を返す。

```
ghci> M.lookup "non existing" keyValues
Nothing
```

取り出すときは、`case`式で

```
ghci> :{
ghci| case M.lookup "one" keyValues of
ghci|     Just v -> show v
ghci|     Nothing -> "not found!"
ghci| :}
"1"

ghci> :{
ghci| case M.lookup "none" keyValues of
ghci|     Just v -> show v
ghci|     Nothing -> "not found!"
ghci| :}
"not found!"
```

当然、`Nothing`であった場合は値コンストラクターのパラメーターから取り出そうとしてもできない

```
ghci> :{
ghci| case M.lookup "one" keyValues of
ghci|     Just v -> show v
ghci|     Nothing v -> show v
ghci| :}

<interactive>:35:5: error:
    ? The constructor ‘Nothing’ should have no arguments, but has been given 1
    ? In the pattern: Nothing v
      In a case alternative: Nothing v -> show v
      In the expression:
        case M.lookup "one" keyValues of
          Just v -> show v
          Nothing v -> show v
```

`Maybe a`のままでは、`a`に対する演算ができない！

```
ghci> one = M.lookup "one" keyValues
ghci> two = M.lookup "two" keyValues
ghci> one + two

<interactive>:21:1: error:
    ? Non type-variable argument in the constraint: Num (Maybe a)
      (Use FlexibleContexts to permit this)
    ? When checking the inferred type
        it :: forall a. (Num a, Num (Maybe a)) => Maybe a
```

このように、`case`式でのチェックを強制できる！

```
ghci> :{
ghci| case one of
ghci|     Just valOne ->
ghci|         case two of
ghci|             Just valTwo -> valOne + valTwo
ghci|             Nothing -> -99999
ghci|     Nothing -> -99999
ghci| :}
3
```

`case`式を書くのが面倒！というときは、敢えてこう書いてもよい

```
ghci> Just valOne = one
ghci> Just valTwo = two
ghci> valOne + valTwo
3
```

リスト型の値に対して↓のように書いてたのと同じこと。

```
ghci> first : left = [1, 2, 3]
ghci> first
1
ghci> left
[2,3]
```

当然↓は実行時エラーになるので、面倒くさいとき以外やっちゃいけない

```
ghci> Just x = Nothing
ghci> x
*** Exception: <interactive>:49:1-16: Non-exhaustive patterns in Just x
```

### `readMaybe`関数で、`read`関数の失敗に備える

```
ghci> :t read
read :: Read a => String -> a
ghci> read "1" :: Integer
1
ghci> read "not integer" :: Integer
*** Exception: Prelude.read: no parse
```

```
ghci> import Text.Read
ghci> :t readMaybe
readMaybe :: Read a => String -> Maybe a
ghci> readMaybe "1" :: Maybe Integer
Just 1
ghci> readMaybe "not integer" :: Maybe Integer
Nothing
```

### `mapMaybe`関数で、成功した値のみのリストに変換する

今回の課題では使用しませんが、いつか使います。

```
ghci> import Data.Maybe
ghci> import Text.Read

ghci> :t mapMaybe
mapMaybe :: (a -> Maybe b) -> [a] -> [b]
ghci> mapMaybe readMaybe ["12", "not a number", "34"] :: [Integer]
[12,34]
```

### 発展編: 詳しいエラー情報を持つ、`Either`型

```
ghci> :i Either
data Either a b = Left a | Right b      -- Defined in ‘Data.Either’
instance Applicative (Either e) -- Defined in ‘Data.Either’
-- ... 省略 ...
```

型引数を2つとる。1つめは`Left`という値コンストラクターの引数に使われ、2つめは`Right`という値コンストラクターの引数に使われている

慣習上、`Right`が成功した場合に返す値として使われ、`Left`が失敗した場合に返す値として使われる。

### 応用編: 実行しうるコマンドを表す型を作る

3つ以上の値コンストラクターを持つこともできるし、各値コンストラクターが2つ以上のフィールドを持っても良い。

今回の課題における、各種コマンドを表す。

```
data Command =
    Add String Integer
  | Get String
  | Quit
  deriving Show
```

ユーザーから受け取った行をこの型の値に変換する関数を作ると、コマンドを実行する処理と、入力をコマンドに変換する処理の分離がしやすくなる。

※今回の課題で必ず使わないといけないわけではない

使わない場合とそうでない場合を試して比べてみるといいかも

使う場合のヒント: パターンマッチは入れ子になった構造に対して、中身に対してもマッチできるので、利用するとすっきり書けます。
