# 入力した値の内容に応じて処理を分ける (2)

標準入力から空白で区切られた身長・体重を1行で受け取り、BMIを計算するプログラムを書きましょう。

1. プロンプトとして「`Height Weight: `」と表示します。
2. 標準入力から1行の入力を受け取ります。
3. 1行目の入力を、空白で区切った文字列のリストとして代入します。
4. 代入した文字列のリストの要素数が
    1. 「2以上」であれば、1つめの要素を身長、2つめの要素を体重が書かれた文字列として解釈して、BMIを計算し、標準出力に出力してください。
    2. 「1」であれば、下記の処理を行います。
        1. プロンプトとして「`Weight: `」と表示します。
        2. 標準入力から1行の入力を受け取ります。
        3. 最初に入力した行を身長、2行目に入力した行を体重が書かれた文字列として解釈して、BMIを計算し、標準出力に出力してください。
    3. それ以外の場合は、「`Invalid input`」という形式のメッセージを標準出力に出力してください。

## 注意事項

- バッファリングの都合により、「プロンプト」は**`putStr`はなく`putStrLn`で出力**してください。  
  さもなくばプロンプトが入力を受け取った後に出力されてしまい、混乱の原因となります。  
  ちゃんとしたバッファリングの設定はまたいつか！
- 小数点以下の値に対して、四捨五入などの丸め処理をする必要はありません。
- 浮動小数点数の丸め誤差を気にする必要もありません。

## 実行例

身長として「`2`」、体重として「`80`」を、入力した場合（身長、体重ともに1行目に入力している）:

```bash
shell> stack exec runhaskell ./assets/9.hs
Height Weight:
2 80
20.0
```

身長として「`2`」、体重として「`80`」を、入力した場合（身長と体重を別々の行に入力している）:

```bash
shell> stack exec runhaskell ./assets/9.hs
Height Weight:
2
Weight:
80
20.0
```

3つの単語を入力した場合

```bash
shell> stack exec runhaskell ./assets/9.hs
Height Weight:
2 80 4
20.0
```

何も入力しなかった場合

```
shell> stack exec runhaskell ./assets/9.hs
Height Weight:

Invalid input:
```

## 必要な知識

### 計算式

課題2でも同じ式を載せましたが、改めて一般化して掲載します。  
身長`H`m, 体重`W`kgの人のBMIは、以下の計算式で求めることができます。

```
  W  ÷ (  H  ×   H )
^^^^    ^^^^   ^^^^
体重 ÷ (身長 × 身長)
```

### いろいろなデータ構造に対するパターンマッチ

課題hogeで、タプルの個別の要素を取り出す機能として紹介したパターンマッチは、実際にはもっといろいろなデータ構造に対して使えるようになっています。  
この課題では、課題hogeで取り上げられなかったものをはじめとして、できるだけ網羅的に紹介しましょう💪

#### 復習: タプルに対するパターンマッチ

まずは課題hoge(8?)の復習です。  
下記👇のように書くことで、タプルの個別の要素を直接変数に代入することができたのでした。  
これがタプルに対するパターンマッチです。

```haskell
ghci> (x, y) = ("aa", "bb")
ghci> x
"aa"
ghci> y
"bb"
```

#### リストに対するパターンマッチ（リストの長さがわかっている場合）

実はタプルのパターンマッチにおける丸括弧`()`を角括弧`[]`に換えれば、そのままリストに対してのパターンマッチになります！  
（ただし、もちろんすべての要素の型が同じである場合に限ります。リストとタプルの違いを思い出してください）

```haskell
ghci> [x, y] = ["aa", "bb"]
ghci> x
"aa"
ghci> y
"bb"
```

タプルのパターンマッチの場合と同様に、リストの最初の要素が`x`に代入され、二つ目の要素が`y`に代入されました。実に直感的ですね。

しかし、この方法でのリストに対するパターンマッチでは、マッチさせる要素の数と、実際の要素の数が食い違っていた場合に、実行時エラーになってしまいます💥

```haskell
ghci> [x, y, z] = ["aa", "bb"]
ghci> x
"*** Exception: <interactive>:75:1-24: Irrefutable pattern failed for pattern [x, y, z]

ghci> y
"*** Exception: <interactive>:75:1-24: Irrefutable pattern failed for pattern [x, y, z]

ghci> z
"*** Exception: <interactive>:75:1-24: Irrefutable pattern failed for pattern [x, y, z]

ghci>
```

`[x, y, z] = ["aa", "bb"]`の行でパターンマッチした時点ではエラーにならず、代入したそれぞれの変数を評価しようとして初めてエラーになるので、一見パターンマッチとは無関係なエラーに見えますね😕。  
しかし`Irrefutable pattern failed for pattern [x, y, z]`というエラーメッセージのとおり、このエラーは実際のところ、パターンマッチが失敗したことを示しています（`Irrefutable`という単語が何を指しているのかは、結構難しいのでここでは割愛します）。

タプルと異なり、リストは値の数が決まっていない（型だけでは値がいくつ入っているのかわからない）ので、パターンマッチする側が`[x, y, z]`と書いて長さが3つのリストを期待しても、その通りの長さのリストが来るとは限らないのです。上記のエラーはそのような状況で発生するエラーです。

では、「リストの長さがわからない場合」や、「パターンマッチに失敗した場合に、実行時エラーを起こさない」ためにはどうすればいいのか、気になりますよね？  
前者についてはちょっと遠回りしつつ次の節から、後者についてはこの課題の後の方で紹介します。少々お待ちを。

#### リストの本当の値コンストラクター

「リストの長さがわからない場合」の対応策を説明する前に、リストの「正体」についてお話しします。

課題hoge6?で、自分のオリジナルな型を定義する際一緒に定義した、「値コンストラクター」というものを思い出してください。

```haskell
data Entry =
  Entry
  { category :: String
  , price :: Integer
  }
```

という`Entry`型の定義で言うところの、

```haskell
data Entry =
-- ↓ここから
  Entry
  { category :: String
  , price :: Integer
  }
-- ↑この部分！
```

のことです。  
この「値コンストラクター」には「定義しようとしている型の値が、どのような値を含んでいるのか」という情報が含まれているのでした。

リストにも値コンストラクターはちゃんとあります。  
ただしリストの場合、課題hoge6で定義したような、値コンストラクターが一つだけの型とは異なり、値コンストラクターが**二つ**あります。  
値コンストラクターが二つあるデータ型を使うと、二つの種類の値を表現することができます。  
これはリストが特別だというわけではなく、実際のところみなさんが定義する型も値コンストラクターを二つ以上にすることができるのですが、その方法については後の課題で説明させてください。

リストにおいては二つの種類の値コンストラクターを使い分けることで、リストが「空っぽの場合」と「（一つ以上の）要素がある場合」を表すことができます。  
それではリストの二つの値コンストラクターが一体どういうものなのか、具体的に見ていきましょう。

まずはリストが空っぽ、つまり要素が一つもない場合の値コンストラクターです。

```haskell
ghci> []
[]
```

「空っぽ」であるとおり、これまでにも出てきた、`[1, 2, 3]`などといった式から、中身をごっそり取り除いたような表記になっていますよね。  
この`[]`は、これまでに作った`Entry`などとは以下の点で異なるので、ピンと来ない方が多いのではないのでしょうか。

- 名前に記号しか含まれていない！
    - 読み上げるときには「空リスト」とか「ニル（nil）」と呼びましょう
- フィールドを一つも持っていない。つまり、中に値を一つも持っていない！
    - リストが保持する値は、この後紹介する「リストに要素が入っている場合のコンストラクター」が持っています。  
      `[]`はあくまでも「値が一つもない場合」の値コンストラクターなので、フィールドを持つ必要がありません。

しかし、それでも`[]`はHaskellの仕様上立派な値コンストラクターです。  
多少違和感を感じるかも知れませんが、使うことで慣れていっていただけると🙏！

続いて、リストに要素が入っている場合の値コンストラクターです。  
ちょっと見慣れない形になっているので、注意してご覧ください。

例えば`[1, 2, 3]`というリストを、リストの**本物の**値コンストラクターで表すと、次のように表されます。

```haskell
1 : 2 : 3 : []
```

なんだこれは？始めと終わりにあった開き角括弧`[`と閉じ角括弧`]`や、区切り文字であったカンマ`,`は姿を消し、代わりにコロン`:`で区切られました。末尾には空のリスト`[]`が付いているようです。

果たしてこれは本当にリストなのでしょうか？GHCiに入力してみましょう:

```haskell
ghci> 1 : 2 : 3 : []
[1,2,3]
```

おお、確かにGHCiは`1 : 2 : 3 : []`を`[1,2,3]`というリストのことだと認識したみたいです！  
下記の通り比較演算子`==`で比較してみても、やっぱり同じ値だという結果`True`が返ります:

```haskell
ghci> 1 : 2 : 3 : [] == [1, 2, 3]
True
```

続けて長さ2、1、のリストも続けてコロン`:`を使って作ってみましょう。類推できるかな？

長さ2のリストではこうで:


```haskell
ghci> 2 : 3 : []
[2,3]
```

長さ1のリストではこうです:

```haskell
ghci> 3 : []
[3]
```

やはり、要素と区切り文字であるコロン`:`を取り除くと要素が一つ減るみたいですね。  
最終的にすべての要素がなくなると、おなじみの空リスト`[]`が顔を出すわけです。

この記法を一般化すると、次の通りです:


```haskell
値 : 残りの要素を含むリスト
```

シンプルですね。  
`[1]`や`[1, 2]`も、本当は`1 : []`や`1 : 2 : []`の糖衣構文でしかありません。

このように、`:` は**リストの先頭の要素と、残りのリストを含む値コンストラクター**となっています。  
`[]`と同様こちらも名前が記号しかないので分かりづらいですが、`:`も立派な値コンストラクターなのです（ちなみに読み上げるときは「コンス（Cons）」という変な名前で読んでください）。

そして、リストはこの`:`と、先ほど紹介した「空っぽのリスト」を表す`[]`という二つの値コンストラクターを使い分けることで、「空っぽの場合」と「（一つ以上の）要素がある場合」の二つの場合を表すことができるのです。

ここまでの話をまとめます:

- リストの「本当の値コンストラクター」には、「空っぽの場合」と「（一つ以上の）要素がある場合」の二つがある:
    - 「空っぽの場合」の値コンストラクターは`[]`という記号で表され、フィールドを一つも持たない。
    - 「（一つ以上の）要素がある場合」の値コンストラクターは`:`という記号で表され、
        - 左辺のフィールドに、リストの先頭の要素を持ち、
        - 右辺のフィールドに、残りのリストを持つ。

次の節では、リストの値コンストラクター`:`を使って、「リストの長さがわからない場合」にパターンマッチする方法を覚えましょう。

#### リストに対するパターンマッチ（リストの長さがわからない場合）

前節で紹介したリストの値コンストラクター、`:`を使えば、左辺における「リストの先頭の要素」と、右辺における「残りのリスト」に対してパターンマッチできます:

```haskell
ghci> x : xs = [1, 2, 3]
ghci> x
1
ghci> xs
[2,3]
```

左辺に書いた`x`には`[1, 2, 3]`の先頭の要素である`1`が、右辺に書いた`xs`には`[1, 2, 3]`から`1`を取り除いた`[2, 3]`が代入されましたね！

`[x, y, z] = ...`などと書いてパターンマッチしていた時と異なり、`:`を使ったパターンマッチはリストの長さに寄らずにパターンマッチできます:

```haskell
ghci> x : xs = [9, 8, 7, 6, 5, 4, 3, 2, 1]
ghci> x
9
ghci> xs
[8,7,6,5,4,3,2,1]

ghci> x : xs = [100, 200]
ghci> x
100
ghci> xs
[200]

ghci> x : xs = [5]
ghci> x
5
ghci> xs
[]
```

しかし、残念ながら`:`を使ってもうまく扱えないケースがあります:

```haskell
ghci> x : xs = []
ghci> x
*** Exception: <interactive>:57:1-11: Irrefutable pattern failed for pattern x : xs

ghci> xs
*** Exception: <interactive>:57:1-11: Irrefutable pattern failed for pattern x : xs
```

そう、パターンマッチするリストが空だった場合ですね。  
`:`はあくまでも「（一つ以上の）要素がある場合」を表す値コンストラクターなので、要素が一つもない場合、つまり空のリストの場合にはパターンマッチに失敗し、実行時エラーが発生してしまいます。  
リストはその定義上「（一つ以上の）要素がある場合」と「空っぽの場合」の値コンストラクターを使い分けることで作られるデータ構造なので、これらの「場合」に応じて違うパターンにマッチさせなければ、この実行時エラーを回避することができません。  
そこで登場するのが次の節で紹介する`case`式なのです！

### `case`式で場合分けされたパターンマッチをする

`case`式は、名前のとおり、式の値がどの値コンストラクターであるかによって「場合分け」するときに使用する構文です。

例えば、`list`という変数に入ったリストが空っぽの場合の値コンストラクター`[]`であるか、あるいは一つ以上の要素を持っている場合の値コンストラクター`:`であるかで処理を変えたい場合は、次のように書きます。

```haskell
case list of
    [] -> putStrLn "list is Empty!"
    x : xs -> putStrLn "list is not empty!"
```

ちょっと複雑なので1行ずつ解説しましょう。  
`case list of`という行で、どの値コンストラクターであるか「チェックしたい式」を書きます。上記の場合、`list`という変数ですね。

続いて、2行目の`[] -> putStrLn "list is Empty!"`という行では、「チェックしたい式」が空のリスト`[]`である場合に評価したい式を書きましょう。上記の場合、`putStrLn "list is Empty!"`の実行です。  
そして3行目の`x : xs -> putStrLn "list is not empty!"`ではそう、「チェックしたい式」が空のリストでない、`:`である場合に評価する式を書きます。上記の場合は`putStrLn "list is not empty!"`です。
詰まるところ右向きの矢印`->`の左側にはマッチさせたい値コンストラクターを、`->`の右側にはマッチした場合に計算したい式を書くのです。

早速GHCiでも試してみましょう。GHCiで試す場合、`data`宣言でレコード型を定義したときなどと同様に、複数行の式を入力するときに使う`:{`と`:}`を使うのをお忘れなく:

```haskell
ghci> possiblyEmpty = []
ghci> :{
ghci| case possiblyEmpty of
ghci|   [] -> putStrLn "Empty!"
ghci|   x : xs -> putStrLn "list is not empty!"
ghci| :}
Empty!
```

👆ではマッチさせたい式、すなわち`possiblyEmpty`が空のリスト`[]`であったため、`[] -> putStrLn "Empty!"`の行が実行されました。

`possiblyEmpty`を空じゃないリストに変えると、`x : xs -> putStrLn "list is not empty!"`の行を実行することができます:

```haskell
ghci> possiblyEmpty = [1, 2, 3]
ghci> :{
ghci| case possiblyEmpty of
ghci|   [] -> putStrLn "Empty!"
ghci|   x : xs -> putStrLn "list is not empty!"
ghci| :}
list is not empty!
```

ここまでの`case`式の例はすべてリストの「本当の値コンストラクター」、すなわち空っぽの場合を表す`[]`と、一つ以上の要素を持つ`:`を使ったパターンマッチでしたが、「リストに対するパターンマッチ（リストの長さがわかっている場合）」の節で紹介したパターンマッチももちろん`case`式で使えます:

```haskell
ghci> xs = [1, 2, 3]
ghci> :{
ghci| case xs of
ghci|   [first, second, third] -> putStrLn "Three elements!"
ghci|   [first, second] -> putStrLn "Two elements!"
ghci|   [first] -> putStrLn "Only one element!"
ghci|   [] -> putStrLn "Empty!"
ghci| :}
Three elements!
```

この場合はリストの長さがそれぞれ3の場合、2の場合、1の場合と0の場合のみマッチする`case`式なので、リストの長さが4以上の場合は実行時エラーとなってしまいます。ご注意ください。

```haskell
ghci> xs = [1, 2, 3, 4]
ghci> :{
ghci| case xs of
ghci|   [first, second, third] -> putStrLn "Three elements!"
ghci|   [first, second] -> putStrLn "Two elements!"
ghci|   [first] -> putStrLn "Only one element!"
ghci|   [] -> putStrLn "Empty!"
ghci| :}
*** Exception: <interactive>:(6,1)-(10,25): Non-exhaustive patterns in case
```

このような実行時エラーは、先ほど紹介した`x : xs`と`[]`の二つの場合によるパターンマッチであれば、起きることがありません。リストは定義上、`先頭の要素 : 残りの要素が入ったリスト`の場合と、`[]`の場合のみを取り得るので、どのようなリストに対しても、漏れなくマッチできるのです。

また、具体的な値コンストラクターを明示しないで、あらゆるパターンにマッチさせる「ワイルドカード」パターンもあります:

```haskell
ghci> xs = [1]
ghci> :{
ghci| case xs of
ghci|   [first, second, third] -> putStrLn "Three elements!"
ghci|   [first, second] -> putStrLn "Two elements!"
ghci|   [] -> putStrLn "Empty!"
ghci|   o -> putStrLn "Other!"
ghci| :}
Other!
```

`o -> putStrLn "Other!"`という行に書いた`o`がそれです。`->`の左側には`o`というどの値コンストラクターにも一致しない、単なる変数が書かれているので、`o`は「ワイルドカード」パターンと見なされます。`xs`が`o`以前に書いた3つのパターンいずれにもマッチしなかった場合に、どんなリストであろうとマッチしてくれます。`if`式における`else`とちょっと似てますね。

さて、先ほど`o -> putStrLn "Other!"`という行に書いた`o`が変数であることに触れました。ここまで例を示しませんでしたが、実は`case`式における`->`の左側など、パターンマッチの際書いたアルファベット小文字始まりの名前は、`->`の右側で変数として参照できます。

例えば直前の例における、`o -> putStrLn "Other!"`の行を修正して、「Other!」の中身が具体的になんであったのか確かめてみましょう。  
おなじみの`show`関数で文字列に変換して、`++`で結合させてみてください:

```haskell
ghci> xs = [1]
ghci> :{
ghci| case xs of
ghci|   [first, second, third] -> putStrLn "Three elements!"
ghci|   [first, second] -> putStrLn "Two elements!"
ghci|   [] -> putStrLn "Empty!"
ghci|   o -> putStrLn ("Other! " ++ show o)
ghci| :}
Other! [1]
```

`Other!`の直後に変数`o`の中身 --- すなわち`case xs of`のパターンマッチでマッチしたリスト全体が表示されましたね！  
この場合`xs`と全く同じなので直接`xs`に言及しても結果は変わりませんが、`first`や`second`、`third`を使えば、名前のとおり1番目・2番目・3番目の要素を参照できます！

```haskell
ghci> xs = [1]
ghci> :{
ghci| case xs of
ghci|   [first, second, third] -> putStrLn "Three elements!"
ghci|   [first, second] -> putStrLn "Two elements!"
ghci|   [] -> putStrLn "Empty!"
ghci|   o -> putStrLn ("Other! " ++ show o)
ghci| :}
```

`case`式では値コンストラクターの「場合」によって実行する処理を分けるだけでなく、パターンマッチすることで該当する「場合」を構成する値（この場合、リストの1番目や2番目にある値）を取り出すこともできるんですね！

と、いうわけで要素の数が2だった場合に、一つ目の要素と二つ目の要素を`show`関数で表示させてみましょう:

```haskell
ghci> xs = [4, 5]
ghci> :{
ghci| case xs of
ghci|   [first, second] -> putStrLn ("first: " ++ show first ++ ", second: " ++ show second)
ghci|   [] -> putStrLn "Empty!"
ghci|   o -> putStrLn ("Other! " ++ show o)
ghci| :}
first: 4, second: 5
```

この機能は、リストの「本当の値コンストラクター 」である`:`でももちろん使用できます。例えば下記のように書くことで、長さが1以上ある任意のリストにおける、先頭の要素を取り出せます:

```haskell
ghci> xs = ["a"]
ghci> :{
ghci| case xs of
ghci|   x : xs -> putStrLn ("Head: " ++ x)
ghci|   other -> putStrLn "Other! "
ghci| :}
Head: a
```

なお、ここまでに例示した`case`式の大半には、実はやや好ましくない部分があります。GHCで`unused-matches`という警告を有効にすると、その問題について教えてくれます。次のように入力して、GHCiで有効にしてみましょう:

```haskell
ghci> :set -Wunused-matches
```

その上で、一つ前の例を再度入力します[^shadowing]:

[^shadowing]: このコードブロックには本当は問題がもう一つありますが、ここでは割愛します。あくまでもアンダースコアを使った構文を紹介したいだけなので。

```haskell
ghci> xs = ["a"]
ghci> :{
ghci| case xs of
ghci|   x : xs -> putStrLn ("Head: " ++ x)
ghci|   other -> putStrLn "Other! "
ghci| :}

<interactive>:11:7: warning: [-Wunused-matches]
    Defined but not used: ‘xs’

<interactive>:12:3: warning: [-Wunused-matches]
    Defined but not used: ‘other’
Head: a
```

入力した`putStrLn`による出力`Head: a`が表示される前に、二つの警告が表示されました。`Defined but not used: <変数名>`とあるとおり、どちらも`<変数名>`の変数を利用していないことを示しています。確かに、`x : xs -> putStrLn ("Head: " ++ x)`の行でも`other -> putStrLn "Other! "`の行でも、`xs`や`other`は`->`の右側で使用されていませんね。

さて、一体これの何が問題なのでしょう？このように小さなコードではあまりありがたくないし、コードを書いている途中の段階では、未完成の箇所があるので参照していない変数があるのは普通のことかも知れません。しかし、あなたが「もうこのコードは完成してる！」と思った段階で参照していない変数があると、例えば次のようなミスを犯してしまっている可能性があります:

##### (1) 実はまだ書いていない処理があった（未完成だった）

あなたがまだ実装を思いついていないから未完成なのか、それともうっかり実装し忘れたから未完成なのか、GHCが見分けるすべはありません。

##### (2) 変数名をタイポしたために、意図しない変数を参照していた

例えば次のような場合を想像してください:

```haskell
ghci> xs = ["a"]
ghci> c = "This is the wrong value"
ghci> :{
ghci| case xs of
ghci|   -- 「x」と打つつもりが、隣の「c」を打ってしまった！
ghci|   x : xs -> putStrLn ("Head: " ++ c)
ghci|   --                             ^^^
ghci|   other -> putStrLn "Other! "
ghci| :}
Head: This is the wrong value
```

少し極端な例ですが、変数名をタイポした場合、「変数が見つからない」というエラーにもならず、このような思わぬ失敗を招くことがあります。

これらのようなミスを防ぐためにも、「使っていない変数」というのは極力なくした方がいいでしょう。しかし`x : xs -> putStrLn ("Head: " ++ x)`のケースのように、「パターンマッチはするけど、すべての変数を使いたいわけじゃない（使いたいのは`x`だけ）」というような場合はしばしばあります。そのようなときは、マッチさせる変数名をアンダースコアで始まる名前に変更しましょう:

```haskell
ghci> xs = []
ghci> :{
ghci| case xs of
ghci|   x : _xs -> putStrLn ("Head: " ++ x)
ghci|   _other -> putStrLn "Other! "
ghci| :}
Other!
```

今度は警告が出力されませんでした。アンダースコアで始まる名前に変更することで、「この変数はワザと使用していないんです！」という意思表示をすることになります。だから使用してなくても警告されないんですね。


```haskell
ghci> xs = [1]
ghci> :{
ghci| case xs of
ghci|   [_, _, _] -> putStrLn "Three elements!"
ghci|   [_, _] -> putStrLn "Two elements!"
ghci|   o -> putStrLn ("Other! " ++ show o)
ghci| :}
Other! [1]
```

#### `case`式の中でも`do`記法を使う

`case`式における`->`の後には、Haskellの任意の式を書くことができます。これは、`do`記法でつなげた「命令」も例外ではありません。例えば下記のコードでは、`strings`というリストに対して、`strings`が空でなかった場合に最初の要素と残りのリストを表示する処理を、`do`記法で書いています:

```haskell
ghci> strings = ["a", "b", "c"]
ghci> :{
ghci| case strings of
ghci|   x : xs -> do
ghci|     putStrLn ("The first element is: " ++ x ++ ".")
ghci|     putStrLn ("The rest elements are: " ++ show xs ++ ".")
ghci|   [] -> putStrLn "Empty!"
ghci| :}
The first element is: a.
The rest elements are: ["b","c"].
```

もちろん、`do`記法はどの`->`の後に書いてもよいので、参考までにもう一つ例を挙げましょう。以下は`numbers`というリストの要素数が2だった場合にそれぞれの要素を足し算し、それ以外の場合は`Sorry`と謝りつつどんなリストだったか教えてくれるコードです:

```
ghci> numbers = [1, 2, 3]
ghci> :{
ghci| case numbers of
ghci|   [n1, n2] -> do
ghci|     let answer = n1 + n2
ghci|     putStrLn ("The answer is: " ++ show answer)
ghci|   other -> do
ghci|     putStrLn "Sorry, I don't know how to sum them up!"
ghci|     putStrLn ("Your input is: " ++ show other)
ghci| :}
Sorry, I don't know how to sum them up!
Your input is: [1,2,3]
```

### `words`関数で空白文字で区切られた文字列を分割する

`words`関数は、本課題を解く際標準入力から受け取った1行の文字列を、空白文字で区切るのに使用します:

```haskell
ghci> words "a b c"
["a","b","c"]
```

👆のようにスペース一つで文字列を分割するのはもちろんのこと、

```haskell
ghci> words "a   b                 c"
["a","b","c"]
```

👆のとおり、スペースが一つ以上連続していればいくつあろうと無視して分割できます。

```haskell
ghci> words "          "
[]
ghci> words ""
[]
```

それから、👆のように空白文字しかない文字列を受け取ると空のリストを返します。

```haskell
ghci> words "a                  "
["a"]
ghci> words "          a"
["a"]
ghci> words "    a  "
["a"]
```

👆のとおり最初の要素の前後にある空白文字は無視するのもポイントです。

```haskell
ghci> words "          a\nbc\nd"
["a","bc","d"]
```

最後に、👆のように改行文字など単なるスペース以外の空白文字も分割対象となるので注意してください（今回の課題ではあまり気にする必要はありませんが）。

### おまけ: もっといろいろなデータ構造に対するパターンマッチ

ここからは、これまでに紹介した、リストやタプル以外の型の値に対するパターンマッチの方法を紹介します。多くの構文はよく使うものですが、例によって今回の課題を解くために必須な知識ではないので、 面倒くさいという方は課題を解きましょう。

#### レコードに対するパターンマッチ 1

課題hogeで紹介したレコード型も、他の型と同じようにパターンマッチして、値の一部を取り出すことができます。例を見ながら学びましょう。

まずはおなじみ`Entry`型を再び定義します:

```haskell
ghci> :{
ghci| data Entry =
ghci|   Entry
ghci|   { category :: String
ghci|   , price :: Integer
ghci|   } deriving Show
ghci| :}
```

パターンマッチする値も作ります:

```haskell
ghci> entry1 = Entry "book" 2980
```

リストやタプルに対してパターンマッチする際は、例えば下記のようにリストやタプルの値コンストラクターを`=`の左辺で使って、値を代入したい箇所を変数で置き換えるという書き方をしました:

```haskell
[x, y] = [1, 2]
(a, b) = (True, "a")
first : left = 1 : [2, 3]
```

レコード型の値に対するパターンマッチもこれと全く同じです。`Entry "book" 2980`という式で組み立てたのと同様のことを、`=`の左辺で行えばいいのです:

```haskell
ghci> Entry cat pri = entry1
ghci> cat
"book"
ghci> pri
2980
```

はい、`Entry <categoryを代入する変数> <priceを代入する変数> = ...`という構文で、それぞれの変数に`Entry`型の値を代入することができました。このようにして、レコード型の値もパターンマッチして各フィールドの値を直接変数に代入することができます。

#### レコードに対するパターンマッチ 2

課題hogeのおまけで紹介した「レコードラベルと値コンストラクターを使ってレコード型の値を作成する」方法は、パターンマッチでも使えます。`Entry`型のようにレコードラベルの数が少ない型であればあまり役に立たないですが、レコードラベルの数がたくさんあると役に立つ、というやつでした。

早速例を示しましょう。次のように`Entry`値コンストラクターで作成した`entry2`は、

```haskell
ghci> entry2 = Entry { category = "glass", price = 12980 }
```

👇のように書くことで、各レコードラベルの値を指定した変数に代入することができます:

```haskell
ghci> Entry { category = cat, price = pri } = entry2
ghci> cat
"glass"
ghci> pri
12980
```

👆の例では`entry2`における`category`の値を`cat`という変数に、`price`の値を`pri`という変数に代入することができました。`{ category = cat, price = pri }`と書いたことから分かるとおり、変数に代入する処理であるにもかかわらず、代入する変数の名前を`=`の右辺に書いていることに注意してください。どうしてこのような構文になっているのかは分かりませんが、いずれにしても、このレコードラベルを明記しながらパターンマッチする構文においてだけは、レコードラベルの`=`の右側に変数名を書く点を覚えておきましょう。

#### 組み合わせたパターンマッチ

これまでに説明したパターンマッチの構文を組み合わせると、入れ子になった値に対して一部だけマッチする、なんてことができます。ただし、一般に、何重にも入れ子になった値を直接操作するコードは、データ構造の変更に弱くなりがちですし、頻繁に使うものではないのでここでは例を示すだけに留めます。

こちらがその例で使用するデータ型です。いつもの`Entry`型の値をリストとしてもち、`dateYMD`というレコードラベルでそれらに関連する日付を年・月・日で構成されたタプルとして保持しています:

```haskell
ghci> :{
ghci| data DatedEntries =
ghci|   DatedEntries
ghci|   { entries :: [Entry]
ghci|   , dateYMD :: (Integer, Integer, Integer)
ghci|   } deriving Show
ghci| :}
```

そしてこれが、その`DatedEntries`を使った入れ子の値に対するパターンマッチの例です:

```haskell
ghci> todayEntries = DatedEntries [entry1, entry2] (2019, 2, 27)
ghci> DatedEntries [firstEntry, lastEntry] (y, m, d) = todayEntries

ghci> entry1
Entry {category = "book", price = 2980}
ghci> firstEntry
Entry {category = "book", price = 2980}

ghci> entry2
Entry {category = "glass", price = 12980}
ghci> lastEntry
Entry {category = "glass", price = 12980}

ghci> y
2019
ghci> m
2
ghci> d
27
```

ここでは二重に入れ子になった構造のみパターンマッチしていますが、理屈の上ではいくらでも複雑な構造に対してパターンマッチできます。が、くれぐれもやり過ぎないように気をつけましょう⚠️。
