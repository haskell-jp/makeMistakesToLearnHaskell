# 入力した値の内容に応じて処理を分ける (2)

標準入力から空白で区切られた身長・体重を1行で受け取り、BMIを計算するプログラムを書きましょう。

1. プロンプトとして「`Height Weight: `」と表示します。
2. 標準入力から1行の入力を受け取ります。
3. 1行目の入力を、空白で区切った文字列のリストとして代入します。
4. 代入した文字列のリストの要素数が
    1. 「2以上」であれば、1つめの要素を身長、2つめの要素を体重が書かれた文字列として解釈して、BMIを計算し、標準出力に出力してください。
    2. 「1」であれば、下記の処理を行います。
        1. プロンプトとして「`Weight: `」と表示します。
        2. 標準入力から1行の入力を受け取ります。
        3. 最初に入力した行を身長、2行目に入力した行を体重が書かれた文字列として解釈して、BMIを計算し、標準出力に出力してください。
    3. それ以外の場合は、「`Invalid input`」という形式のメッセージを標準出力に出力してください。

## 注意事項

- バッファリングの都合により、「プロンプト」は**`putStr`はなく`putStrLn`で出力**してください。  
  さもなくばプロンプトが入力を受け取った後に出力されてしまい、混乱の原因となります。  
  ちゃんとしたバッファリングの設定はまたいつか！
- 小数点以下の値に対して、四捨五入などの丸め処理をする必要はありません。
- 浮動小数点数の丸め誤差を気にする必要もありません。

## 実行例

身長として「`2`」、体重として「`80`」を、入力した場合（身長、体重ともに1行目に入力している）:

```bash
shell> stack exec runhaskell ./assets/9.hs
Height Weight:
2 80
20.0
```

身長として「`2`」、体重として「`80`」を、入力した場合（身長と体重を別々の行に入力している）:

```bash
shell> stack exec runhaskell ./assets/9.hs
Height Weight:
2
Weight:
80
20.0
```

3つの単語を入力した場合

```bash
shell> stack exec runhaskell ./assets/9.hs
Height Weight:
2 80 4
20.0
```

何も入力しなかった場合

```
shell> stack exec runhaskell ./assets/9.hs
Height Weight:

Invalid input:
```

## 必要な知識

### 計算式

課題2でも同じ式を載せましたが、改めて一般化して掲載します。  
身長`H`m, 体重`W`kgの人のBMIは、以下の計算式で求めることができます。

```
  W  ÷ (  H  ×   H )
^^^^    ^^^^   ^^^^
体重 ÷ (身長 × 身長)
```

### いろいろなデータ構造に対するパターンマッチ

課題hogeで、タプルの個別の要素を取り出す機能として紹介したパターンマッチは、実際にはもっといろいろなデータ構造に対して使えるようになっています。  
この節では、課題hogeで取り上げられなかったものをはじめとして、できるだけ網羅的に紹介しましょう💪

#### 復習: タプルに対するパターンマッチ

まずは課題hogeの復習です。  
下記👇のように書くことで、タプルの個別の要素を直接変数に代入することができたのでした。  
これがタプルに対するパターンマッチです。

```haskell
ghci> (x, y) = ("aa", "bb")
ghci> x
"aa"
ghci> y
"bb"
```

#### リストに対するパターンマッチ（リストの長さがわかっている場合）

実はタプルのパターンマッチにおける丸括弧`()`を角括弧`[]`に換えれば、そのままリストに対してのパターンマッチになります！  
（ただし、もちろんすべての要素の型が同じである場合に限ります。リストとタプルの違いを思い出してください）

```haskell
ghci> [x, y] = ["aa", "bb"]
ghci> x
"aa"
ghci> y
"bb"
```

タプルのパターンマッチの場合と同様に、リストの最初の要素が`x`に代入され、二つ目の要素が`y`に代入されました。実に直感的ですね。

しかし、この方法でのリストに対するパターンマッチでは、マッチさせる要素の数と、実際の要素の数が食い違っていた場合に、実行時エラーになってしまいます💥

```haskell
ghci> [x, y, z] = ["aa", "bb"]
ghci> x
"*** Exception: <interactive>:75:1-24: Irrefutable pattern failed for pattern [x, y, z]

ghci> y
"*** Exception: <interactive>:75:1-24: Irrefutable pattern failed for pattern [x, y, z]

ghci> z
"*** Exception: <interactive>:75:1-24: Irrefutable pattern failed for pattern [x, y, z]

ghci>
```

`[x, y, z] = ["aa", "bb"]`の行でパターンマッチした時点ではエラーにならず、代入したそれぞれの変数を評価しようとして初めてエラーになるので、一見パターンマッチとは無関係なエラーに見えますね😕。  
しかし`Irrefutable pattern failed for pattern [x, y, z]`というエラーメッセージのとおり、このエラーは実際のところ、パターンマッチが失敗したことを示しています（`Irrefutable`という単語が何を指しているのかは、結構難しいのでここでは割愛します）。

タプルと異なり、リストは値の数が決まっていない（型だけでは値がいくつ入っているのかわからない）ので、パターンマッチする側が`[x, y, z]`と書いて長さが3つのリストを期待しても、その通りの長さのリストが来るとは限らないのです。上記のエラーはそのような状況で発生するエラーです。

では、「リストの長さがわからない場合」や、「パターンマッチに失敗した場合に、実行時エラーを起こさない」ためにはどうすればいいのか、気になりますよね？  
前者についてはちょっと遠回りしつつ次の節から、後者についてはこの課題の後の方で紹介します。少々お待ちを。

#### リストの本当の値コンストラクター

「リストの長さがわからない場合」の対応策を説明する前に、リストの「正体」についてお話しします。

課題hoge6?で、自分のオリジナルな型を定義する際一緒に定義した、「値コンストラクター」というものを思い出してください。

```haskell
data Entry =
  Entry
  { category :: String
  , price :: Integer
  }
```

という`Entry`型の定義で言うところの、

```haskell
data Entry =
-- ↓ここから
  Entry
  { category :: String
  , price :: Integer
  }
-- ↑この部分！
```

のことです。  
この「値コンストラクター」には「定義しようとしている型の値が、どのような値を含んでいるのか」という情報が含まれているのでした。

リストにも値コンストラクターはちゃんとあります。  
ただしリストの場合、課題hoge6で定義したような、値コンストラクターが一つだけの型とは異なり、値コンストラクターが**二つ**あります。  
値コンストラクターが二つあるデータ型を使うと、二つの種類の値を表現することができます。  
これはリストが特別だというわけではなく、実際のところみなさんが定義する型も値コンストラクターを二つ以上にすることができるのですが、その方法については後の課題で説明させてください。

リストにおいては二つの種類の値コンストラクターを使い分けることで、リストが「空っぽの場合」と「（一つ以上の）要素がある場合」を表すことができます。  
それではリストの二つの値コンストラクターが一体どういうものなのか、具体的に見ていきましょう。

まずはリストが空っぽ、つまり要素が一つもない場合の値コンストラクターです。

```haskell
ghci> []
[]
```

「空っぽ」であるとおり、これまでにも出てきた、`[1, 2, 3]`などといった式から、中身をごっそり取り除いたような表記になっていますよね。  
この`[]`は、これまでに作った`Entry`などとは以下の点で異なるので、ピンと来ない方が多いのではないのでしょうか。

- 名前に記号しか含まれていない！
    - 読み上げるときには「空リスト」とか「ニル（nil）」と呼びましょう
- フィールドを一つも持っていない。つまり、中に値を一つも持っていない！
    - リストが保持する値は、この後紹介する「リストに要素が入っている場合のコンストラクター」が持っています。  
      `[]`はあくまでも「値が一つもない場合」の値コンストラクターなので、フィールドを持つ必要がありません。

しかし、それでも`[]`はHaskellの仕様上立派な値コンストラクターです。  
多少違和感を感じるかも知れませんが、使うことで慣れていっていただけると🙏！

続いて、リストに要素が入っている場合の値コンストラクターです。  
ちょっと見慣れない形になっているので、注意してご覧ください。

例えば`[1, 2, 3]`というリストを、リストの**本物の**値コンストラクターで表すと、次のように表されます。

```haskell
1 : 2 : 3 : []
```

なんだこれは？始めと終わりにあった開き角括弧`[`と閉じ角括弧`]`や、区切り文字であったカンマ`,`は姿を消し、代わりにコロン`:`で区切られました。末尾には空のリスト`[]`が付いているようです。

果たしてこれは本当にリストなのでしょうか？GHCiに入力してみましょう:

```haskell
ghci> 1 : 2 : 3 : []
[1,2,3]
```

おお、確かにGHCiは`1 : 2 : 3 : []`を`[1,2,3]`というリストのことだと認識したみたいです！  
下記の通り比較演算子`==`で比較してみても、やっぱり同じ値だという結果`True`が返ります:

```haskell
ghci> 1 : 2 : 3 : [] == [1, 2, 3]
True
```

続けて長さ2、1、のリストも続けてコロン`:`を使って作ってみましょう。類推できるかな？

長さ2のリストではこうで:


```haskell
ghci> 2 : 3 : []
[2,3]
```

長さ1のリストではこうです:

```haskell
ghci> 3 : []
[3]
```

やはり、要素と区切り文字であるコロン`:`を取り除くと要素が一つ減るみたいですね。  
最終的にすべての要素がなくなると、おなじみの空リスト`[]`が顔を出すわけです。

この記法を一般化すると、次の通りです:


```haskell
値 : 残りの要素を含むリスト
```

シンプルですね。  
`[1]`や`[1, 2]`も、本当は`1 : []`や`1 : 2 : []`の糖衣構文でしかありません。

このように、`:` は**リストの先頭の要素と、残りのリストを含む値コンストラクター**となっています。  
`[]`と同様こちらも名前が記号しかないので分かりづらいですが、`:`も立派な値コンストラクターなのです（ちなみに読み上げるときは「コンス（Cons）」という変な名前で読んでください）。

そして、リストはこの`:`と、先ほど紹介した「空っぽのリスト」を表す`[]`という二つの値コンストラクターを使い分けることで、「空っぽの場合」と「（一つ以上の）要素がある場合」の二つの場合を表すことができるのです。

ここまでの話をまとめます:

- リストの「本当の値コンストラクター」には、「空っぽの場合」と「（一つ以上の）要素がある場合」の二つがある:
    - 「空っぽの場合」の値コンストラクターは`[]`という記号で表され、フィールドを一つも持たない。
    - 「（一つ以上の）要素がある場合」の値コンストラクターは`:`という記号で表され、
        - 左辺のフィールドに、リストの先頭の要素を持ち、
        - 右辺のフィールドに、残りのリストを持つ。

次の節では、リストの値コンストラクター`:`を使って、「リストの長さがわからない場合」にパターンマッチする方法を覚えましょう。

#### リストに対するパターンマッチ（リストの長さがわからない場合）

```haskell
ghci> x : xs = [1, 2, 3]
ghci> x
1
ghci> xs
[2,3]

ghci> y : ys = xs
ghci> y
2
ghci> ys
[3]
```

```haskell
ghci> x : y : xs = [1, 2, 3]
ghci> x
1
ghci> y
2
ghci> xs
[3]
```

型注釈の`::`と間違えないように気をつけてください！

`:`を使ってもうまく扱えないケースが！

```haskell
ghci> x : xs = []
ghci> x
*** Exception: <interactive>:57:1-11: Irrefutable pattern failed for pattern x : xs

ghci> xs
*** Exception: <interactive>:57:1-11: Irrefutable pattern failed for pattern x : xs
```

### `case`式で場合分けされたパターンマッチをする

```haskell
ghci> possiblyEmpty = []
ghci> :{
ghci| case possiblyEmpty of
ghci|   x : xs -> print x
ghci|   [] -> putStrLn "Empty!"
ghci| :}
Empty!
```

```haskell
ghci> possiblyEmpty = [1, 2, 3]
ghci> :{
ghci| case possiblyEmpty of
ghci|   x : xs -> print x
ghci|   [] -> putStrLn "Empty!"
ghci| :}
1
```

```haskell
ghci> xs = [1, 2, 3]
ghci> :{
ghci| case xs of
ghci|   [first, second, third] -> putStrLn "Three elements!"
ghci|   [first, second] -> putStrLn "Two elements!"
ghci|   [] -> putStrLn "Empty!"
ghci| :}
Three elements!
```

```haskell
ghci> xs = [1]
ghci> :{
ghci| case xs of
ghci|   [first, second, third] -> putStrLn "Three elements!"
ghci|   [first, second] -> putStrLn "Two elements!"
ghci|   [] -> putStrLn "Empty!"
ghci| :}
*** Exception: <interactive>:(100,1)-(103,25): Non-exhaustive patterns in case
```

```haskell
ghci> xs = [1]
ghci> :{
ghci| case xs of
ghci|   [first, second, third] -> putStrLn "Three elements!"
ghci|   [first, second] -> putStrLn "Two elements!"
ghci|   [] -> putStrLn "Empty!"
ghci|   o -> putStrLn ("Other! " ++ show o)
ghci| :}
Other! [1]
```

シャドーイングした例

```haskell
ghci> xs = [1]
ghci> :{
ghci| case xs of
ghci|   [first, second, third] -> putStrLn "Three elements!"
ghci|   [first, second] -> putStrLn "Two elements!"
ghci|   xs -> putStrLn ("Other! " ++ show xs)
ghci| :}
Other! [1]
```

```haskell
ghci> xs = [1]
ghci> :{
ghci| case xs of
ghci|   [_first, _second, _third] -> putStrLn "Three elements!"
ghci|   [_first, _second] -> putStrLn "Two elements!"
ghci|   o -> putStrLn ("Other! " ++ show o)
ghci| :}
Other! [1]
```

```haskell
ghci> xs = [1]
ghci> :{
ghci| case xs of
ghci|   [_, _, _] -> putStrLn "Three elements!"
ghci|   [_, _] -> putStrLn "Two elements!"
ghci|   o -> putStrLn ("Other! " ++ show o)
ghci| :}
Other! [1]
```

```haskell
ghci> xs = ["a"]
ghci> :{
ghci| case xs of
ghci|   x : _xs -> putStrLn ("Head: " ++ x)
ghci|   _other -> putStrLn "Other! "
ghci| :}
Head: a
```

```haskell
ghci> xs = []
ghci> :{
ghci| case xs of
ghci|   x : _xs -> putStrLn ("Head: " ++ x)
ghci|   _other -> putStrLn "Other! "
ghci| :}
Other!
```

### `case`式の中でも`do`記法を使う

```haskell
ghci> possiblyEmpty = ["a", "b", "c"]
ghci> :{
ghci| case possiblyEmpty of
ghci|   x : xs -> do
ghci|     putStrLn ("The first element is: " ++ x ++ ".")
ghci|     putStrLn ("The rest elements are: " ++ show xs ++ ".")
ghci|   [] -> putStrLn "Empty!"
ghci| :}
The first element is: a.
The rest elements are: ["b","c"].
```

```
ghci> numbers = [1, 2, 3]
ghci> :{
ghci| case numbers of
ghci|   [n1, n2] -> do
ghci|     let answer = n1 + n2
ghci|     putStrLn ("The answer is: " ++ show answer)
ghci|   other -> do
ghci|     putStrLn "Sorry, I don't know how to sum them up!"
ghci|     putStrLn ("Your input is: " ++ show other)
ghci| :}
Sorry, I don't know how to sum them up!
Your input is: [1,2,3]
```

### `words`関数で空白文字で区切られた文字列を分割する

```haskell
ghci> words "a b c"
["a","b","c"]
ghci> words "a   b                 c"
["a","b","c"]
ghci> words "          "
[]
ghci> words ""
[]
ghci> words "a                  "
["a"]
ghci> words "          a"
["a"]
ghci> words "          a\nbc\nd"
["a","bc","d"]
```
