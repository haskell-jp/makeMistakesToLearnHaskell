# 例外をスローする・再帰呼び出し（復習）

そろそろ課題2.5で目標とするアプリケーションのことを意識して、入力された行を「分類」と「金額」のペアとして解釈して、「金額」の合計を書くプログラムを書いてみましょう。

1. 「金額の合計」を「0」として、以下の処理を実行します。
2. **(A)** 標準入力から1行の入力を受け取ります。
3. 受け取った入力を、空白で区切った文字列のリストとして代入します。
4. 代入した文字列のリストの要素数が
    1. 「2」であれば、1つめの要素を「分類」、2つめの要素を「金額」が書かれた文字列として解釈して、「金額」を「金額の合計」に足して、再度**(A)**から実行します。
    2. 「0」であれば、「金額の合計」を出力して、終了します。
    3. それ以外の場合は、「`Invalid input: <入力した文字列>`」という形式のメッセージで**例外を発生させ**、終了します。

## 必要な知識

### 例外を発生させる

まずは、課題のプログラムの説明で出てきた「**例外を発生させ**、終了」するための方法を紹介します。

「例外」とは文字通りプログラムを実行しているときに発生した例外的な値です。通常、例外が発生するとプログラムはエラーメッセージを標準エラー出力に出力して終了してしまいます。「例外」は予期しない状況でしか作られないので、その後どうすればよいかプログラムも分からなくなってしまい、終了してしまうのです（「例外」が発生してもプログラムが終了しないよう、なんとかやりくりする方法はありますが、ここでは割愛します）。

今回紹介する、例外を発生させる二つの方法は、プログラムのどこからでも発生させられるよう、**どんな型の値にもなり得る**という特殊な（文字通り例外的な）特徴を持っています。いずれの方法も開発中にしばしば利用されるので、今回の課題を解く上でもどちらかを使ってみてください。

まずは`undefined`です。GHCiに入力すると下のように`*** Exception: Prelude.undefined`と表示されたことから、`undefined`が例外（exception）を発生させたことが察せられます:

```haskell
ghci> undefined
*** Exception: Prelude.undefined
CallStack (from HasCallStack):
  error, called at libraries\base\GHC\Err.hs:79:14 in base:GHC.Err
  undefined, called at <interactive>:4:1 in interactive:Ghci1
```

先に触れたとおり`undefined`はどんな型の値にもなることができます。そのことはGHCiの`:t`コマンドを使ってみてもよくわかります:

```haskell
ghci> :t undefined
undefined :: a
```

`undefined :: a`という、今まで見てきた`:t`の結果とはちょっと異なる結果が表示されました。課題hoge(7?)で紹介したとおり、型が現れるところに出てきた、小文字で始まる識別子`a`は`a`という名前の型変数です。型変数`a`は「何かの型」を表しているのでした。「何かの型」は「何かの型」を返す値（この場合`undefined`）が実際に使われている箇所において、型推論されることで具体的な型になります。例えば、`putStrLn undefined`という式は`putStrLn`が`String -> IO ()`という型なので、その引数として与えた`undefined`は`String`型として解釈されます。もう一つ例を挙げると、課題hogeで紹介した`if`式を使った`if undefined then 1 else 2`という式の場合、`undefined`が書かれた`if`式の条件部には本来`Bool`型の値を書かなければなりませんので、`if undefined then 1 else 2`という式における`undefined`は`Bool`型の値として解釈されます。このように、`undefined`は「例外」をプログラムにおけるどこの式からでも発生させられるよう、単なる`a`という「何かの型」となっています。

「例外」を発生させるもう一つの方法は`error`関数を使った方法です。`error`関数は引数として文字列を与えると例外を発生させる関数となっています:

```haskell
ghci> error "My awesome error message!"
*** Exception: My awesome error message!
CallStack (from HasCallStack):
  error, called at <interactive>:5:1 in interactive:Ghci1
```

`undefined`を使った場合と比べて、`*** Exception:`と書かれた後のメッセージが変わりましたね！このように`error`関数は、自分で設定したエラーメッセージの例外を発生させるのにとてもお手軽な機能なのです。

GHCiで`error`関数の型も見てみましょう。どんな型になっているか、`undefined`の型や、これまでに学習した知識から推測した上で入力してみてください。

... いいですか？それでは答えはこちら！:

```haskell
ghci> :t error
error :: [Char] -> a
```

イメージどおりの結果でしたか？`undefined`がプログラムにおけるどこの式からでも使えるよう`a`型になっていたのと同様に、`error`関数も`a`型を返すのです。そして、`error`関数の場合はエラーメッセージである文字列を引数として渡す必要があることから、`[Char] -> a`、すなわち「文字列を受け取って、何かの型（使用される箇所に応じて型推論された結果の型）を返す関数」となっているのです。

#### 強引にコンパイルを通す

それでは、`undefined`や`error`関数の典型的なユースケースを紹介しましょう。

プログラムを少しずつ書いていくとき、全体像を把握できるよう`main`関数から必要な処理を列挙する、というトップダウンなアプローチはしばしば有用です。そんな場合に`undefined`や`error`関数はしばしば使用されます。例えば、課題10ではBMIを計算するアプリケーションについて、課題9でべた書きしたコードから「文字列として身長`height`と体重`weight`を受け取って、BMIを求める」関数を切り出すという方法を採りましたが、今度は逆にBMIを求める関数以外の処理から埋めてみましょう。課題9の課題文に従って、とりあえず「BMIを計算する」以外の処理を埋めると、次のようなコードができあがるでしょう:

```hs
main = do
  putStrLn "Height Weight: "
  hwStr <- getLine
  case words hwStr of
    heightStr : weightStr : _ -> do
      let result = {- TODO: ここでBMIを計算する -}
      print result
    [heightStr] -> do
      putStrLn "Weight: "
      weightStr <- getLine
      let result = {- TODO: ここでBMIを計算する -}
      print result
    other ->
      putStrLn "Invalid input"
```

未完成なコードだから当然と言えば当然なのですが、上記のコードは動きません。`{- TODO: ここでBMIを計算する -}`の部分が原因で、構文エラー（`parse error`）になってしまいます:

```hs
<interactive>:11:7: error:
    parse error (possibly incorrect indentation or mismatched brackets)
```

もう少し埋められないものでしょうか？コメントを挟んだだけだと構文エラーになってしまいますから、`bmiFromStrings`などといった名前の関数がある**つもりで**使ってみましょう。BMIを計算するには身長と体重が必要なわけですから、`bmiFromStrings`関数には身長と体重を表す文字列である`heightStr`と`weightStr`をそれぞれ渡すことにします:

```hs
main = do
  putStrLn "Height Weight: "
  hwStr <- getLine
  case words hwStr of
    heightStr : weightStr : _ -> do
      let result = bmiFromStrings heightStr weightStr
      print result
    [heightStr] -> do
      putStrLn "Weight: "
      weightStr <- getLine
      let result = bmiFromStrings heightStr weightStr
      print result
    other ->
      putStrLn "Invalid input"
```

今度は次のようなエラーになりました:

```hs
<interactive>:12:20: error:
    Variable not in scope: bmiFromStrings :: String -> String -> t

<interactive>:17:20: error:
    Variable not in scope: bmiFromStrings :: String -> String -> t
```

`Variable not in scope: bmiFromStrings :: String -> String -> t`というエラーが2箇所で発生しました。こちらのエラーは「`bmiFromStrings`という関数（を入れた変数）が見つからないよ！」というエラーです。` :: String -> String -> t`という箇所は、`bmiFromStrings`がどんな型であるべきなのかを表しています。親切なことにGHCは、`bmiFromStrings`がどのような引数を受け取り戻り値をどのような関数に渡しているかを見て、まだ影も形もない`bmiFromStrings`の型について教えてくれるのです。ここでは、`bmiFromStrings`の引数、`heightStr`・`weightStr`が`String`型なので引数を両方`String`型と判断し、戻り値である`result`を渡した`print`関数は「`Show`型クラスのインスタンスである何かの型」の値を受け取るのでひとまず`t`としました。実際のところ、（課題10の模範解答もそうであったとおり）ここではBMIを計算して返す関数が欲しいので、結果として欲しいのは数値型の`Double`です。従って、ここではひとまず`bmiFromStrings :: String -> String -> Double`という型の関数を書きましょう... と言ったところでようやく出てくるのが`undefined`や`error`関数です。次のように使うことで、「`bmiFromStrings`という`String`型の値を2つ受け取って`Double`型の値を返す関数の定義」を「仮置き」できます:

```haskell
bmiFromStrings :: String -> String -> Double
bmiFromStrings = undefined
```

この`bmiFromStrings`と前述の`main`関数を同じファイルに書いてGHCiで読み込むとあら不思議、何のエラーも出ません！そのまま`main`関数を実行するとどうなるのでしょうか？

```haskell
ghci> main
Height Weight:
120 90 -- とりあえず身長と体重両方を入力してみる
*** Exception: Prelude.undefined
CallStack (from HasCallStack):
  error, called at libraries\base\GHC\Err.hs:79:14 in base:GHC.Err
  undefined, called at <interactive>:22:18 in interactive:Ghci1
```

`main`関数の最初の方にあたる、`Height Weight`を出力する処理や`getLine`で入力を取得する処理を行った後、この課題の最初の方で`undefined`を入力したときと同様に`*** Exception: Prelude.undefined`と表示されました。これはまさしく`bmiFromStrings`関数を定義するときに書いた`undefined`を`String -> String -> Double`型の値、すなわち「文字列を二つ受け取って数値を返す関数」として評価しようとして発生した例外によるものです。

このように、`undefined`は「どんな型の値にもなり得る」という特殊な性質を利用して、実装がまだできていない関数の定義を埋めて、強引にコンパイルを通すのによく用いられます。間違えてこのまま使用してしまわないよう注意する必要はあるものの、上記の例のようにトップダウンにプログラムを書いているとき、概要を書いた時点で思い描いたとおりに実装が進んでいるか確かめるのに、大変便利です。コンパイルができると言うことは型チェックにも成功している、ということなのでそれを確かめるだけでもある種の確信を得られます。

では、例外が発生したときに表示するメッセージをもっと分かりやすくしたいときはどうすればよいでしょうか？そう、`error`関数を使いましょう。関数の名前も書いておくとより親切なので、私は下記のような入力を半自動で行ってくれるスニペットをエディターに設定しています:

```haskell
bmiFromStrings :: String -> String -> Double
bmiFromStrings = error "bmiFromStrings is not defined yet!"
```

`bmiFromStrings`関数を上記の`error`関数を使ったバージョンに差し替えて、先ほどの`main`関数を実行すると、ちゃんと設定したエラーメッセージが表示されますね:

```haskell
ghci> main
Height Weight:
120 90
*** Exception: bmiFromStrings is not defined yet!
CallStack (from HasCallStack):
  error, called at <interactive>:22:18 in interactive:Ghci1
```

#### `read`関数が文字列からの変換に失敗したとき

実は、この課題以前に紹介した関数にも例外を発生させるものがあり、その関数が例外を発生させた例もすでに紹介しています。それは何でしょうか？

答えはこちら:

```haskell
ghci> read "not a number" + 2
*** Exception: Prelude.read: no parse
```

そう、`read`関数は与えられた文字列を対象の型（`read`関数の戻り値を使用している箇所から型推論した結果の型）の値に変換できないとき、上記のように例外を発生させます。そのため、`read`関数に与える文字列は、あらかじめ対象の型に**確実に変換できる**と分かっている文字列を渡す方が好ましいでしょう。そうでなければ、例外が発生してプログラムがその場で終了してしまう恐れがあるためです。もちろん、これまで書いてきたようにプログラムが即終了しても構わないような状況であれば構いませんが。

#### ちょっと待って、もっといいやり方があるよ！

### 再帰呼び出し（復習）

ユーザーが入力した行を、1つずつ結合する関数を作る

```haskell
concatLines currentString = do
    line <- getLine
    concatLines (currentString ++ line)
```

課題11より: 「`getLine`のような「命令」は実行する度に結果が変わるけど、普通の引数は変わらないので、自分で引数を変える必要がある」

今回は、「結果」となる値を書き換えるために、引数で引き回す。

「変数を書き換える」代わりに「違う引数を渡す」のが関数型プログラミングのポイント

```haskell
concatLines currentString = do
    line <- getLine
    case line of
        "" -> return currentString
        _  -> concatLines (currentString ++ line)
```
