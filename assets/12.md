# 例外をスローする・再帰呼び出し（復習）

そろそろ課題2.5で目標とするアプリケーションのことを意識して、入力された行を「分類」と「金額」のペアとして解釈して、「金額」の合計を書くプログラムを書いてみましょう。

1. 「金額の合計」を「0」として、以下の処理を実行します。
2. **(A)** 標準入力から1行の入力を受け取ります。
3. 受け取った入力を、空白で区切った文字列のリストとして代入します。
4. 代入した文字列のリストの要素数が
    1. 「2」であれば、1つめの要素を「分類」、2つめの要素を「金額」が書かれた文字列として解釈して、「金額」を「金額の合計」に足して、再度**(A)**から実行します。
    2. 「0」であれば、「金額の合計」を出力して、終了します。
    3. それ以外の場合は、「`Invalid input: <入力した文字列>`」という形式のメッセージで**例外を発生させ**、終了します。

## 必要な知識

### 例外を発生させる

まずは、課題のプログラムの説明で出てきた「**例外を発生させ**、終了」するための方法を紹介します。

「例外」とは文字通りプログラムを実行しているときに発生した例外的な値です。通常、例外が発生するとプログラムはエラーメッセージを標準エラー出力に出力して終了してしまいます。「例外」は予期しない状況でしか作られないので、その後どうすればよいかプログラムも分からなくなってしまい、終了してしまうのです（「例外」が発生してもプログラムが終了しないよう、なんとかやりくりする方法はありますが、ここでは割愛します）。

今回紹介する、例外を発生させる二つの方法は、プログラムのどこからでも発生させられるよう、**どんな型の値にもなり得る**という特殊な（文字通り例外的な）特徴を持っています。いずれの方法も開発中にしばしば利用されるので、今回の課題を解く上でもどちらかを使ってみてください。

まずは`undefined`です。GHCiに入力すると下のように`*** Exception: Prelude.undefined`と表示されたことから、`undefined`が例外（exception）を発生させたことが察せられます:

```haskell
ghci> undefined
*** Exception: Prelude.undefined
CallStack (from HasCallStack):
  error, called at libraries\base\GHC\Err.hs:79:14 in base:GHC.Err
  undefined, called at <interactive>:4:1 in interactive:Ghci1
```

先に触れたとおり`undefined`はどんな型の値にもなることができます。そのことはGHCiの`:t`コマンドを使ってみてもよくわかります:

```haskell
ghci> :t undefined
undefined :: a
```

`undefined :: a`という、今まで見てきた`:t`の結果とはちょっと異なる結果が表示されました。課題hoge(7?)で紹介したとおり、型が現れるところに出てきた、小文字で始まる識別子`a`は`a`という名前の型変数です。型変数`a`は「何かの型」を表しているのでした。「何かの型」は「何かの型」を返す値（この場合`undefined`）が実際に使われている箇所において、型推論されることで具体的な型になります。例えば、`putStrLn undefined`という式は`putStrLn`が`String -> IO ()`という型なので、その引数として与えた`undefined`は`String`型として解釈されます。もう一つ例を挙げると、課題hogeで紹介した`if`式を使った`if undefined then 1 else 2`という式の場合、`undefined`が書かれた`if`式の条件部には本来`Bool`型の値を書かなければなりませんので、`if undefined then 1 else 2`という式における`undefined`は`Bool`型の値として解釈されます。このように、`undefined`は「例外」をプログラムにおけるどこの式からでも発生させられるよう、単なる`a`という「何かの型」となっています。

「例外」を発生させるもう一つの方法は`error`関数を使った方法です。`error`関数は引数として文字列を与えると例外を発生させる関数となっています:

```haskell
ghci> error "My awesome error message!"
*** Exception: My awesome error message!
CallStack (from HasCallStack):
  error, called at <interactive>:5:1 in interactive:Ghci1
```

`undefined`を使った場合と比べて、`*** Exception:`と書かれた後のメッセージが変わりましたね！このように`error`関数は、自分で設定したエラーメッセージの例外を発生させるのにとてもお手軽な機能なのです。

GHCiで`error`関数の型も見てみましょう。どんな型になっているか、`undefined`の型や、これまでに学習した知識から推測した上で入力してみてください。

... いいですか？それでは答えはこちら！:

```haskell
ghci> :t error
error :: [Char] -> a
```

イメージどおりの結果でしたか？`undefined`がプログラムにおけるどこの式からでも使えるよう`a`型になっていたのと同様に、`error`関数も`a`型を返すのです。そして、`error`関数の場合はエラーメッセージである文字列を引数として渡す必要があることから、`[Char] -> a`、すなわち「文字列を受け取って、何かの型（使用される箇所に応じて型推論された結果の型）を返す関数」となっているのです。

#### 強引にコンパイルを通す

それでは、`undefined`や`error`関数の典型的なユースケースを紹介しましょう。

プログラムを少しずつ書いていくとき、全体像を把握できるよう`main`関数から必要な処理を列挙する、というトップダウンなアプローチはしばしば有用です。そんな場合に`undefined`や`error`関数はしばしば使用されます。例えば、課題10ではBMIを計算するアプリケーションについて、課題9でべた書きしたコードから「文字列として身長`height`と体重`weight`を受け取って、BMIを求める」関数を切り出すという方法を採りましたが、今度は逆にBMIを求める関数以外の処理から埋めてみましょう。課題9の課題文に従って、とりあえず「BMIを計算する」以外の処理を埋めると、次のようなコードができあがるでしょう:

```hs
main = do
  putStrLn "Height Weight: "
  hwStr <- getLine
  case words hwStr of
    heightStr : weightStr : _ -> do
      let result = {- TODO: ここでBMIを計算する -}
      print result
    [heightStr] -> do
      putStrLn "Weight: "
      weightStr <- getLine
      let result = {- TODO: ここでBMIを計算する -}
      print result
    other ->
      putStrLn "Invalid input"
```

未完成なコードだから当然と言えば当然なのですが、上記のコードは動きません。`{- TODO: ここでBMIを計算する -}`の部分が原因で、構文エラー（`parse error`）になってしまいます:

```hs
<interactive>:11:7: error:
    parse error (possibly incorrect indentation or mismatched brackets)
```

もう少し埋められないものでしょうか？コメントを挟んだだけだと構文エラーになってしまいますから、`bmiFromStrings`などといった名前の関数がある**つもりで**使ってみましょう。BMIを計算するには身長と体重が必要なわけですから、`bmiFromStrings`関数には身長と体重を表す文字列である`heightStr`と`weightStr`をそれぞれ渡すことにします:

```hs
main = do
  putStrLn "Height Weight: "
  hwStr <- getLine
  case words hwStr of
    heightStr : weightStr : _ -> do
      let result = bmiFromStrings heightStr weightStr
      print result
    [heightStr] -> do
      putStrLn "Weight: "
      weightStr <- getLine
      let result = bmiFromStrings heightStr weightStr
      print result
    other ->
      putStrLn "Invalid input"
```

今度は次のようなエラーになりました:

```hs
<interactive>:12:20: error:
    Variable not in scope: bmiFromStrings :: String -> String -> t

<interactive>:17:20: error:
    Variable not in scope: bmiFromStrings :: String -> String -> t
```

`Variable not in scope: bmiFromStrings :: String -> String -> t`というエラーが2箇所で発生しました。こちらのエラーは「`bmiFromStrings`という関数（を入れた変数）が見つからないよ！」というエラーです。` :: String -> String -> t`という箇所は、`bmiFromStrings`がどんな型であるべきなのかを表しています。親切なことにGHCは、`bmiFromStrings`がどのような引数を受け取り戻り値をどのような関数に渡しているかを見て、まだ影も形もない`bmiFromStrings`の型について教えてくれるのです。ここでは、`bmiFromStrings`の引数、`heightStr`・`weightStr`が`String`型なので引数を両方`String`型と判断し、戻り値である`result`を渡した`print`関数は「`Show`型クラスのインスタンスである何かの型」の値を受け取るのでひとまず`t`としました。実際のところ、（課題10の模範解答もそうであったとおり）ここではBMIを計算して返す関数が欲しいので、結果として欲しいのは数値型の`Double`です。従って、ここではひとまず`bmiFromStrings :: String -> String -> Double`という型の関数を書きましょう... と言ったところでようやく出てくるのが`undefined`や`error`関数です。次のように使うことで、「`bmiFromStrings`という`String`型の値を2つ受け取って`Double`型の値を返す関数の定義」を「仮置き」できます:

```haskell
bmiFromStrings :: String -> String -> Double
bmiFromStrings = undefined
```

この`bmiFromStrings`と前述の`main`関数を同じファイルに書いてGHCiで読み込むとあら不思議、何のエラーも出ません！そのまま`main`関数を実行するとどうなるのでしょうか？

```haskell
ghci> main
Height Weight:
120 90 -- とりあえず身長と体重両方を入力してみる
*** Exception: Prelude.undefined
CallStack (from HasCallStack):
  error, called at libraries\base\GHC\Err.hs:79:14 in base:GHC.Err
  undefined, called at <interactive>:22:18 in interactive:Ghci1
```

`main`関数の最初の方にあたる、`Height Weight`を出力する処理や`getLine`で入力を取得する処理を行った後、この課題の最初の方で`undefined`を入力したときと同様に`*** Exception: Prelude.undefined`と表示されました。これはまさしく`bmiFromStrings`関数を定義するときに書いた`undefined`を`String -> String -> Double`型の値、すなわち「文字列を二つ受け取って数値を返す関数」として評価しようとして発生した例外によるものです。

このように、`undefined`は「どんな型の値にもなり得る」という特殊な性質を利用して、実装がまだできていない関数の定義を埋めて、強引にコンパイルを通すのによく用いられます。間違えてこのまま使用してしまわないよう注意する必要はあるものの、上記の例のようにトップダウンにプログラムを書いているとき、概要を書いた時点で思い描いたとおりに実装が進んでいるか確かめるのに、大変便利です。コンパイルができると言うことは型チェックにも成功している、ということなのでそれを確かめるだけでもある種の確信を得られます。

では、例外が発生したときに表示するメッセージをもっと分かりやすくしたいときはどうすればよいでしょうか？そう、`error`関数を使いましょう。関数の名前も書いておくとより親切なので、私は下記のような入力を半自動で行ってくれるスニペットをエディターに設定しています:

```haskell
bmiFromStrings :: String -> String -> Double
bmiFromStrings = error "bmiFromStrings is not defined yet!"
```

`bmiFromStrings`関数を上記の`error`関数を使ったバージョンに差し替えて、先ほどの`main`関数を実行すると、ちゃんと設定したエラーメッセージが表示されますね:

```haskell
ghci> main
Height Weight:
120 90
*** Exception: bmiFromStrings is not defined yet!
CallStack (from HasCallStack):
  error, called at <interactive>:22:18 in interactive:Ghci1
```

#### `read`関数が文字列からの変換に失敗したとき

実は、この課題以前に紹介した関数にも例外を発生させるものがあり、その関数が例外を発生させた例もすでに紹介しています。それは何でしょうか？

答えはこちら:

```haskell
ghci> read "not a number" + 2
*** Exception: Prelude.read: no parse
```

そう、`read`関数は与えられた文字列を対象の型（`read`関数の戻り値を使用している箇所から型推論した結果の型）の値に変換できないとき、上記のように例外を発生させます。そのため、`read`関数に与える文字列は、あらかじめ対象の型に**確実に変換できる**と分かっている文字列を渡す方が好ましいでしょう。そうでなければ、例外が発生してプログラムがその場で終了してしまう恐れがあるためです。もちろん、これまで書いてきたようにプログラムが即終了しても構わないような状況であれば構いませんが。

#### ちょっと待って、もっといいやり方があるよ！

ここまでで、`undefined`や`error`関数を使ったとき、それから`read`関数に予期せぬ文字列を渡してしまったとき、例外が発生し、プログラムがそのまま終了してしまうことを解説しました。例外を使うことは、今回の課題のようにあらかじめプログラムがすぐに終了しても構わないと分かっているときや、プログラムを書いている途中に使う分には便利なのですが、関数が処理を続けられない場合に用いる常套手段としては、大きな問題があります。それは、「どの関数が例外を発生させるのか、分かりづらい」ということです。いくつか先の課題になってしまいますが、この先では、関数の型によって「この関数は失敗して処理を続けられなくなる場合がある」ということを示す方法を紹介します。ひとまずそれまでは、ここで紹介した`undefined`や`error`関数をご利用ください。「今すぐ知りたいよ！」という方は課題hoge(18?)まで飛ばすか、「Haskell Maybe」や「Haskell Either」で検索してください。

### 再帰呼び出し（復習）

ここまで紹介した知識で今回の課題を解くことはできますが、今回の課題を解くのに必要な再帰呼び出しが、前回の課題で紹介したものより少し込み入ったものとなっているので、同じように再帰する関数を書いてみて、コツを学びましょう。

今回の課題で実装する関数は、標準入力から1行取得する処理を繰り返し、受け取った行の一部を金額として解釈して、合計を計算します。代わりにここでは、標準入力から1行取得する処理を繰り返し、受け取った行をそのまま`++`で結合する関数を書くことにします。

何はともあれ、関数の名前を付けましょう。`concatLines`という名前にします。

```haskell
concatLines = undefined
```

先ほど紹介した`undefined`を使い、`concatLines`が未定義であることを明示しつつ、強引にコンパイルできるようにしてみました。これをスタート地点として少しずつ実装していきましょう。

ひとまず、「標準入力から1行取得する」`getLine`関数を繰り返し実行するだけの`concatLines`を書いてみます:

```haskell
concatLines = do
    line <- getLine
    concatLines
```

GHCiに入力して、実行してみましょう:

```haskell
ghci> concatLines
aaa   -- ここはユーザーによる入力
bbbb  -- ここもユーザーによる入力
cc    -- ここもユーザーによる入力
-- ..... 以下繰り返し
```

上記のように、何行入力してみても`concatLines`関数の実行は終わりません。`Ctrl + C`を押すなどして強制終了させなければなりません。それもそのはず、`concatLines`の定義のとおり、`concatLines`は`getLine`を実行した後**必ず**`concatLines`を再帰呼び出しするため、標準入力から1行取得した後、直ちにまた1行取得しようとするのです。

どうすれば直せるでしょう？再帰呼び出しは`concatLines`関数自身を繰り返し呼び出すことで行われるのですから、適当な条件で呼び出さないようにすれば良いのです。今回はひとまず、標準入力から取得した1行の文字列が、空文字列だった場合は再帰呼び出ししないようにしてみましょう:

```haskell
concatLines = do
    line <- getLine
    case line of
        "" -> return line
        _  -> concatLines
```

再帰呼び出ししない場合、すなわち上記の`case`式における`"" -> return line`の行では、再帰呼び出しも含め「何もしない」ことを表すために`return`を使う必要があるので使いました。では、上記の`concatLines`関数を実行するとどうなるでしょう？

```haskell
ghci> concatLines
aa   -- ここから最後から一つ前の行までがユーザーによる入力
ggg
adad
qq

""   -- これはGHCiが出力した文字列。`concatLines`の実行結果
```

確かに何も入力しないでただEnterを押した直後、`concatLines`関数の実行は終了し、結果である文字列`""`が表示されました。しかし、これではまだ本節で実装する関数の要件を満たせておりません --- そう、「受け取った行をそのまま`++`で結合」できていないので、必ず空文字列`""`が返ってきてしまいます。

「受け取った行をそのまま`++`で結合」して意図通りの値を返すには、何らかの方法で「これまで`concatLines`を呼ぶ度に結合してきた文字列」をどこかに保存し、`getLine`関数が新たに取得した文字列と結合させる必要があります。そのためには、「これまで`concatLines`を呼ぶ度に結合してきた文字列」を**引数に**保存してください:

```haskell
concatLines stringSoFar = do
    line <- getLine
    let newString = stringSoFar ++ line
    case line of
        "" -> return newString
        _  -> concatLines newString
```

`stringSoFar`という引数が増えましたね！ここに「これまで結合してきた文字列」が代入されます。`concatLines`関数は`getLine`関数を呼ぶ度に、この`stringSoFar`と`getLine`の結果`line`を結合します。そして、`line`が空文字列でなかった場合は、結合してできた文字列`newString`を新しい「これまで結合してきた文字列」となるよう`concatLines`に渡し、再帰呼び出しします。

ここでのポイントは次のとおりです: `getLine`をただ呼ぶだけでは、呼び出した時得られた入力（上述の例で言うところの`line`）しか変えられないところを、`stringSoFar`という引数を増やすことで、「これまで結合してきた文字列」として再帰呼び出しの際に変更して呼び出せることです。課題hoge(11)で、引数として数のリストを受け取って、すべての要素を2倍にして返す`doubles`関数を書いたときのことを思い出してください。`doubles`関数では、引数である`xs`を再帰呼び出しする度に一つ要素を取り除いたリスト`xsLeft`に変換して渡すことで、引数の要素を一つずつ処理していました。このときと同様に、「変数を書き換える」代わりに「違う引数を渡す」のです。

もちろん、引数が増えた以上、実際に利用する際の引数もちゃんと増やさなければなりません:

```haskell
-- これはエラー！
ghci> concatLines

<interactive>:12:1: error:
    ? No instance for (Show ([Char] -> IO [Char]))
        arising from a use of ‘print’
        (maybe you haven't applied a function to enough arguments?)
    ? In a stmt of an interactive GHCi command: print it

-- これはOK！
ghci> concatLines ""
ddd  -- ここから最後から一つ前の行までがユーザーによる入力
llll
0

"dddllllzzzzzzz0" -- これはGHCiが出力した文字列。`concatLines`の実行結果
```

`-- これはOK！`な`concatLines ""`では、`concatLines`の引数として空文字列を渡しました。`concatLines`の引数`stringSoFar`はあくまで「これまで結合してきた文字列」を表しているのですから、`concatLines`関数を最初に呼ぶときは何も結合していない文字列、すなわち空文字列を渡すのが正解なのです。このように何を渡すか決まっている場合は、次のように`where`句を使って実際に再帰呼び出しする関数を切り出し、他の関数から再帰呼び出しする関数を呼べないようにするのが定石です:

```haskell
concatLines = loop ""
  where
    loop stringSoFar = do
        line <- getLine
        let newString = stringSoFar ++ line
        case line of
            "" -> return newString
            _  -> loop newString
```

上記の例では`concatLines`自身は再帰呼び出しを行わず、`where`句で定義したローカルな関数、`loop`関数に最初の引数`""`を渡した上で再帰呼び出しさせています。`loop`関数は`where`句で定義されているので`concatLines`以外の関数から呼び出すことはできず、結果`loop`関数の最初に渡される引数は`concatLines`が渡した`""`だけとなるのです。

再帰呼び出しをする関数ではしばしばこのようなパターンがとられており、その際に再帰呼び出しするローカルな関数の名前は、しばしば`go`や上記の`loop`といった名前が用いられます。是非覚えておいてください。
