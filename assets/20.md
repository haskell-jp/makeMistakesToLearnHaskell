# `do`における変数への代入を抑える 2

課題hoge(5?)のアプリケーションを、`<-`を使わずに書き換えましょう。

## 必要な知識

### `fmap`, `<$>`を使って「命令」の結果に純粋な関数を適用する

従来、`IO`（命令）の結果に対して（`a -> IO b`というような型ではなく、`a -> b`という型の）普通の関数を実行するには、次のように`do`の中で左細い矢印`<-`を使って、一旦変数に代入する必要がありました。

```haskell
do
    line <- getLine

    -- lineという変数に代入して、length関数を実行してから何かする
    print (length line)

    -- あるいは、length関数を実行してから何もせずにそのまま返す
    return (length line)
```

課題hoge(19?)で紹介した`>>=`を使うことによって、`do`や代入する変数を用意する必要はなくなりましたが、`return`などの関数を使い、必ず何らかの形で右辺の関数を、`IO`（命令）を返す関数に変換する必要がありました:

```haskell
getLine >>= return . length
```

この（よくある）変換を不要にするのが`fmap`、あるいはその演算子バージョンである`<$>`の役目です。実際のところ`<$>`の方がよく使われるので、ここからは`<$>`で説明します。

上記の例を`<$>`を使って書き換えてみると、こう👇なります:

```haskell
length <$> getLine
```

`>==`から両辺に渡す式が入れ替わっている点には、ご注意ください。`<$>`では、左辺に「普通の関数」、右辺に「命令」を渡します。`>>= return .`という部分が`<$>`に置き換わって、すっきりしましたね！

このように`<$>`は、**`IO`（命令）の結果**に対して、普通の、**純粋な関数**を実行する命令を作るための演算子です。

そのことを裏付けるために、例のごとく`:t`で型定義を覗いてみましょう。

```haskell
ghci> :t (<$>)
(<$>) :: Functor f => (a -> b) -> f a -> f b
```

おっと、`Monad`でもない、`Functor`という聞き慣れない型クラスの型変数が出てきました。`Functor`の説明は置いておいて、前の課題と同様`TypeApplications`を使って型変数`f`を`IO`に置き換えて解釈しましょう。

```haskell
ghci> :set -XTypeApplications
ghci> :t (<$>) @IO
(<$>) @IO :: (a -> b) -> IO a -> IO b
```

上記のように`<$>`の型変数`f`を`IO`に絞ったバージョンを作ると、2つの引数と戻り値は次のような型となります:

- 第1引数（左辺）の`a -> b`: 普通の（入出力を行わない）関数 `a -> b`。
- 第2引数（右辺）の`IO a`: 第1引数の関数の引数と、同じ型の値を返す`IO`（命令）。
- 戻り値の`IO b`: 第1引数（左辺）の関数と、同じ型の値を返す命令。

`IO a`を`a -> b`で`IO b`に変換する演算子である、というのが伝わるでしょうか？`length <$> getLine`の例に当てはめると、`getLine`で「ユーザーから入力してもらった文字列」に対して、`length`関数を実行して得た文字列の長さを返す`IO`（命令）を作っていますね！

```haskell
     length   <$>   getLine
     ^^^^^^         ^^^^^^^
[Char] -> Int      IO [Char]
^^^^^^    ^^^      ^^ ^^^^^^
  a        b       f    a
            \     /
             \   /
              \_/
              / \
            IO  Int
            ^^  ^^^
            f    b
```

ただし厳密に言えば、第1引数である関数はあくまでも`a -> b`という型の、「普通の関数」として扱われる、という点にはご注意ください。`<$>`を`IO`を返す関数`a -> IO b`に対して使うと、**型エラーにならず**、妙な動作になってしまう場合があります。例えば、`putStrLn <$> getLine`とGHCi上で書いた場合...

```haskell
ghci> putStrLn <$> getLine
aaaaa -- ここはユーザーによる入力
```

`putStrLn =<< getLine`と書いたときと異なり、入力した文字列が`putStrLn`によって出力されなかったことにお気づきでしょうか？そう、`getLine`が実行されてユーザーから入力を得たものの、なぜかそれを受け取ったはずの`putStrLn`は実行されなかったのです...😱

#### なぜ`putStrLn <$> getLine`と書いても`putStrLn`は実行されないのか、あるいは型注釈を付けようという話

この理由については難しい話になるので節を分けます。今回の課題を解くだけの目的では必要ないばかりか、あなたの今後のHaskeller人生で絶対に必要な知識でもないので、わからなかったら適当に飛ばしてください。

```haskell
ghci> :t putStrLn <$> getLine
putStrLn <$> getLine :: IO (IO ())
```

`IO (IO ())`という、妙な型が返ってきました、`IO ()`を返す`IO`、つまり「命令を返す命令」とは一体何者なんでしょうか...？

この型に推論されたこと自体は、それぞれの関数の型を考えればごく自然なことです。

- `putStrLn`は`[Char] -> IO ()`という型で、
- `getLine`は`IO [Char]`という型で、
- `IO`に対する`<$>`は`(a -> b) -> IO a -> IO b`という型なので、
- 型変数`a`に`[Char]`、型変数`b`に`IO ()`が代入された。

そう、`IO ()`自体は単なる普通の型なので、普通に型推論され、普通に型変数に代入されます。これまで扱ってきた`Integer`や`Bool`、`[a]`などと変わらない、普通の型なのです。

型と言うことは何らかの値を表しているはずです。これまではっきりと説明してきませんでしたが、一体`IO`型の値は何を表しているのでしょう？

`IO`は「命令」を表すオブジェクトです。例えるなら、ほかのプログラミング言語で言うところの「関数オブジェクト」に近いです。PythonやJavaScriptにおける関数オブジェクト、Rubyで言えば`Proc`クラスのオブジェクト、Javaにおける`Callable`インターフェースを実装したオブジェクトなどなどが該当します。

ただし、ほかのプログラミング言語で言うところの、「関数オブジェクト」と異なり、引数を受け取りません。Haskellでは引数を受け取るのは、あくまでも普通の関数`a -> b`の役目なのです。`putStrLn`も引数に当たる`[Char]`は`[Char] -> IO ()`という型の「普通の関数」の引数として受け取っています。

一方、普通の関数`a -> b`は、`IO`のように入出力処理が出来ません。なので入出力処理の部分は`IO`に任せているのです。

したがって、ほかのプログラミング言語における「関数オブジェクト」は、「自由に入出力ができる」、「関数の戻り値（や引数）になることができる」、という点で、Haskellの`IO`と似ています。「`IO`は引数を受け取らない関数オブジェクト」と捉えてください。

以上の通り、「関数オブジェクト」とよく似たこの`IO`は単なる値として扱えるので、Haskellにおける関数`a -> b`の結果`b`として返したり、`putStrLn <$> getLine`が返す`IO (IO ())`のように、`IO`を実行した結果として返すことができます。

では肝心な点、その結果として返された`IO`はどうやって実行することができるのでしょうか？簡潔に言うと、`main`関数やGHCiの中のどこかで評価することで（`>>=`や`>>`、あるいは`do`でつなげられて、その部分を通ったとき）初めて実行できます。ほかのプログラミング言語における「関数オブジェクト」と異なり、実行する専用の演算子[^execute-operator]はありません。ちょっと分かりづらいですね。

[^execute-operator]: JavaScriptやPythonの関数オブジェクトでは`()`、Rubyの`Proc`クラスのインスタンスやJavaの`Callable`を実装したオブジェクトでは`call`メソッドがその「実行する専用の演算子」に該当します。本当はHaskellにも`unsafePerofrmIO`という関数がありますが、原則としてデバッグ用途以外で使ってはいけないので、詳しくは触れないでおきます。

例として、先程の`putStrLn <$> getLine`を今度こそ全部実行してみましょう:

```haskell
ghci> action1 = putStrLn <$> getLine
ghci> action1
aaaaa         -- ここはユーザーによる入力
ghci>         -- この時点では putStrLn は実行されない
ghci> :t action1 --  IO (IO ()) という型なので、内側の IO () が実行されるまで、putStrLn は実行されない
action1 :: IO (IO ())

-- do の中で<- を使って action1 の中の IO () を取り出して、実行する
ghci> :{
ghci| do
ghci|   action2 <- action1
ghci|   action2
ghci| :}
aaaaa -- ここはユーザーによる入力
aaaaa -- 入力した文字列が出力された！
```

GHCiは、`putStrLn <$> getLine`という式を受け取ったとき、とりあず`IO (IO ())`の外側の`IO (...)`、つまりこの場合`getLine`に当たる「命令」を実行します。そして、その結果として`putStrLn <getLineが返した文字列>`という`IO ()`型の値（命令）を返しているのです。

そのため、上記のように`putStrLn <$> getLine`から`<-`で（あるいは、`>>=`で）取り出した`IO ()`（上記で言うところの`action2`）を直接`do`の中に含めてGHCiに入力することで初めて、`putStrLn <getLineが返した文字列>`の部分も実行することができるようになるのです。

`putStrLn <$> getLine`と書いても`putStrLn`の部分が実行されなかったのは、`getLine`が結果として返した`[Char]`を`putStrLn`で`IO ()`に変換した後、実行していなかったからなのです。

先程の`action2`を最終的に実行する`do`の型を`:t`を使って見てみると、ちゃんと入れ子じゃない、普通の`IO ()`になっていることが確認できます:

```haskell
ghci> :{
ghci| :t do
ghci|   action2 <- action1
ghci|   action2
ghci| :}
do
  action2 <- action1
  action2 :: IO ()
```

なお、この`putStrLn <$> getLine`と入力しても`putStrLn`が実行されない、という現象は、GHCiだけでなく、`main`関数に`putStrLn <$> getLine`と書いてしまった場合も同様に発生します。

```haskell
main = putStrLn <$> getLine
```

というファイルを`not-echoed.hs`という名前で保存して実行してみても、やはりGHCiで実行した場合と同様に、`getLine`に当たる部分しか実行されません。

```
shell> stack exec runhaskell not-echoed.hs
12345 # ここはユーザーによる入力
shell>
```

しかし、多くのHaskellerが行うように、この問題は`main`関数に型注釈をつけていれば、型エラーとして回避できます。`not-echoed.hs`を次のように書き換えてみましょう。

```haskell
main :: IO ()
main = putStrLn <$> getLine
```

今度は以下のような型エラーが報告されるので、問題のある`putStrLn <$> getLine`は実行される間でもありません。

```
shell> stack exec runhaskell not-echoed.hs
not-echoed.hs:2:8: error:
    ? Couldn't match type ‘IO ()’ with ‘()’
      Expected type: IO ()
        Actual type: IO (IO ())
    ? In the expression: putStrLn <$> getLine
      In an equation for ‘main’: main = putStrLn <$> getLine
  |
2 | main = putStrLn <$> getLine
  |        ^^^^^^^^^^^^^^^^^^^^
```

`main`関数のように、`let`や`where`を伴わないで定義された、同じモジュール内のどの関数からも参照できる関数を、「トップレベルに定義された関数」と言います。`main`関数だけでなく、ほかのトップレベルの関数などにも型注釈を付けていれば、この問題は大抵回避できます。一般に、**トップレベルに定義する関数は、型注釈を書く**ことでインターフェースを明確にすることが望ましいとされています。なので、トップレベルの関数などに型注釈を書くことは、この問題を回避する以外のメリットもあるので、なるべく書きましょう。当入門ではこれまで`main`の型注釈については省略してきましたが、今後は`main`についても記載します。

### `<*>`を使って2つ目以降の引数を「命令」の結果から渡す

`+`などの二項演算子といった、2つ以上の引数を受け取る関数の引数として、`IO`などの「命令」の結果を渡す場合、`<$>`だけではできません（理由は後述します）。

例えばこれまで、下記のように`do`を使って書いていたコードを例としましょう:

```haskell
-- `getLine`を2回実行して、取得した2つの文字列を ++ で結合する
do
  line1 <- getLine
  line2 <- getLine
  return $ line1 ++ line2
```

このように2つ（以上）の「命令」が返した結果を、命令でない、純粋な関数に渡すコードは、前の節で紹介した`<$>`と、ここで新たに紹介する`<*>`という演算子を使って次のように書き換えることができます:

```haskell
(++) <$> getLine <*> getLine
```

すっきり！やっぱりワンライナーで書けましたね！（課題hoge(18?)で学習した「演算子を前置関数に変換する」方法を思い出してください！）

試しに実行すると、確かに`getLine`を2回実行して、その結果を`++`で結合していることがわかります:

```haskell
ghci> (++) <$> getLine <*> getLine
first half -- ここはユーザーによる入力
second half -- ここはユーザーによる入力
"first halfsecond half"
```

例のごとく、「新しい関数を見つけたら型を見る」の精神で、`<*>`の型を覗いてみましょう:

```haskell
ghci> :t (<*>)
(<*>) :: Applicative f => f (a -> b) -> f a -> f b
```

`Monad`, `Functor`と続いて、`Applicative`というまた見知らぬ型クラスが登場しました。これらの詳細は次の課題で説明しますので、今はまた`TypeApplications`で`f`を`IO`に置き換えましょう。

```haskell
ghci> :set -XTypeApplications
ghci> :t (<*>) @IO
(<*>) @IO :: IO (a -> b) -> IO a -> IO b
```

`TypeApplications`で`f`を`IO`に絞っても、まだまだ複雑な型ですね。日本語で説明すると、`<*>`は両辺に次のような値を受け取り、次のような値を返す演算子となっています:

- 第1引数（左辺）の`IO (a -> b)`: 「普通の（入出力を行わない）関数 `a -> b`」を返す命令。
- 第2引数（右辺）の`IO a`: 「第1引数の命令が返す関数」の引数と同じ型`a`を返す命令。
- 戻り値の`IO b`: 「第1引数の命令が返す関数」の戻り値と同じ型`b`を返す命令。

第1引数の`IO (a -> b)`がかなり変わっていますね。`a -> b`を返す命令なんて一体どこから出てくるのでしょうか？その答えは、先ほどの`(++) <$> getLine <*> getLine`という式における`<*>`の左辺、`(++) <$> getLine`にあります:

```haskell
ghci> :t (++) <$> getLine
(++) <$> getLine :: IO ([Char] -> [Char])
```

`IO ([Char] -> [Char])`、すなわち「『文字列を受け取って文字列を返す関数』を返す命令」が出てきました！

以下のように`<$>`の型変数`a`・`b`・`f`が推論された結果です:

```haskell
      (++)         <$>            getLine
     ^^^^^^                       ^^^^^^^
[Char] -> [Char] -> [Char]       IO [Char]
^^^^^^    ^^^^^^^^^^^^^^^^       ^^ ^^^^^^
 a          b                    f    a
            \                   /
             \                 /
              \_______________/
              /        \
            IO ([Char] -> [Char])
            ^^ ^^^^^^^^^^^^^^^^^^
            f           b
```

`++`のような2つ以上の引数を受け取る関数を`<$>`に渡した場合、必ずこのように`IO`の中に関数を含んだ型が現れます。Haskellでは2つ以上の引数を受け取る関数は`a -> b -> c`（カッコを補うと「`a -> (b -> c)`」）という型の、「引数を1つ受け取ると、『残りの引数を受け取る関数』を返す関数」で表現されるので、`<$>`を使った結果に「関数を返す命令」が現れるのは、当然なことなのです。

こうした場合に対応するのが`<*>`の役目です。改めて型宣言を思い出してみましょう:

```haskell
ghci> :t (<*>) @IO
(<*>) @IO :: IO (a -> b) -> IO a -> IO b
```

2つ以上の引数を受け取る関数を`<$>`に渡した結果現れる、`IO (a -> b)`型の値を左辺に受け取ることがはっきりと書かれていますね。そして右辺で受け取っているのは、また命令です。「『第1引数の命令が返す関数』の引数と同じ型`a`を返す命令」であることから、第1引数に渡された命令が返す関数に渡すことが予期されます。結果、最終的に`<*>`が返すのは、やっぱり命令です。「『第1引数の命令が返す関数』の戻り値と同じ型`b`を返す命令」とあるとおり、やはり第1引数に渡された命令が返す関数の結果をそのまま返す命令なんでしょう。

ここで出てきた`IO a`から結果となる`a`型の値を取り出して、`IO (a -> b)`の結果となる`a -> b`に渡すには、`IO (a -> b)`と`IO a`、両方を実行する必要があります。下記のような関数を書いて、実際に`<*>`が左辺の`IO (a -> b)`と右辺の`IO a`の両方を実行していることを確かめてみましょう:

```haskell
-- 関数を返す前に`putStrLn`を実行する命令
returnDoubler :: IO (Integer -> Integer)
returnDoubler = do
  putStrLn "Returning a function"
  return (* 2)

-- 整数を返す前に`putStrLn`を実行する命令
return4 :: IO Integer
return4 = do
  putStrLn "Returning 4"
  return 4
```

`returnDoubler`と`<*>`、`return4`を組み合わせると、次のように振る舞います:

```haskell
ghci> returnDoubler <*> return4
Returning a function
Returning 4
8
```

`returnDoubler`に書いた`putStrLn`の後に、`return4`に書いた`putStrLn`が実行されましたね。そう、`<*>`は、左辺に渡した「関数を返す命令」と、右辺に渡した「値を返す命令」を順番に実行しているのです。

以上から、`<*>`は、`<$>`が返した「関数を返す`IO`（命令）」と、`<*>`の右辺に渡したもう1つの`IO`（命令）を**続けて実行する**ための演算子であることがわかります。`<$>`は、あくまでも**1つの**命令の結果を関数に渡す役割である一方、`<*>`は、**2つ以上の**命令を続けて実行して関数に渡す、という点を覚えておいてください。

「2つ**以上**」と書いたとおり、3つ以上の引数を受け取る関数に対しても`<*>`は使えます。例えば、今回の課題で定義しておくと便利であろう、「元金と金利（単位はパーセント）と年数を受け取って、年数後の元金を返す」関数を定義して、それに対して`<*>`を使ってみます。

```haskell
-- Ref: https://support.microsoft.com/ja-jp/help/141695/xl-how-to-calculate-compound-interest
yearlyRate :: Double -> Double -> Integer -> Double
yearlyRate principal interestRate years =
  principal * (1 + interestRate / 100) ^ years
```

試してましょう。`IO`型の値を用意するのに先程の`returnDoubler`のような関数を都度定義するのも面倒なので、`TypeApplications`を使って手っ取り早く`return @IO`で`IO`型の値を作ります[^return]:

[^return]: 単なる`return`だと、ほかの`Monad`型クラスのインスタンスである型の`return`が採用される恐れがあります。`TypeApplications`を使って`return @IO`と書けば、「この`return`は必ず`IO`に対する`return`だよ」と明記できるのでこの問題を回避できるのです。

```haskell
ghci> yearlyRate <$> return @IO 100.0 <*> return @IO 5.0 <*> return @IO 2
110.25
```

できました！

3つめの引数を渡すときも、`<*>`を使って残りの命令を渡すだけです。4つめ以降の引数でも変わりません。途中の式がどのように型付けされているかは、自分で確かめてみてください。

それから、上記の例は下記のように、関数を定義しないで直接それぞれの演算子に対して`<$>`や`<*>`を使うというやり方でも実現できます。ただ、ご覧の通り前置記法で二項演算子を何重も書くのはさすがにつらいので、普段はやめておいた方がいいでしょう:

```haskell
ghci> (*) <$> return @IO 100.0 <*> ((^) <$> ((1 +) <$> ((/ 100) <$> return @IO 5.0)) <*> return @IO 2)
```

あるいは、ラムダ抽象を使うのも1つの手です（相変わらず一行で書くには読みづらいでしょうが）:

```haskell
ghci> (\principal interestRate years -> principal * (1 + interestRate / 100.0) ^ years) <$> return @IO 100 <*> return @IO 5.0 <*> return @IO 2
110.25
```

もっと冗長だけどわかりやすいやり方、すなわち`do`記法を使った方法に立ち返ってもよいでしょう:

```haskell
ghci> :{
ghci| do
ghci|   principal <- return @IO 100.0
ghci|   interestRate <- return @IO 5.0
ghci|   years <- return @IO 2
ghci|   return @IO $ principal * (1 + interestRate / 100) ^ years
ghci| :}
110.25
```

これらの`do`や`<$>`、`<*>`などを使い分けることは、ソースコードの見た目を変える以外にほとんど意味がありません（`IO`型以外の場合や、GHCの`Strict`という言語拡張を使った場合など、いろいろ例外はありますが割愛します）。上記のように`do`を使って書いても、できあがる「命令」の処理内容は変わらないのです。「`<$>`や`<*>`で簡潔に書けるけど、簡潔すぎて読みづらいな」と感じたら迷わず`do`記法を使って書き直してください。

#### `<$>`はなぜ引数が2つ以上の場合には使えないのか

「後述します」と言って積み残した課題がありました。掲題の通り、「`<$>`はなぜ引数が2つ以上の場合には使えないのか」という疑問への回答です。簡単に言うと、前節で`<*>`を解説する際触れたとおり、`a -> b -> c`のような型の、2つ以上の引数を受け取る関数を`<$>`に渡すと`IO (b -> c)`というような型の「（残りの引数を受け取る）関数を返す命令」が出来てしまい、それ以上`<$>`では引数を渡せなくなってしまうから、です。ここでは実際にそれを確かめるため、`<$>`を引数が2つ以上の関数に対し使ってみて、どんな型エラーになるか見てみましょう:

```haskell
ghci> (++) <$> getLine <$> getLine

<interactive>:16:1: error:
    ? Couldn't match expected type ‘String -> b’
                  with actual type ‘IO ([Char] -> [Char])’
    ? Possible cause: ‘(<$>)’ is applied to too many arguments
      In the first argument of ‘(<$>)’, namely ‘(++) <$> getLine’
      In the expression: (++) <$> getLine <$> getLine
      In an equation for ‘it’: it = (++) <$> getLine <$> getLine
    ? Relevant bindings include
        it :: IO b (bound at <interactive>:16:1)
```

`In the first argument of ‘(<$>)’, namely ‘(++) <$> getLine’`という行に注目してください。`<$>`を2回使っているのでわかりづらいですが、ここでは2つめの`<$>`についての型エラーが報告されています。左辺に渡した式`(++) <$> getLine`の型が間違っているのです。

具体的には、左辺の型について、

- 期待している型: `String -> b`、すなわち「文字列を受け取ってなにかの（まだ決まっていない）型`b`の値を返す（普通の）関数」、に対して、
- 実際に渡された式の型: `IO ([Char] -> [Char])`は「『文字列を受け取って文字列を返す関数』を返す**命令**」となっている、

というエラーです。

このような型になった原因は、`(++) <$> getLine`という式の型が`IO ([Char] -> [Char])`となった理由について説明したとおりです。繰り返しになりますが、`<$>`はあくまでも1つの命令を操作するための演算子であって、`<*>`のように、`IO ([Char] -> [Char])`と（右辺が返す）`IO [Char]`という2つの命令を「つなげる」ことはできません。

#### `>>=`との違い

課題hoge(19?)で学習した`>>=`は、いずれも`<*>`と同様、2つの`IO`（命令）を**続けて実行**する`IO`（命令）を作るための演算子です。

課題hoge(19?)でも確かにそう紹介しています:

> まとめると`>>=`は、「左辺の命令の実行結果を受け取って、右辺の『命令を返す関数』につなげて、続けて実行する命令」を返す演算子と言えます。

そうした意味においていずれも用途は似ているのですが、それぞれ使用できる場面が異なります。ここではその違いを解説します。

一言で言うと、「`<*>`は（`<$>`と同様に）あくまでも**純粋な関数**を`IO`（命令）の結果に対して適用するためのものであることに対して、`>>=`は**`IO`（命令）を返す関数**を別の`IO`（命令）の結果に対して適用するものである」という点が異なります。そこに大きな隔たりがあります。

「なぜ`putStrLn <$> getLine`と書いても`putStrLn`は実行されないのか」を説明した節で挙げた例を思い出してください。

```haskell
putStrLn =<< getLine
```

上記の「`getLine`でユーザーから入力してもらった文字列を`putStrLn`で出力する」という命令を`<$>`や`<*>`でも作ってみようとして、

```haskell
putStrLn <$> getLine
```

...と書いても、`IO ()`ではなく`IO (IO ())`が返されてしまい、その内側の`IO`にあたる`getLine`を実行するだけにとどまってしまう、という問題があるのでした。

同じことが`<*>`でも起こります。2つの文字列を受け取り、それらを結合して`putStrLn`する命令を返す関数を例にします:

```haskell
putTwoLines :: String -> String -> IO ()
putTwoLines s1 s2 = putStrLn $ s1 ++ s2
```

これを、`<$>`と`<*>`を組み合わせて、`getLine`を2回実行した結果に対して使用してみます:

```haskell
ghci> putTwoLines <$> getLine <*> getLine
123 -- ここはユーザーによる入力
456 -- ここはユーザーによる入力
ghci>
```

`putStrLn <$> getLine`と書いたときと同様に、`<$>`と`<*>`、それぞれの右辺に渡した`getLine`を実行することはできたのですが、`putTwoLines`を実行することはできませんでした。やはりこれは、`putStrLn <$> getLine`を実行したときと同じ現象です。`<$>`も`<*>`もどちらも、`IO (IO ())`を`IO ()`に変えることができないのです。

今回のようなケースを`>>=`で修正する場合、次のように書けば良いでしょう:

```haskell
-- もちろん`do`を使って書いた方が読みやすいケースですが、
-- 今回は`do`を使ったバージョンは割愛します。やってみてください！
ghci> getLine >>= (\s1 -> getLine >>= (\s2 -> putTwoLines s1 s2))
123 -- ここはユーザーによる入力
456 -- ここはユーザーによる入力
123456
ghci>
```

あるいは、いっそのこと`putTwoLines`における文字列を結合する部分、すなわち`++`する部分を抜き出して、

```haskell
ghci> putStrLn =<< (++) <$> getLine <*> getLine
123 -- ここはユーザーによる入力
456 -- ここはユーザーによる入力
123456
ghci>
```

と書いてもいいでしょう。これならワンライナーでもまあまあ読みやすいですね！

話が逸れましたが、どちらにしても`getLine`を2回実行した結果を`putStrLn`に渡す際には、`=<<`を使用している点に注意してください。やっぱり命令の結果をまた別の命令を返す関数に渡すには、`=<<`が必須なのです。

### まとめ: `<$>`, `<*>`, `>>=`の使い分け

- `IO`（命令）が返す値に、関数（`a -> b`）を適用したい
    - その関数が返すのは`IO`（命令）？
        - YES =\> `>>=`か`do`を使おう
        - NO =\> その関数が受け取る引数の数は？
            - 1つだけ =\> `<$>`を使おう
            - 2つ以上 =\> `<$>`と`<*>`を組み合わせて使おう
            - どちらにしても、やっぱり`<$>`や`<*>`・`>>=`だと読みにくい！
                - =\> `do`（と`return`）を使おう
