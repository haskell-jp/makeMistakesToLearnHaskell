# `do`における変数への代入を抑える 2

課題5のアプリケーションを、`<-`を使わずに書き換えましょう。

## 必要な知識

### `fmap`, `<$>`を使って「命令」の結果に純粋な関数を適用する

従来、`IO`（命令）の結果に対して（`a -> IO b`というような型ではなく、`a -> b`という型の）普通の関数を実行するには、次のように`do`の中で左細い矢印`<-`を使って、一旦変数に代入する必要がありました。

```
do
    line <- getLine

    -- line 変数に代入して、length関数を実行してから何かする
    print (length line)
    -- あるいは、length関数を実行してから何もせずにそのまま返す
    return (length line)
```

課題19で紹介した`>>=`を使うことによって、`do`や代入する変数を用意する必要はなくなりましたが、`return`などの関数を使って、必ず何らかの形で`IO`（命令）に変換する必要がありました。

```
getLine >>= return . length
```

この変換を不要にするのが`fmap`、あるいはその演算子バージョンである`<$>`の役目です（実際のところ`<$>`の方がよく使われるので、ここからは`<$>`で説明します）。  
上記の例を書き換えてみると、こう👇なります。

```
length <$> getLine
```

順番が変わってしまっている点には、ご注意ください。  
`>>= return .`という部分が`<$>`に置き換わって、すっきりしましたね！

このように`<$>`は、**`IO`（命令）を実行した結果に対して、普通の、純粋な関数を実行する**命令を作るための演算子です。

そのことを裏付けるために、例のごとく`:t`で型定義を覗いてみましょう。

```
ghci> :t (<$>)
(<$>) :: Functor f => (a -> b) -> f a -> f b
```

おっと、`Monad`でもない、`Functor`という聞き慣れない型クラスの型変数が出てきました。  
`Functor`の説明は一旦置いておいて、前の課題と同様`TypeApplications`を使って型変数`f`を`IO`に置き換えて解釈しましょう。

```
ghci> :set -XTypeApplications
ghci> :t (<$>) @IO
(<$>) @IO :: (a -> b) -> IO a -> IO b
```

2つの引数と戻り値:

- 第1引数（左辺）: 普通の（入出力を行わない）関数 `a -> b`。
- 第2引数（右辺）の`IO a`: 第1引数の関数の引数と、同じ型の値を返す`IO`（命令）。
- 戻り値の`IO b`: 第1引数（左辺）の関数と、同じ型の値を返す命令。

`IO a`を`a -> b`で`IO b`に変換する演算子である、というのが伝わるでしょうか？  
`length <$> getLine`の例に当てはめると、`getLine`で「ユーザーから入力してもらった文字列」に対して、`length`関数を実行して得た文字列の長さを返す`IO`（命令）を作っていますね！

```
     length   <$>   getLine
     ^^^^^^         ^^^^^^^
[Char] -> Int      IO [Char]
^^^^^^    ^^^      ^^ ^^^^^^
  a        b       f    a
            \     /
             \   /
              \_/
              /\
            IO Int
            ^^ ^^^
            f   b
```

ここで重要なのは、第1引数である関数はあくまでも`a -> b`という型の、「普通の関数」として**扱われる**、という点です。  
`<$>`を`IO`を返す関数`a -> IO b`に対して使うと、**型エラーにはならず**、妙な動作になってしまう場合があるのでご注意ください。

例えば、`putStrLn <$> getLine`とGHCi上で書いた場合...

```
ghci> putStrLn <$> getLine
aaaaa -- ここはユーザーによる入力
```

`putStrLn =<< getLine`と書いたときと異なり、入力した文字列が`putStrLn`によって出力されなかったことにお気づきでしょうか？  
そう、`getLine`が実行されてユーザーから入力を得たものの、なぜかそれを受け取ったはずの`putStrLn`は実行されなかったのです...😱

#### なぜ`putStrLn <$> getLine`と書いても`putStrLn`は実行されないのか、あるいは型注釈を付けようという話

この理由については、難しい話になるので節を分けます。  
今回の課題を解くだけの目的では必要ないばかりか、あなたの今後のHaskeller人生で絶対に必要な知識でもないので、わからなかったら適当に飛ばしてください。

```
ghci> :t putStrLn <$> getLine
putStrLn <$> getLine :: IO (IO ())
```

`IO (IO ())`という、妙な型が返ってきました、`IO ()`を返す`IO`、つまり「命令を返す命令」とは一体何者なんでしょうか...？

この型に推論されたこと自体は、それぞれの関数の型を考えればごく自然なことです。

- `putStrLn`は`[Char] -> IO ()`という型で、
- `getLine`は`IO [Char]`という型で、
- `IO`に対する`<$>`は`(a -> b) -> IO a -> IO b`という型なので、
- 型変数`a`に`[Char]`、型変数`b`に`IO ()`が代入された。

そう、`IO ()`も、実態は単なる普通の型なので、普通に型推論され、普通に型変数に代入されます。  
これまで扱ってきた`Integer`や`Bool`、`[a]`などと変わらない、普通の型なのです。

型と言うことは何らかの値を表しているはずです。これまではっきりと説明してきませんでしたが、一体`IO`型の値は何を表しているのでしょう？  
`IO`は「命令」を表すオブジェクトです。

例えるなら、ほかのプログラミング言語で言うところの、「関数オブジェクト」に近いです。  
PythonやJavaScriptにおける関数オブジェクト、Rubyで言えば`Proc`クラスのオブジェクト、Javaで言うところの`Callable`インターフェースを実装したオブジェクトなどなど

ただし、ほかのプログラミング言語で言うところの、「関数オブジェクト」と異なり、引数を受け取りません。  
Haskellでは引数を受け取るのは、あくまでも普通の関数`a -> b`の役目なのです。  
`putStrLn`も引数に当たる`[Char]`は`[Char] -> IO ()`という型の「普通の関数」の引数として受け取っていますね。  
でも、普通の関数`a -> b`は、`IO`のように入出力処理が出来ません。  
なので入出力処理の部分は`IO`に任せているのです。  
ほかのプログラミング言語における「関数オブジェクト」は、自由に入出力が出来る、関数の戻り値になることが出来る、という点で、Haskellの`IO`と似ています。  
「`IO`は引数を受け取らない関数オブジェクト」とイメージしてください。

「関数オブジェクト」とよく似たこの`IO`は単なる値として扱えるので、Haskellにおける関数`a -> b`の結果`b`として返したり、`putStrLn <$> getLine`が返す`IO (IO ())`のように、`IO`を実行した結果として返すことができます。

で、その結果として返された`IO`はどうやって実行することができるのでしょうか？  
`main`関数やGHCiの中で評価されて（`>>=`や`>>`でつなげられてその部分を通ったとき）初めて実行される  
ほかのプログラミング言語の「関数オブジェクト」と異なり、実行するための演算子が明確でなく、わかりづらい

```
ghci> :t putStrLn <$> getLine
putStrLn <$> getLine :: IO (IO ())
ghci> returnedAction <- putStrLn <$> getLine
12345 -- ここはユーザーによる入力
ghci> :t returnedAction
returnedAction :: IO ()
ghci> returnedAction
12345
```

GHCiは、`putStrLn <$> getLine`という式を受け取ったとき、とりあず`IO (IO ())`の外側の `IO (...)`、つまりこの場合`getLine`に当たる「命令」を実行します。  
そして、その結果として`putStrLn <getLineが返した文字列>`という`IO ()`型の値（命令）を返しているのです。  
そのため、上記のように`putStrLn <$> getLine`から`<-`で（あるいは、`>>=`で）取り出した`IO ()`（上記で言うところの`returnedAction`）を直接GHCiに入力すれば、`putStrLn <getLineが返した文字列>`の部分も実行することができます。

<!-- 2019/08/07 今日はここまで -->

この、`putStrLn <$> getLine`と入力しても`putStrLn`が実行されない、という現象は、GHCiだけでなく、`main`関数に`putStrLn <$> getLine`と書いてしまった場合も同様に発生します。

```
main = putStrLn <$> getLine
```

というファイルを`not-echoed.hs`というファイルに保存して実行してみても、やはりGHCiで実行した場合と同様に、`getLine`に当たる部分しか実行されません。

```
shell> stack exec runhaskell not-echoed.hs
12345 # ここはユーザーによる入力
shell>
```

しかし、多くのHaskellerが行うように、この問題は`main`関数に型注釈をつけていれば、型エラーとして回避できます。  
`not-echoed.hs`を次のように書き換えてみましょう。

```
main :: IO ()
main = putStrLn <$> getLine
```

今度は以下のような型エラーが報告されるので、問題のある`putStrLn <$> getLine`は実行されるまでもありません。

```
shell> stack exec runhaskell not-echoed.hs
not-echoed.hs:2:8: error:
    ? Couldn't match type ‘IO ()’ with ‘()’
      Expected type: IO ()
        Actual type: IO (IO ())
    ? In the expression: putStrLn <$> getLine
      In an equation for ‘main’: main = putStrLn <$> getLine
  |
2 | main = putStrLn <$> getLine
  |        ^^^^^^^^^^^^^^^^^^^^
```

`main`関数のように、`let`や`where`を伴わないで定義された、同じモジュール内のどの関数からも参照できる関数を、「トップレベルに定義された関数」と言います。  
`main`関数だけでなく、ほかのトップレベルの`IO`型の値を返す関数（あるいは`IO`型の値そのもの）にも型注釈を付けていれば、この問題は大抵回避できます。  
一般に、トップレベルに定義する関数は、型注釈を書くことでインターフェースを明確にすることが望ましいとされています。  
なので、トップレベルの関数に型注釈を書くことは、この問題を回避する以外のメリットもあるので、なるべく書きましょう。  
当入門ではこれまで`main`の型注釈については省略してきたが、今後は`main`についても記載します。

### `<*>` を使って2個目以降の引数を「命令」の結果から渡す

#### `>>=`との違い

### `Monad`, `Applicative`, `Functor`の関係
