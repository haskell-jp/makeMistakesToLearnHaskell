# `do`における変数への代入を抑える 2

課題5のアプリケーションを、`<-`を使わずに書き換えましょう。

## 必要な知識

### `fmap`, `<$>`を使って「命令」の結果に純粋な関数を適用する

従来、`IO`（命令）の結果に対して（`a -> IO b`というような型ではなく、`a -> b`という型の）普通の関数を実行するには、次のように`do`の中で左細い矢印`<-`を使って、一旦変数に代入する必要がありました。

```
do
    line <- getLine

    -- line 変数に代入して、length関数を実行してから何かする
    print (length line)
    -- あるいは、length関数を実行してから何もせずにそのまま返す
    return (length line)
```

課題19で紹介した`>>=`を使うことによって、`do`や代入する変数を用意する必要はなくなりましたが、`return`などの関数を使って、必ず何らかの形で`IO`（命令）に変換する必要がありました。

```
getLine >>= return . length
```

この変換を不要にするのが`fmap`、あるいはその演算子バージョンである`<$>`の役目です（実際のところ`<$>`の方がよく使われるので、ここからは`<$>`で説明します）。  
上記の例を書き換えてみると、こう👇なります。

```
length <$> getLine
```

順番が変わってしまっている点には、ご注意ください。  
`>>= return .`という部分が`<$>`に置き換わって、すっきりしましたね！

このように`<$>`は、**`IO`（命令）を実行した結果に対して、普通の、純粋な関数を実行する**命令を作るための演算子です。

そのことを裏付けるために、例のごとく`:t`で型定義を覗いてみましょう。

```
ghci> :t (<$>)
(<$>) :: Functor f => (a -> b) -> f a -> f b
```

おっと、`Monad`でもない、`Functor`という聞き慣れない型クラスの型変数が出てきました。  
`Functor`の説明は一旦置いておいて、前の課題と同様`TypeApplications`を使って型変数`f`を`IO`に置き換えて解釈しましょう。

```
ghci> :set -XTypeApplications
ghci> :t (<$>) @IO
(<$>) @IO :: (a -> b) -> IO a -> IO b
```

2つの引数と戻り値:

- 第1引数（左辺）の`a -> b`: 普通の（入出力を行わない）関数 `a -> b`。
- 第2引数（右辺）の`IO a`: 第1引数の関数の引数と、同じ型の値を返す`IO`（命令）。
- 戻り値の`IO b`: 第1引数（左辺）の関数と、同じ型の値を返す命令。

`IO a`を`a -> b`で`IO b`に変換する演算子である、というのが伝わるでしょうか？  
`length <$> getLine`の例に当てはめると、`getLine`で「ユーザーから入力してもらった文字列」に対して、`length`関数を実行して得た文字列の長さを返す`IO`（命令）を作っていますね！

```
     length   <$>   getLine
     ^^^^^^         ^^^^^^^
[Char] -> Int      IO [Char]
^^^^^^    ^^^      ^^ ^^^^^^
  a        b       f    a
            \     /
             \   /
              \_/
              /\
            IO Int
            ^^ ^^^
            f   b
```

ここで重要なのは、第1引数である関数はあくまでも`a -> b`という型の、「普通の関数」として**扱われる**、という点です。  
`<$>`を`IO`を返す関数`a -> IO b`に対して使うと、**型エラーにはならず**、妙な動作になってしまう場合があるのでご注意ください。

例えば、`putStrLn <$> getLine`とGHCi上で書いた場合...

```
ghci> putStrLn <$> getLine
aaaaa -- ここはユーザーによる入力
```

`putStrLn =<< getLine`と書いたときと異なり、入力した文字列が`putStrLn`によって出力されなかったことにお気づきでしょうか？  
そう、`getLine`が実行されてユーザーから入力を得たものの、なぜかそれを受け取ったはずの`putStrLn`は実行されなかったのです...😱

#### なぜ`putStrLn <$> getLine`と書いても`putStrLn`は実行されないのか、あるいは型注釈を付けようという話

この理由については、難しい話になるので節を分けます。  
今回の課題を解くだけの目的では必要ないばかりか、あなたの今後のHaskeller人生で絶対に必要な知識でもないので、わからなかったら適当に飛ばしてください。

```
ghci> :t putStrLn <$> getLine
putStrLn <$> getLine :: IO (IO ())
```

`IO (IO ())`という、妙な型が返ってきました、`IO ()`を返す`IO`、つまり「命令を返す命令」とは一体何者なんでしょうか...？

この型に推論されたこと自体は、それぞれの関数の型を考えればごく自然なことです。

- `putStrLn`は`[Char] -> IO ()`という型で、
- `getLine`は`IO [Char]`という型で、
- `IO`に対する`<$>`は`(a -> b) -> IO a -> IO b`という型なので、
- 型変数`a`に`[Char]`、型変数`b`に`IO ()`が代入された。

そう、`IO ()`も、実態は単なる普通の型なので、普通に型推論され、普通に型変数に代入されます。  
これまで扱ってきた`Integer`や`Bool`、`[a]`などと変わらない、普通の型なのです。

型と言うことは何らかの値を表しているはずです。これまではっきりと説明してきませんでしたが、一体`IO`型の値は何を表しているのでしょう？  
`IO`は「命令」を表すオブジェクトです。

例えるなら、ほかのプログラミング言語で言うところの「関数オブジェクト」に近いです。  
PythonやJavaScriptにおける関数オブジェクト、Rubyで言えば`Proc`クラスのオブジェクト、Javaにおける`Callable`インターフェースを実装したオブジェクトなどなど

ただし、ほかのプログラミング言語で言うところの、「関数オブジェクト」と異なり、引数を受け取りません。  
Haskellでは引数を受け取るのは、あくまでも普通の関数`a -> b`の役目なのです。  
`putStrLn`も引数に当たる`[Char]`は`[Char] -> IO ()`という型の「普通の関数」の引数として受け取っていますね。

一方、普通の関数`a -> b`は、`IO`のように入出力処理が出来ません。  
なので入出力処理の部分は`IO`に任せているのです。

結果、ほかのプログラミング言語における「関数オブジェクト」は、自由に入出力ができる、関数の戻り値になることができる、という点で、Haskellの`IO`と似ています。  
従って、「`IO`は引数を受け取らない関数オブジェクト」というイメージで捉えてください。

以上の通り、「関数オブジェクト」とよく似たこの`IO`は単なる値として扱えるので、Haskellにおける関数`a -> b`の結果`b`として返したり、`putStrLn <$> getLine`が返す`IO (IO ())`のように、`IO`を実行した結果として返すことができます。

では、その結果として返された`IO`はどうやって実行することができるのでしょうか？  
`main`関数やGHCiの中で評価されて（`>>=`や`>>`でつなげられてその部分を通ったとき）初めて実行されます。  
ほかのプログラミング言語の「関数オブジェクト」と異なり、実行するための演算子が明確でなく、わかりづらい

```
ghci> :t putStrLn <$> getLine
putStrLn <$> getLine :: IO (IO ())
ghci> returnedAction <- putStrLn <$> getLine
12345 -- ここはユーザーによる入力
ghci> :t returnedAction
returnedAction :: IO ()
ghci> returnedAction
12345
```

GHCiは、`putStrLn <$> getLine`という式を受け取ったとき、とりあず`IO (IO ())`の外側の `IO (...)`、つまりこの場合`getLine`に当たる「命令」を実行します。  
そして、その結果として`putStrLn <getLineが返した文字列>`という`IO ()`型の値（命令）を返しているのです。  
そのため、上記のように`putStrLn <$> getLine`から`<-`で（あるいは、`>>=`で）取り出した`IO ()`（上記で言うところの`returnedAction`）を直接GHCiに入力すれば、`putStrLn <getLineが返した文字列>`の部分も実行することができます。

<!-- 2019/08/07 今日はここまで -->

`putStrLn <$> getLine`と書いても`putStrLn`の部分が実行されなかったのは、`getLine`が結果として返した`[Char]`を`putStrLn`で`IO ()`に変換した後、実行していなかったからなのです。

この、`putStrLn <$> getLine`と入力しても`putStrLn`が実行されない、という現象は、GHCiだけでなく、`main`関数に`putStrLn <$> getLine`と書いてしまった場合も同様に発生します。

```
main = putStrLn <$> getLine
```

というファイルを`not-echoed.hs`というファイルに保存して実行してみても、やはりGHCiで実行した場合と同様に、`getLine`に当たる部分しか実行されません。

```
shell> stack exec runhaskell not-echoed.hs
12345 # ここはユーザーによる入力
shell>
```

しかし、多くのHaskellerが行うように、この問題は`main`関数に型注釈をつけていれば、型エラーとして回避できます。  
`not-echoed.hs`を次のように書き換えてみましょう。

```
main :: IO ()
main = putStrLn <$> getLine
```

今度は以下のような型エラーが報告されるので、問題のある`putStrLn <$> getLine`は実行されるまでもありません。

```
shell> stack exec runhaskell not-echoed.hs
not-echoed.hs:2:8: error:
    ? Couldn't match type ‘IO ()’ with ‘()’
      Expected type: IO ()
        Actual type: IO (IO ())
    ? In the expression: putStrLn <$> getLine
      In an equation for ‘main’: main = putStrLn <$> getLine
  |
2 | main = putStrLn <$> getLine
  |        ^^^^^^^^^^^^^^^^^^^^
```

`main`関数のように、`let`や`where`を伴わないで定義された、同じモジュール内のどの関数からも参照できる関数を、「トップレベルに定義された関数」と言います。  
`main`関数だけでなく、ほかのトップレベルの`IO`型の値を返す関数（あるいは`IO`型の値そのもの）にも型注釈を付けていれば、この問題は大抵回避できます。  
一般に、トップレベルに定義する関数は、型注釈を書くことでインターフェースを明確にすることが望ましいとされています。  
なので、トップレベルの関数に型注釈を書くことは、この問題を回避する以外のメリットもあるので、なるべく書きましょう。  
当入門ではこれまで`main`の型注釈については省略してきましたが、今後は`main`についても記載します。

### `<*>`を使って2つ目以降の引数を「命令」の結果から渡す

`+`などの二項演算子といった、2つ以上の引数を受け取る関数の引数を、`IO`などの「命令」の結果から渡す場合、`<$>`だけではできません（理由は後述します）。

なので、下記のように`do`を使って書いていた場合、`<$>`と`<*>`を使って書き換えることができます。  

```
-- `getLine`を2回実行して、取得した2つの文字列を ++ で結合する
do
  line1 <- getLine
  line2 <- getLine
  return $ line1 ++ line2
```

```
(++) <$> getLine <*> getLine
```

すっきり！やっぱりワンライナーで書けましたね！  
（課題18で学習した「演算子を前置関数に変換する」方法を思い出してください！）

実行例

```
ghci> (++) <$> getLine <*> getLine
first half -- ここはユーザーによる入力
second half -- ここはユーザーによる入力
"first halfsecond half"
```

例のごとく、新しい関数を見つけたら型を見る、の精神で、`<*>`の型を覗いてみましょう。

```
ghci> :t (<*>)
(<*>) :: Applicative f => f (a -> b) -> f a -> f b
```

`Monad`, `Functor`と続いて、`Applicative`というまた見知らぬ型クラスが登場しました。  
これらの詳細は次の課題で行いますので、今はまた`TypeApplications`で`f`を`IO`に置き換えましょう。

```
ghci> :set -XTypeApplications
ghci> :t (<*>) @IO
(<*>) @IO :: IO (a -> b) -> IO a -> IO b
```

- 第1引数（左辺）の`IO (a -> b)`: 「普通の（入出力を行わない）関数 `a -> b`」を返す命令。
- 第2引数（右辺）の`IO a`: 「第1引数の命令が返す関数」の引数と同じ型`a`を返す命令。
- 戻り値の`IO b`: 「第1引数の命令が返す関数」の引数と同じ型`a`を返す命令。

第1引数の`IO (a -> b)`がかなり変わっている。`a -> b` を返す命令なんて一体どこから出てくるのか

その答えは、先ほどの`(++) <$> getLine <*> getLine`という式における`<*>`の左辺、`(++) <$> getLine`にあります。

```
ghci> :t (++) <$> getLine
(++) <$> getLine :: IO ([Char] -> [Char])
```

`IO ([Char] -> [Char])`、すなわち「『文字列を受け取って文字列を返す関数』を返す命令」が出てきました！

以下のように型が推論された結果です。  
（以下の図における型変数`a`, `b`, `f`は、すべて`<$>`における型変数を指しています。`++`に適用する型変数は、それらと区別するために`c`としました。`++`の型が`[c] -> [c] -> [c]`となっているのはそのためです）

```haskell
      (++)         <$>   getLine
     ^^^^^^              ^^^^^^^
[c] -> [c] -> [c]       IO [Char]
^^^    ^^^^^^^^^^       ^^ ^^^^^^
 a          b           f    a
            \          /
             \        /
              \______/
              /  \
            IO ([c] -> [c])
            ^^ ^^^^^^^^^^^^
            f       b
```

`++`のような2つ以上の引数を受け取る関数を`<$>`に渡した場合、必ずこのような型が現れます。  
Haskellでは2つ以上の引数を受け取る関数は`a -> b -> c`（カッコを補うと「`a -> (b -> c)`」）という型の、「引数を1つ受け取ると、『残りの引数を受け取る関数』を返す関数」で表現されるので、`<$>`を使った結果に「関数を返す命令」が現れるのは、ある意味当然なことなのです。

こうした場合に対応するのが`<*>`の役目です。  
改めて型宣言を思い出してみましょう。

```
ghci> :t (<*>) @IO
(<*>) @IO :: IO (a -> b) -> IO a -> IO b
```

2つ以上の引数を受け取る関数を`<$>`に渡した結果現れる、`IO (a -> b)`のような型の値を左辺に受け取ることがはっきりと書かれていますね。  
そして、右辺で受け取っているのは、また命令です。「『第1引数の命令が返す関数』の引数と同じ型`a`を返す命令」であることから、左辺に渡された命令が返す関数に渡されることが予期されます。  
結果、最終的に`<*>`が返すのは、やっぱり命令です。「『第1引数の命令が返す関数』の戻り値と同じ型`b`を返す命令」とあるとおり、やはり左辺に渡された命令が返す関数の結果をそのまま返す命令なんでしょう。

ここで出てきた`IO a`から結果となる値`a`を取り出して、`IO (a -> b)`の結果となる`a -> b`に渡すには、`IO (a -> b)`と`IO a`、両方を実行する必要があります。  
下記のような関数を書いて、実際に`<*>`が左辺の`IO (a -> b)`と右辺の`IO a`の両方を実行していることを確かめてみましょう。

```
-- 関数を返す前に`putStrLn`を実行する命令
returnDoubler :: IO (Integer -> Integer)
returnDoubler = do
  putStrLn "Returning a function"
  return (* 2)

-- 整数を返す前に`putStrLn`を実行する命令
return4 :: IO Integer
return4 = do
  putStrLn "Returning 4"
  return 4
```

```
ghci> returnDoubler <*> return4
Returning a function
Returning 4
8
```

`returnDoubler`に書いた`putStrLn`の後に、`return4`に書いた`putStrLn`が実行されましたね。  
そう、`<*>`は、左辺に渡した「関数を返す命令」を実行した後に、右辺に渡した「値を返す命令」を実行しているのです。

以上から、`<*>`は、`<$>`が返した「関数を返す`IO`（命令）」と、`<*>`の右辺に渡したもう一つの`IO`（命令）を**続けて実行する**ための演算子であることがわかります。

`<$>`は、あくまでも**1つの**命令に対して結果を関数に渡す役割である一方、`<*>`は、**2つ以上の**命令を、続けて実行して関数に渡す、ということを覚えておきましょう。

「2つ以上」と書いたとおり、当然3つ以上の引数を受け取る関数に対しても`<*>`は使えます。  
例えば、今回の課題で定義しておくと便利であろう、「元金と金利（単位はパーセント）、年数を受け取って、年数後の元金を返す」関数を定義して、それに対して`<*>`を使ってみます。

```
-- Ref: https://support.microsoft.com/ja-jp/help/141695/xl-how-to-calculate-compound-interest
yearlyRate :: Double -> Double -> Integer -> Double
yearlyRate principal interestRate years =
  principal * (1 + interestRate / 100) ^ years
```

試してましょう。

```
ghci> yearlyRate <$> return 100.0 <*> return 5.0 <*> return 2
110.25
```

できました！  
3つめの引数を渡すときも`<*>`を使って残りの命令を渡すだけです。これは4つめ以降の引数でも変わりません。

ちなみに、「適当な`IO`型の値（正確には`Monad`型クラスのインスタンスである型の値）を用意したい、でもいちいち考えるのが面倒くさい」と言うときは、上記のように`return`を使うと簡単です。

それから、上記の例は下記のように、関数を定義しないで直接各種演算子に対して`<$>`や`<*>`を使うことによっても実現できます。  
ただ、ご覧の通り前置記法で二項演算子を何重も書くのはさすがにつらいので、この例ではやめておいた方がいいでしょう。

```
ghci> (*) <$> return 100.0 <*> ((^) <$> ((1 +) <$> ((/ 100) <$> return 5.0)) <*> return 2)
```

あるいは、ラムダ式を使うのも一つの手です。

```
ghci> (\principal interestRate years -> principal * (1 + interestRate / 100.0) ^ years) <$> return 100 <*> return 5.0 <*> return 2
110.25
```

もっと冗長だけどわかりやすいやり方、すなわち`do`記法を使ったに立ち返って、

```
ghci> :{
ghci| do
ghci|   principal <- return 100.0
ghci|   interestRate <- return 5.0
ghci|   years <- return 2
ghci|   return $ principal * (1 + interestRate / 100) ^ years
ghci| :}
110.25
```

と書いても、できあがる「命令」の処理内容は全く変わりません。

これらの`do`や`<$>`・`<*>`などとの使い分けは、ソースコードの見た目が変わる以外の違いに、ほとんど関係がありません（`IO`以外の型の扱いやGHCの`Strict`という言語拡張を使った場合など、いろいろ例外はありますが割愛します）。  
適宜読みやすいと思う書き方を選んでください。個人的には、迷ったらより冗長な方にするのをおすすめします。

#### `<$>`はなぜ引数が2つ以上の場合には使えないのか

「後述する」と言って積み残した課題がありました。  
試しに`<$>`を引数が2つ以上の関数に対して使ってみて、型エラーになることを確認してみましょう。

```
ghci> (++) <$> getLine <$> getLine

<interactive>:16:1: error:
    ? Couldn't match expected type ‘String -> b’
                  with actual type ‘IO ([Char] -> [Char])’
    ? Possible cause: ‘(<$>)’ is applied to too many arguments
      In the first argument of ‘(<$>)’, namely ‘(++) <$> getLine’
      In the expression: (++) <$> getLine <$> getLine
      In an equation for ‘it’: it = (++) <$> getLine <$> getLine
    ? Relevant bindings include
        it :: IO b (bound at <interactive>:16:1)
```

`In the first argument of ‘(<$>)’, namely ‘(++) <$> getLine’`という行に注目してください。  
`<$>`を2回使っているのでわかりづらいですが、ここでは2つめの`<$>`についての型エラーが報告されています。  
左辺に渡した式`(++) <$> getLine`の型が間違っているのです。  
具体的には、左辺の型について、

- 期待している型: `String -> b`、すなわち「文字列を受け取ってなにかの（まだ決まっていない）型`b`の値を返す（普通の）関数」、に対して、
- 実際に渡された式の型: `IO ([Char] -> [Char])`、「『文字列を受け取って文字列を返す関数』を返す命令」となっている、

というエラーです。

このような型になった理由は、`(++) <$> getLine`という式の型が`IO ([Char] -> [Char])`となった理由について説明したとおりです。  
`<$>`はあくまでも1つの命令をを操作するための演算子であって、`<*>`のように、`IO ([Char] -> [Char])`と（右辺が返す）`IO [Char]`という2つの命令を「つなげる」ことができないのです。

#### `>>=`や`>>`との違い

課題19で学習した`>>=`と`>>`は、いずれも`<*>`と同様、2つの`IO`（命令）を**続けて実行**する`IO`（命令）を作るための演算子です。

課題19より

> まとめると、`>>`は、「両辺の命令を**続けて実行**して、右辺の命令の結果を返す命令」を作る演算子。  

> 「左辺の命令の実行結果を受け取って、右辺の『命令を返す関数』につなげて、**続けて実行**する命令」を返す演算子

そうした意味においていずれも用途は似ているのですが、それぞれ使用できる場面が異なります。  
ここでは、

hoge

### `Monad`, `Applicative`, `Functor`の関係

hoge
