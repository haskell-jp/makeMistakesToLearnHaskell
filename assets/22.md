# `IO`ä»¥å¤–ã§ã‚‚`do`ã‚’ä½¿ã†: Eitherç·¨

èª²é¡Œ21ã®ã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³ã‚’æ”¹è‰¯ã—ã¦ã€é€£æƒ³é…åˆ—ã«è©²å½“ã™ã‚‹è¦ç´ ãŒè¦‹ã¤ã‹ã‚‰ãªã‹ã£ãŸå ´åˆã«ã€ã©ã®é€£æƒ³é…åˆ—ã‹ã‚‰è¦‹ã¤ã‹ã‚‰ãªã‹ã£ãŸã®ã‹å‡ºåŠ›ã—ã¾ã—ã‚‡ã†ã€‚

<!-- TODO: Leftã®å ´åˆæ¨™æº–ã‚¨ãƒ©ãƒ¼å‡ºåŠ›ã«ã™ã‚‹ -->

1. ã‚³ãƒãƒ³ãƒ‰ãƒ©ã‚¤ãƒ³å¼•æ•°ã®ãƒªã‚¹ãƒˆã‚’å–å¾—ã—ã¾ã™ã€‚
2. ã‚³ãƒãƒ³ãƒ‰ãƒ©ã‚¤ãƒ³å¼•æ•°ã®ãƒªã‚¹ãƒˆã®é•·ã•ãŒ
    1. ã€Œ1ã€ã§ã‚ã‚Œã°ã€ãã®è¦ç´ ã‚’ç”¨ã„ã¦ã€èª²é¡Œ21ã¨åŒã˜4ã¤ã®é€£æƒ³é…åˆ—ã‹ã‚‰å¯¾å¿œã™ã‚‹è¦ç´ ã‚’æ¤œç´¢ã—ã¾ã™ã€‚
        1. ã€Œå¥½ããªæœç‰©ã€ã®é€£æƒ³é…åˆ—ã«è©²å½“ã™ã‚‹è¦ç´ ãŒãªã‹ã£ãŸå ´åˆã€ã€Œ`Fruit not found. He/She might like vegitables better.`ã€ã¨å‡ºåŠ›ã—ã€ã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³ã‚’çµ‚äº†ã—ã¾ã™ã€‚
        2. ã€Œç”Ÿå¹´æœˆæ—¥ã€ã®é€£æƒ³é…åˆ—ã«è©²å½“ã™ã‚‹è¦ç´ ãŒãªã‹ã£ãŸå ´åˆã€ã€Œ`Birthday not found. He/She might want to hide his/her age.`ã€ã¨å‡ºåŠ›ã—ã€ã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³ã‚’çµ‚äº†ã—ã¾ã™ã€‚
        3. ã€Œãƒ¡ãƒ¼ãƒ«ã‚¢ãƒ‰ãƒ¬ã‚¹ã€ã®é€£æƒ³é…åˆ—ã«è©²å½“ã™ã‚‹è¦ç´ ãŒãªã‹ã£ãŸå ´åˆã€ã€Œ`Mail address not found. He/She might be afraid of spams.`ã€ã¨å‡ºåŠ›ã—ã€ã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³ã‚’çµ‚äº†ã—ã¾ã™ã€‚
        4. ã€Œä½ã‚“ã§ã„ã‚‹éƒ½é“åºœçœŒã€ã®é€£æƒ³é…åˆ—ã«è©²å½“ã™ã‚‹è¦ç´ ãŒãªã‹ã£ãŸå ´åˆã€ã€Œ`Prefecture not found. Where does he/she live?`ã€ã¨å‡ºåŠ›ã—ã€ã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³ã‚’çµ‚äº†ã—ã¾ã™ã€‚
        5. 4ã¤ã®é€£æƒ³é…åˆ—**ã™ã¹ã¦**ã«è©²å½“ã™ã‚‹è¦ç´ ãŒã‚ã£ãŸå ´åˆã€ãã‚Œã‚‰ã‚’ã™ã¹ã¦æ¨™æº–å‡ºåŠ›ã«å‡ºåŠ›ã—ã¾ã™ ï¼ˆã“ã®å ´åˆã«ãŠã‘ã‚‹å‡ºåŠ›å½¢å¼ã¯èª²é¡Œ21ã¨åŒæ§˜ã§ã™ï¼‰ã€‚
    2. ãã‚Œä»¥å¤–ã®å ´åˆã¯ã€ã€Œ`Invalid arguments: <ã‚³ãƒãƒ³ãƒ‰ãƒ©ã‚¤ãƒ³å¼•æ•°ã®ãƒªã‚¹ãƒˆ>`ã€ã¨ã„ã†å½¢å¼ã®ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚’ä¾‹å¤–ã¨ã—ã¦ã‚¹ãƒ­ãƒ¼ã—ã€çµ‚äº†ã—ã¾ã™ã€‚

## å¿…è¦ãªçŸ¥è­˜

### `Either`ã§ã€Œå¤±æ•—ã®è©³ç´°ã€ã‚’è¡¨ç¾ã™ã‚‹

èª²é¡Œ17ã®ç›´å’Œå‹: ã€Œå€¤ã®ç¨®é¡ã«ã‚ˆã£ã¦ã€ä¿æŒã§ãã‚‹å€¤ã‚’åˆ‡ã‚Šæ›¿ãˆã‚‰ã‚Œã‚‹å‹ã€

`Maybe`ã¯ãã®ç›´å’Œå‹ã®æ€§è³ªã‚’åˆ©ç”¨ã—ã€å€¤ã‚³ãƒ³ã‚¹ãƒˆãƒ©ã‚¯ã‚¿ãƒ¼ãŒ`Just`ã®å ´åˆã®ã¿å€¤ã‚’æ ¼ç´ã§ãã‚‹ã‚ˆã†ã«ã™ã‚‹ã“ã¨ã§ã€å€¤ã‚’ã¨ã‚Œãªã‹ã£ãŸå ´åˆã®å€¤`Nothing`ã‚’è¡¨ç¾ã§ãã‚‹ã‚ˆã†ã«ã—ã¾ã—ãŸã€‚

```haskell
ghci> :i Maybe
data Maybe a = Nothing | Just a         -- Defined in â€˜GHC.Maybeâ€™
-- ... ä»¥ä¸‹ç•¥ ...
```

ã—ã‹ã—ã€ä»Šå›ã®èª²é¡Œã®ã‚ˆã†ã«ã€Œè¦ç´ ãŒè¦‹ã¤ã‹ã‚‰ãªã‹ã£ãŸå ´åˆã«ã€ã©ã®é€£æƒ³é…åˆ—ã‹ã‚‰è¦‹ã¤ã‹ã‚‰ãªã‹ã£ãŸã®ã‹ã€ã¨ã„ã†æƒ…å ±ã‚’å‡¦ç†ã™ã‚‹å ´åˆã¯ã€`Maybe`ã§ã¯ä¸ä¾¿ã§ã™ã€‚  
`Nothing`ã¯ã‚ãã¾ã§ã‚‚å‡¦ç†ãŒã€Œå¤±æ•—ã—ãŸã€ã¨ã„ã†æƒ…å ±ã—ã‹æŒã£ã¦ã„ãªã„ãŸã‚ã€ã€Œãªãœå¤±æ•—ã—ãŸã‹ã€ã€Œã©ã®ã‚ˆã†ã«å¤±æ•—ã—ãŸã‹ã€ã€æœ¬èª²é¡Œã®å ´åˆã€Œã©ã®é€£æƒ³é…åˆ—ã‚’æ¤œç´¢ã—ãŸéš›è¦‹ã¤ã‹ã‚‰ãªã‹ã£ãŸã‹ã€ã¨ã„ã£ãŸæƒ…å ±ã‚’æŒã¦ãªã„ã®ã§ã™ã€‚

ãã“ã§ã€ç›´å’Œå‹ã®ã€Œå€¤ã®ç¨®é¡ã«ã‚ˆã£ã¦ã€ä¿æŒã§ãã‚‹å€¤ã‚’åˆ‡ã‚Šæ›¿ãˆã‚‰ã‚Œã‚‹ã€ã¨ã„ã†æ€§è³ªã‚’åˆ©ç”¨ã—ã¦ã€ã€Œå¤±æ•—ã€ã‚’è¡¨ã™å€¤ã«ã‚‚å€¤ã‚’ä¿æŒã§ãã‚‹ã‚ˆã†ã«ã—ãŸã®ãŒ`Either`å‹ã§ã™ã€‚  
GHCiã§å®šç¾©ã‚’è¦‹ã¦ã¿ã¾ã—ã‚‡ã†ã€‚

```haskell
ghci> :i Either
data Either a b = Left a | Right b      -- Defined in â€˜Data.Eitherâ€™
-- ... ä»¥ä¸‹ç•¥ ...
```

`data Maybe a = ...`ã¨å®šç¾©ã•ã‚Œã¦ã„ã‚‹ã¨ãŠã‚Š`Maybe`ã®å‹å¼•æ•°ãŒ`a`ã®ä¸€ã¤ã ã‘ã ã£ãŸã®ã«å¯¾ã—ã¦ã€`Either`ã§ã¯`data Either a b = ...`ã¨å®šç¾©ã•ã‚Œã¦ã„ã‚‹ã¨ãŠã‚Šã€å‹å¼•æ•°ã‚’äºŒã¤ã¨ã‚‹ã“ã¨ã«æ³¨ç›®ã—ã¦ãã ã•ã„ã€‚  
å¢—ãˆãŸå‹å¼•æ•°ã¯ã€äºŒã¤ã®å€¤ã‚³ãƒ³ã‚¹ãƒˆãƒ©ã‚¯ã‚¿ãƒ¼`Left`ãƒ»`Right`ãã‚Œãã‚Œã§ä¸€ã¤ãšã¤ä½¿ç”¨ã•ã‚Œã¦ã„ã¾ã™ã€‚  
çµæœã€`Either`å‹ã®å€¤ã¯ã€`Left`ã®å ´åˆã¨`Right`ã®å ´åˆã«åˆ†ã‹ã‚Œã¦ã„ã¦ã€`Left`ã®å ´åˆã¯ä¸€ã¤ç›®ã®å‹å¼•æ•°`a`ã«æŒ‡å®šã—ãŸå€¤ã®ã¿ã‚’ã€`Right`ã®å ´åˆã¯äºŒã¤ç›®ã®å‹å¼•æ•°`b`ã«æŒ‡å®šã—ãŸå€¤ã®ã¿ã‚’ã¨ã‚‹ã“ã¨ã«ãªã£ã¦ã„ã¾ã™ã€‚

ã“ã®æ€§è³ªã‚’åˆ©ç”¨ã—ã¦ã€`Either`å‹ã¯é€šä¾‹ã€Œå¤±æ•—ã™ã‚‹ã‹ã‚‚çŸ¥ã‚Œãªã„é–¢æ•°ã€ã®çµæœã¨ã—ã¦è¿”ã™å€¤ã«ä½¿ç”¨ã•ã‚Œã¾ã™ã€‚  
å…·ä½“çš„ã«ã¯ãã†ã—ãŸé–¢æ•°ã¯`Left`ã‚’è¿”ã—ãŸå ´åˆã¯ã€Œå¤±æ•—ã—ãŸã€ã¨ã„ã†ã“ã¨ã‚’è¡¨ã—ã¦ã€å¤±æ•—ã®è©³ç´°ã¨ä¸€ç·’ã«è¿”ã—ã¾ã™ã€‚  
ãã—ã¦`Right`ã‚’è¿”ã—ãŸå ´åˆã¯ã€ŒæˆåŠŸã—ãŸã€ã¨ã„ã†ã“ã¨ã‚’è¡¨ã—ã¦ã€è©³ã—ã„å®Ÿè¡Œçµæœã¨ã¨ã‚‚ã«è¿”ã—ã¾ã™ã€‚  
ï¼ˆãªãœ`Left`ãŒã€Œå¤±æ•—ã€ã§`Right`ãŒã€ŒæˆåŠŸã€ãªã®ã‹ã¯å¾Œã»ã©ç•ªå¤–ç·¨ã§èª¬æ˜ã—ã¾ã™ï¼‰

### `Either`å‹ã‚’ä½¿ã†

ãã‚ãã‚å®Ÿéš›ã«`Either`å‹ã®å€¤ã‚’ä½œã£ã¦éŠã‚“ã§ã¿ã¾ã—ã‚‡ã†ï¼  
`Either`å‹ã®å€¤ã‚’ä½œã‚‹æœ€ã‚‚ç°¡å˜ãªæ–¹æ³•ã¯ã€ã‚‚ã¡ã‚ã‚“ã€å„ç¨®å€¤ã‚³ãƒ³ã‚¹ãƒˆãƒ©ã‚¯ã‚¿ãƒ¼ã€`Left`ã¨`Right`ã‚’ä½¿ã†æ–¹æ³•ã§ã™ã€‚

```haskell
ghci> :t Right 'r'
Right 'r' :: Either a Char
ghci> :t Left 'l'
Left 'l' :: Either Char b

ghci> Right 'r'
Right 'r'
ghci> Left 'l'
Left 'l'

ghci> Right 123
Right 123
ghci> Left 789
Left 789

ghci> Right True
Right True
ghci> Left True
Left True

ghci> Right [10, 20, 30]
Right [10,20,30]
ghci> Left [-10, 0, -20]
Left [-10,0,-20]

ghci> Right (123, 'r', True)
Right (123,'r',True)
ghci> Left (789, 'l', True)
Left (789,'l',True)
```

å‹å¼•æ•°ã§ä¸€èˆ¬åŒ–ã—ã¦ã„ã‚‹ã®ã§å½“ç„¶ã§ã™ãŒã€ã”è¦§ã®é€šã‚Šã€`Left`ã«ã‚‚`Right`ã«ã‚‚ã„ã‚ã„ã‚ãªå‹ã®å€¤ã‚’å…¥ã‚Œã‚‹ã“ã¨ãŒã§ãã¾ã™ã­ã€‚

`Maybe`ã¨åŒæ§˜ã€`Either`ã‚‚å½“ç„¶ãƒ‘ã‚¿ãƒ¼ãƒ³ãƒãƒƒãƒã§`Left`ãªã®ã‹`Right`ãªã®ã‹ã‚’ãƒã‚§ãƒƒã‚¯ã—ã¦ã€å€¤ã‚’å–ã‚Šå‡ºã™ã“ã¨ãŒã§ãã¾ã™ã€‚

```haskell
ghci> a = Left "left"
ghci> b = Right 999

ghci> :{
ghci| case a of
ghci|   Right _ -> error "This should not be executed!"
ghci|   Left val -> putStrLn $ "Left value: " ++ val
ghci| :}
Left value: left

ghci> :{
ghci| case b of
ghci|   Right val -> putStrLn $ "Right value: " ++ show val
ghci|   Left _ -> error "This should not be executed!"
ghci| :}
Right value: 999
```

`Left`ã¨`Right`ã«å…¥ã‚Œã‚‹å‹ãŒãã‚Œãã‚Œç•°ãªã‚‹å ´åˆã€ãŠäº’ã„ã®å‹ã‚’å…¥ã‚Œæ›¿ãˆã¦ä½¿ãŠã†ã¨ã—ã¦ã‚‚ã€å‹ã‚¨ãƒ©ãƒ¼ã«ãªã‚Šã¾ã™ã€‚

```haskell
ghci> import Data.Char

ghci> x = Right True :: Either Char Bool

ghci> :{
ghci| case x of
ghci|   Left t -> print $ not t
ghci|   Right c -> print $ toUpper c
ghci| :}

<interactive>:29:25: error:
    ? Couldn't match expected type â€˜Boolâ€™ with actual type â€˜Charâ€™
    ? In the first argument of â€˜notâ€™, namely â€˜tâ€™
      In the second argument of â€˜($)â€™, namely â€˜not tâ€™
      In the expression: print $ not t

<interactive>:30:30: error:
    ? Couldn't match expected type â€˜Charâ€™ with actual type â€˜Boolâ€™
    ? In the first argument of â€˜toUpperâ€™, namely â€˜câ€™
      In the second argument of â€˜($)â€™, namely â€˜toUpper câ€™
      In the expression: print $ toUpper c
```

ä¸Šè¨˜ã®`case`å¼ã§ã¯å®Ÿéš›ã®å€¤ãŒ`Either Char Bool`ã¨ã„ã†å‹ã§ã‚ã‚‹ã®ã«å¯¾ã—ã¦ã€`Right`ã®å‹ã‚’`Char`ã€`Left`ã®å‹ã‚’`Bool`ã¨ã—ã¦è§£é‡ˆã—ã¦ã—ã¾ã£ã¦ã„ã‚‹ãŒãŸã‚ã«ã€ä¸¡æ–¹ã®ç¯€ã§å‹ã‚¨ãƒ©ãƒ¼ã«ãªã£ã¦ã—ã¾ã£ã¦ã„ã¾ã™ã€‚  
`expected type`ã¨`actual type`ãŒãã‚Œãã‚Œã®å‹ã‚¨ãƒ©ãƒ¼ã§ã¡ã‚‡ã†ã©é€†ã«ãªã£ã¦ã„ã‚‹ç‚¹ã«æ³¨ç›®ã—ã¦ãã ã•ã„ã€‚

#### `Either`ã«ã‚‚`<$>`ãƒ»`<*>`ãƒ»`>>=`ãƒ»`do`ã‚’ä½¿ã†

å…ˆã»ã©èª¬æ˜ã—ãŸã¨ãŠã‚Šã€`Either`å‹ã®å€¤ã¯é€ä¸€ãƒ‘ã‚¿ãƒ¼ãƒ³ãƒãƒƒãƒã—ã¦å‡¦ç†ã™ã‚‹ã“ã¨ãŒã§ãã¾ã™ãŒã€`Maybe`ã®ã‚ˆã†ã«`<$>`ã‚„`<*>`ã€`>>=`ã‚’ä½¿ã£ã¦ç°¡æ½”ã«å‡¦ç†ã™ã‚‹ã“ã¨ã‚‚ã§ãã¾ã™ã€‚  
ãã†ã€`Either`ã‚‚`Functor`ãƒ»`Applicative`ãƒ»`Monad`ã®ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã§ã‚ã‚Šã€ã€Œæ–‡è„ˆã‚’æŒã£ãŸå€¤ã€ã®ä¸€æ—ãªã®ã§ã™ã€‚

ã©ã®ã‚ˆã†ãªã€Œæ–‡è„ˆã€ã§ã—ã‚‡ã†ï¼Ÿ  
ãã‚Œã¯ã€`Maybe`ã«ãŠã‘ã‚‹ã€Œ`Just`ã‹`Nothing`ã‹ã©ã†ã‹ã‚’ç¢ºèªã—ã¦ã€æ¬¡ã®è¡Œã‚’å®Ÿè¡Œã™ã‚‹ã‹ã©ã†ã‹æ±ºã‚ã‚‹ã€ã¨ã„ã†æ–‡è„ˆã‹ã‚‰ã€ç°¡å˜ã«é¡æ¨ã§ãã¾ã™ã€‚  
ãã†ã€ã€Œ`Left`ã‹`Right`ã‹ã©ã†ã‹ã‚’ç¢ºèªã—ã¦ã€æ¬¡ã®è¡Œã‚’å®Ÿè¡Œã™ã‚‹ã‹ã©ã†ã‹æ±ºã‚ã‚‹ã€ã¨ã„ã†æ–‡è„ˆã§ã™ã€‚

ä¾‹ãˆã°`<$>`ã‚’è©¦ã—ã¦ã¿ã¾ã—ã‚‡ã†ã€‚

```haskell
ghci> (* 2) <$> Right 123
Right 246
ghci> (* 2) <$> Left "error"
Left "error"
```

ã”è¦§ã®ã¨ãŠã‚Šã€

- å€¤ãŒ`Right`ã®å ´åˆã¯å·¦è¾ºã«æ¸¡ã—ãŸé–¢æ•°ã‚’`Right`ã®å€¤ã«å¯¾ã—ã¦å®Ÿè¡Œã—ã€çµæœã‚’ã¾ãŸ`Right`ã§åŒ…ã‚“ã§è¿”ã—ã€
- å€¤ãŒ`Left`ã®å ´åˆã¯å·¦è¾ºã«æ¸¡ã—ãŸé–¢æ•°ã‚’å®Ÿè¡Œã›ãšã€`Left`ã®å€¤ã‚’ãã®ã¾ã¾è¿”ã™

ã¨ã„ã†æŒ™å‹•ã«ãªã£ã¦ã„ã¾ã™ã€‚  
ä¾‹ãˆ`Left`ã®å‹ãŒã€å·¦è¾ºã«æ¸¡ã—ãŸé–¢æ•°ãŒå—ã‘å–ã‚Œã‚‹ã‚‚ã®ã§ã‚ã£ãŸã¨ã—ã¦ã‚‚ã€å€¤ãŒ`Left`ã®å ´åˆã¯é–¢æ•°ã¯é©ç”¨ã•ã‚Œã¾ã›ã‚“ã€‚ãã®ã¾ã¾`Left`ãŒè¿”ã‚Šã¾ã™ã€‚

```haskell
ghci> (* 2) <$> Left 123
Left 123
```

ã“ã‚Œã¯ã€`<*>`ã‚„`>>=`ãªã©ã«ã¤ã„ã¦ã‚‚åŒæ§˜ã§ã™ã€‚

```haskell
ghci> (*) <$> Right 12 <*> Right 3
Right 36
ghci> (*) <$> Left 12 <*> Right 3
Left 12
ghci> (*) <$> Right 12 <*> Left 3
Left 3
ghci> (*) <$> Left 12 <*> Left 3
Left 12
```

`Either`ã«ãŠã‘ã‚‹`<*>`ã¯ã€ã”è¦§ã®é€šã‚Šä¸¡è¾ºã®å€¤ãŒ`Right`ã®å ´åˆã®ã¿ã€é–¢æ•°ã‚’é©ç”¨ã—ã¦`Right`ã«åŒ…ã‚“ã çµæœã‚’è¿”ã—ã¾ã™ã€‚  
å¯¾ã—ã¦å·¦è¾ºã‹å³è¾ºã€ã©ã¡ã‚‰ã‹ã®å€¤ãŒ`Left`ã ã£ãŸå ´åˆã€å·¦ã‹ã‚‰é †ã«ã€æœ€åˆã«è¦‹ã¤ã‹ã£ãŸ`Left`ã®å€¤ã‚’ãã®ã¾ã¾è¿”ã—ã¾ã™ã€‚  
`Maybe`ã¨åŒæ§˜ã€ã€Œå¤±æ•—ã€ã®å ´åˆã¯ãã®å ´ã§å®Ÿè¡Œã‚’ä¸­æ–­ã—ã¦ãã‚Œã‚‹ã€ã¨ã„ã†ã‚¤ãƒ¡ãƒ¼ã‚¸ã§æ‰ãˆã¦ãã ã•ã„ã€‚

`>>=`ã‚‚`do`ã‚’ä½¿ã£ãŸä¾‹ã§ç¤ºã—ã¾ã—ã‚‡ã†ã€‚  
æ¨™æº–ã«ã¯`Either`å‹ã®å€¤ã‚’è¿”ã™é–¢æ•°ã¯ã‚ã¾ã‚Šãªã„ã®ã§ã€ã¾ãšã¯è‡ªåˆ†ã§ä½œã£ã¦ã¿ã¾ã™ğŸ‘‡

```haskell
import Data.Char

validateName :: String -> Either String String
validateName name =
  case name of
    [] -> Left "Empty name!"
    (first : _left) ->
      -- æœ€åˆã®1æ–‡å­—ç›®ãŒå¤§æ–‡å­—ã‹ã©ã†ã‹ãƒã‚§ãƒƒã‚¯
      if isUpper first
        then Right name -- ã“ã“ã¾ã§å•é¡Œãªã‘ã‚Œã°ãã®ã¾ã¾è¿”ã™
        else Left "Not capitalized name!"
```

ä½œã£ãŸ`validateName`é–¢æ•°ã‚’ä½¿ã£ã¦ã€å®Ÿéš›ã«`do`ã‚’ã„ãã¤ã‹æ›¸ã„ã¦ã¿ã¾ã™ã€‚

```haskell
ghci> :{
ghci| do
ghci|   name <- validateName "Name" -- æ­£å¸¸ãªåå‰
ghci|   validateName "" -- ã“ã“ã§ç©ºæ–‡å­—åˆ—ã«ã‚ˆã‚‹ã‚¨ãƒ©ãƒ¼ã«ãªã‚‹
ghci|   validateName ("lower chars " ++ name) -- æ­£å¸¸ãªåå‰ã‚’æ›¸ãæ›ãˆã¦ã‚¨ãƒ©ãƒ¼ã‚’èµ·ã“ã™
ghci| :}
Left "Empty name!"
```

```haskell
ghci> :{
ghci| do
ghci|   name <- validateName "Name" -- æ­£å¸¸ãªåå‰
ghci|   validateName ("lower chars " ++ name) -- ã“ã“ã§æ­£å¸¸ãªåå‰ã‚’æ›¸ãæ›ãˆã¦ã‚¨ãƒ©ãƒ¼ã‚’èµ·ã“ã™
ghci|   validateName "" -- ç©ºæ–‡å­—åˆ—ã«ã‚ˆã‚‹ã‚¨ãƒ©ãƒ¼ã«ãªã‚‹
ghci| :}
Left "Not capitalized name!"
```

```haskell
ghci> :{
ghci| do
ghci|   name <- validateName "Name" -- æ­£å¸¸ãªåå‰
ghci|   validateName ("Capitalized " ++ name) -- æ›¸ãæ›ãˆã‚‹ãŒã‚¨ãƒ©ãƒ¼ã‚’èµ·ã“ã•ãªã„åå‰ã«
ghci| :}
Right "Capitalized Name"
```

ä¸‰ã¤ã®ä¾‹ã‚’æ¯”ã¹ã¦ã¿ã¦ãã ã•ã„ã€‚`validateName`ãŒ`Left`ã‚’è¿”ã—ãŸè¡Œã§ã€`do`ã¯`Left`ã®å€¤ã‚’ãã®ã¾ã¾è¿”ã—ã¦ã„ã‚‹ã“ã¨ãŒã‚ã‹ã‚Šã¾ã™ã­ã€‚  
æœ€å¾Œã®ä¾‹ã®ã¨ãŠã‚Šã€`do`ã®æœ€å¾Œã®è¡Œã¾ã§`Right`ãŒè¿”ã‚Šç¶šã‘ã‚‹ã¨`Right`ã®å€¤ãŒè¿”ã‚‹ã‚ˆã†ã«ãªã£ã¦ã„ã¾ã™ã€‚  
`Maybe`ã«ãŠã‘ã‚‹`do`ãŒã€é€”ä¸­ã®è¡Œã§`Nothing`ãŒè¿”ã£ãŸã¨ãæ®‹ã‚Šã®å®Ÿè¡Œã‚’ã‚„ã‚ã¦`Nothing`ã‚’è¿”ã—ã¦ã„ãŸã®ã«å¯¾ã—ã€`Either`ã«ãŠã‘ã‚‹`do`ã§ã¯ã€`Left`ãŒè¿”ã£ãŸã¨ãã«å®Ÿè¡Œã‚’ã‚„ã‚ã‚‹ã ã‘ã§ãªãã€`Left`ã®å€¤ã‚’ãã®ã¾ã¾è¿”ã™ã®ãŒç‰¹å¾´ã§ã™ã­ã€‚

#### errorsãƒ‘ãƒƒã‚±ãƒ¼ã‚¸ã®`note`é–¢æ•°ã§ã€`Maybe`ã‹ã‚‰`Either`ã«å¤‰æ›ã™ã‚‹

ä»Šå›ã®èª²é¡Œã§ã¯ã€ã€Œé€£æƒ³é…åˆ—ã«è©²å½“ã™ã‚‹è¦ç´ ãŒè¦‹ã¤ã‹ã‚‰ãªã‹ã£ãŸå ´åˆã«ã€ã©ã®é€£æƒ³é…åˆ—ã‹ã‚‰è¦‹ã¤ã‹ã‚‰ãªã‹ã£ãŸã®ã‹ã€ã‚’è¡¨ç¤ºã™ã‚‹ã“ã¨ã«ãªã£ã¦ã„ã¾ã™ã€‚  
ãã®ãŸã‚ã€å‰å›ã®èª²é¡Œã§ä½¿ç”¨ã—ãŸ`Maybe`ã‚’è¿”ã™é–¢æ•°ï¼ˆ`Data.Map.Strict`ã®`lookup`é–¢æ•°ï¼‰ãŒè¿”ã™å€¤ã‚’`Either`ã«å¤‰æ›ã™ã‚‹é–¢æ•°ãŒã‚ã‚‹ã¨ã‚ˆã„ã§ã—ã‚‡ã†ã€‚

ã‚„ã‚Šæ–¹è‡ªä½“ã¯ã‚¿ã‚¤ãƒˆãƒ«ã©ãŠã‚Š[`errors`ãƒ‘ãƒƒã‚±ãƒ¼ã‚¸][1]ãªã©ãŒæä¾›ã™ã‚‹åŒæ§˜ã®é–¢æ•°ã‚’ä½¿ãˆã°è‰¯ã„ã®ã§ã™ãŒã€ãƒ‘ã‚¿ãƒ¼ãƒ³ãƒãƒƒãƒã®ç·´ç¿’ã‚‚å…¼ã­ã¦ã€è‡ªåˆ†ã§ä½œã£ã¦ã¿ã¾ã—ã‚‡ã†ã€‚  
èª²é¡Œ18ã§ç´¹ä»‹ã—ãŸã€ã€Œãƒ©ãƒ ãƒ€æŠ½è±¡ã‚„é–¢æ•°ã®å¼•æ•°ã§ã®ãƒ‘ã‚¿ãƒ¼ãƒ³ãƒãƒƒãƒã€ã‚’ä½¿ã„ã¾ã™ã€‚

[1]: http://hackage.haskell.org/package/errors

```haskell
maybeToEither :: a -> Maybe b -> Either a b
maybeToEither err Nothing = Left err
maybeToEither _ (Just x) = Right x
```

ç¬¬2å¼•æ•°ã«æ¸¡ã—ãŸ`Maybe`å‹ã®å€¤ã‚’ãƒã‚§ãƒƒã‚¯ã—ã¦ã€å€¤ãŒ`Nothing`ã§ã‚ã‚Œã°ç¬¬1å¼•æ•°ã«æ¸¡ã—ãŸå€¤ã‚’`Left`ã«åŒ…ã¿ã€ç¬¬2å¼•æ•°ã®å€¤ãŒ`Just`ã§ã‚ã‚Œã°ã€`Just`ã®å€¤ã‚’ä»Šåº¦ã¯`Right`ã«åŒ…ã¿ç›´ã—ã¦è¿”ã—ã¾ã™ã€‚

æ—©é€Ÿä½¿ã£ã¦ã¿ã¾ã—ã‚‡ã†ã€‚

```haskell
ghci> maybeToEither "error!" Nothing
Left "error!"

ghci> maybeToEither "error!" (Just "success!")
Right "success!"
```

å†’é ­ã§è§¦ã‚ŒãŸã¨ãŠã‚Šã€ã‚‚ã¡ã‚ã‚“`errors`ãƒ‘ãƒƒã‚±ãƒ¼ã‚¸ã‚’ã‚¤ãƒ³ã‚¹ãƒˆãƒ¼ãƒ«ã—ã¦ã€`Control.Error`ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã®`note`é–¢æ•°ã‚’ä½¿ãˆã°åŒã˜ã“ã¨ãŒã§ãã¾ã™ã€‚

```shell
shell> stack build errors
shell> stack exec ghci
```

```haskell
import Control.Error
ghci> note "error!" Nothing
Left "error!"

ghci> note "error!" (Just "success!")
Right "success!"
```

### ç•ªå¤–ç·¨: ãªãœ`Right`ãŒã€ŒæˆåŠŸã€ã‚’è¡¨ã™ã®ã‹ã€ã‚‚ã†å°‘ã—è©³ã—ã

â€»ç›´æ¥å½¹ã«ç«‹ã¤æƒ…å ±ã«ã¯ãªã‚‰ãªã•ãã†ãªã®ã§ã€ãƒ–ãƒ­ã‚°è¨˜äº‹ã§æ•æ‰ã™ã‚‹ï¼Ÿ

ãªãœã‹ã‚’ä¸€è¨€ã§è¨€ã†ã¨ã€`Either`å‹ã®å®šç¾©ä¸Šã€`Right`ã€ã™ãªã‚ã¡äºŒç•ªç›®ã®å€¤ã‚³ãƒ³ã‚¹ãƒˆãƒ©ã‚¯ã‚¿ãƒ¼ã«æ¸¡ã™å‹å¼•æ•°ã‚’ã€ŒæˆåŠŸã€ã‚’è¡¨ã™å€¤ã®å‹ã«ã—ãªã„ã¨ã€`Functor`ãƒ»`Applicative`ãƒ»`Monad`ã®ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã«ã™ã‚‹ã“ã¨ãŒã§ããªã„ã‹ã‚‰ã§ã™ã€‚

ä¸å¯èƒ½ã§ã‚ã‚‹ã“ã¨ã‚’å†ç¾ã™ã‚‹ãŸã‚ã«ã€`Either`ã¨åå‰ä»¥å¤–ã¯åŒã˜å®šç¾©ã®å‹ã‚’ä½œã£ã¦ã¿ã¾ã™ã€‚

```haskell
data MyEither a b = MyLeft a | MyRight b
```

ãã‚Œã‚’ã€ä¾‹ãˆã°`Functor`ã®ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã«ã—ã‚ˆã†ã¨ã—ã¦ã¿ã¾ã—ã‚‡ã†ã€‚  
`Functor`ã®ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã«ã™ã‚‹ã«ã¯`fmap`ãƒ¡ã‚½ãƒƒãƒ‰ã‚’å®Ÿè£…ã™ã‚‹å¿…è¦ãŒã‚ã‚Šã¾ã™ãŒã€ä»Šè¿°ã¹ãŸã„ã“ã¨ã¨ã¯é–¢ä¿‚ãŒãªã„ã®ã§`undefined`ã§çœç•¥ã—ã¾ã™ã€‚

```haskell
ghci> :{
ghci| instance Functor MyEither where
ghci|   fmap = undefined
ghci| :}

<interactive>:5:18: error:
    ? Expecting one more argument to â€˜MyEitherâ€™
      Expected kind â€˜* -> *â€™, but â€˜MyEitherâ€™ has kind â€˜* -> * -> *â€™
    ? In the first argument of â€˜Functorâ€™, namely â€˜MyEitherâ€™
      In the instance declaration for â€˜Functor MyEitherâ€™
```

ã‚¨ãƒ©ãƒ¼ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã®`Expected kind â€˜* -> *â€™, but â€˜MyEitherâ€™ has kind â€˜* -> * -> *â€™`ã¨ã„ã†ç®‡æ‰€ã«æ³¨ç›®ã—ã¦ãã ã•ã„ã€‚  
`Expected type`ã§ã¯ãªã`Expected kind`ã¨æ›¸ã‹ã‚Œã¦ã„ã‚‹ã¨ãŠã‚Šã€ã“ã‚Œã¯å‹ã‚¨ãƒ©ãƒ¼ã§ã¯ãªãã€èª²é¡Œ17ã«ã‚‚å‡ºã¦ããŸã€Œkindã‚¨ãƒ©ãƒ¼ã€ã¨å‘¼ã°ã‚Œã‚‹ã‚‚ã®ã§ã™ã€‚  
è¦ã™ã‚‹ã«`Functor`ã®ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã¨ãªã‚‹å‹ã¯ã€Œå‹å¼•æ•°ã‚’**ä¸€ã¤**ã¨ã‚‹å‹ï¼ˆkindãŒ`* -> *`ãªå‹ï¼‰ã€ã§ãªãã¦ã¯ãªã‚‰ãªã„ã®ã«å¯¾ã—ã¦ã€`MyEither`ã¯ã€Œå‹å¼•æ•°ã‚’**äºŒã¤**ã¨ã‚‹å‹ï¼ˆkindãŒ`* -> * -> *`ãªå‹ï¼‰ã€ã¨ãªã£ã¦ã„ã‚‹ã€ã¨ã„ã†ã‚¨ãƒ©ãƒ¼ã§ã™ã€‚

ã“ã‚Œã‚’å›é¿ã™ã‚‹ãŸã‚ã€kindã‚’ãã‚ãˆã‚‹ãŸã‚ã«`MyEither`ã«å‹å¼•æ•°ã‚’ã€Œä»»æ„ã®å‹ã€ã¨ã—ã¦ä¸€ã¤ä¸ãˆã¦ã¿ã¾ã™ã€‚

```haskell
ghci> :{
ghci| instance Functor (MyEither a) where
ghci|   fmap = undefined
ghci| :}
```

ä»Šåº¦ã¯kindã‚¨ãƒ©ãƒ¼ãŒèµ·ã“ã‚Šã¾ã›ã‚“ã§ã—ãŸã€‚  
ã—ã‹ã—ã€`MyEither`ã®äºŒã¤ã®å‹å¼•æ•°`a`ãƒ»`b`ãŒãã‚Œãã‚Œã©ã®ã‚ˆã†ã«ä½¿ã‚ã‚Œã‚‹ã‹ã‚’æ€ã„å‡ºã—ã¦ãã ã•ã„ã€‚

```haskell
data MyEither a b = MyLeft a | MyRight b
```

ãã†ã€`MyEither`ã€ãã—ã¦ãã®å…ƒãƒã‚¿ã§ã‚ã‚‹`Either`ã§ã¯ã€å¿…ãšç¬¬ä¸€å‹å¼•æ•°ãŒ`MyLeft`ï¼ˆ`Left`ï¼‰ã®å‹ã§ã€ç¬¬äºŒå‹å¼•æ•°ãŒ`MyRight`ï¼ˆ`Right`ï¼‰ã®å‹ã¨ã—ã¦ä½¿ã‚ã‚Œã‚‹ã“ã¨ãŒã€æ±ºã¾ã£ã¦ã„ã¾ã™ã€‚  
ãã—ã¦ã€å…ˆã»ã©ã®`instance Functor (MyEither a) ...`ã®è¡Œã§ã€kindã‚’åˆã‚ã›ã‚‹ãŸã‚ã«`(MyEither a)`ã¨æ›¸ã„ã¦å‹å¼•æ•°ã‚’ä¸€ã¤æ¸¡ã—ã¦ã—ã¾ã£ã¦ã„ã‚‹ã“ã¨ã‹ã‚‰ã€`Functor`å‹ã‚¯ãƒ©ã‚¹ã®ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã¨ã—ã¦æ¸¡ã•ã‚Œã‚‹å‹å¼•æ•°ï¼ˆ`fmap`ã®å‹æ³¨é‡ˆ`Functor f => (a -> b) -> f a -> f b`ã«ãŠã‘ã‚‹`f`ï¼‰ã«ã¯ã€äºŒã¤ç›®ã®å‹å¼•æ•°ã¨ã—ã¦æ¸¡ã™ã—ã‹ãªã„ã®ã§ã™ã€‚  
ãã®ãŸã‚ã€`MyRight`ã«æ¸¡ã™å‹å¼•æ•°ã®å€¤ã—ã‹`fmap`ã§ã¯æ“ä½œã§ããšã€`fmap`ã«æ¸¡ã—ãŸé–¢æ•°ã«ã‚ˆã£ã¦æ“ä½œã™ã‚‹æ–¹ã®å‹ã®å€¤ã‚’ã€ŒæˆåŠŸã€æ‰ãˆã‚‹ã¨ã€çµæœçš„ã«`Right`ãŒã€ŒæˆåŠŸã€ã‚’è¡¨ã™ã“ã¨ã«ãªã‚‹ã®ã§ã™ã€‚

`MyLeft`ã®å ´åˆã‚’ã€ŒæˆåŠŸã€ã¨è§£é‡ˆã—ã¦ã€`MyLeft`ã®å ´åˆã«æŒ‡å®šã—ãŸé–¢æ•°ã‚’é©ç”¨ã™ã‚‹`fmap`ã®å®Ÿè£…ã‚’æ›¸ã„ã¦ã¿ã‚‹ã¨ã€ã“ã®å•é¡ŒãŒä»Šåº¦ã¯å‹ã‚¨ãƒ©ãƒ¼ã¨ãªã£ã¦ç¾ã‚Œã¾ã™ã€‚

```haskell
ghci> :{
ghci| instance Functor (MyEither a) where
ghci|   fmap f (MyLeft  a) = MyLeft (f a)
ghci|   fmap _ (MyRight b) = MyRight b
ghci| :}

<interactive>:21:24: error:
    ? Couldn't match type â€˜bâ€™ with â€˜aâ€™
      â€˜bâ€™ is a rigid type variable bound by
        the type signature for:
          fmap :: forall a1 b. (a1 -> b) -> MyEither a a1 -> MyEither a b
        at <interactive>:21:3-6
      â€˜aâ€™ is a rigid type variable bound by
        the instance declaration
        at <interactive>:20:10-29
      Expected type: MyEither a b
        Actual type: MyEither b b
    ? In the expression: MyLeft (f a)
      In an equation for â€˜fmapâ€™: fmap f (MyLeft a) = MyLeft (f a)
      In the instance declaration for â€˜Functor (MyEither a)â€™
    ? Relevant bindings include
        a :: a (bound at <interactive>:21:19)
        f :: a1 -> b (bound at <interactive>:21:8)
        fmap :: (a1 -> b) -> MyEither a a1 -> MyEither a b
          (bound at <interactive>:21:3)

<interactive>:21:34: error:
    ? Couldn't match expected type â€˜a1â€™ with actual type â€˜aâ€™
      â€˜a1â€™ is a rigid type variable bound by
        the type signature for:
          fmap :: forall a1 b. (a1 -> b) -> MyEither a a1 -> MyEither a b
        at <interactive>:21:3-6
      â€˜aâ€™ is a rigid type variable bound by
        the instance declaration
        at <interactive>:20:10-29
    ? In the first argument of â€˜fâ€™, namely â€˜aâ€™
      In the first argument of â€˜MyLeftâ€™, namely â€˜(f a)â€™
      In the expression: MyLeft (f a)
    ? Relevant bindings include
        a :: a (bound at <interactive>:21:19)
        f :: a1 -> b (bound at <interactive>:21:8)
        fmap :: (a1 -> b) -> MyEither a a1 -> MyEither a b
          (bound at <interactive>:21:3)
```

hoge

`Applicative`ã‚„`Monad`ã®ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã‚’å®šç¾©ã—ã‚ˆã†ã¨ã—ãŸå ´åˆã‚‚ã€åŒã˜å•é¡ŒãŒèµ·ã“ã‚Šã¾ã™ã€‚  
ã“ã®ã‚ˆã†ã«ã€ç¾åœ¨ã®Haskellã®ä»•æ§˜ä¸Šã€hoge

â€»`newtype`ã‚’ä½¿ã†ã¨ã„ã†æ–¹æ³•ã‚‚ã‚ã‚Šã¾ã™ãŒã€çµæœçš„ã«åˆ¥ã®å‹ã‚’ä½œã‚‹ã“ã¨ã«ãªã‚‹ã—ã€ã¾ã å½“å…¥é–€ã§ã¯`newtype`ã‚’è§£èª¬ã—ã¦ã„ãªã„ã®ã§ã€ã“ã“ã§ã¯çœç•¥ã—ã¾ã™ã€‚

### ç•ªå¤–ç·¨: è¦‹ã¤ã‹ã‚‰ãªã‹ã£ãŸé€£æƒ³é…åˆ—ã™ã¹ã¦ã‚’åˆ—æŒ™ã™ã‚‹

[digestive-functors][2]ãªã©ã€åŒã˜ã“ã¨ã‚’å®Ÿç¾ã™ã‚‹ãƒ‘ãƒƒã‚±ãƒ¼ã‚¸ã¯ã„ã‚ã„ã‚ã‚ã‚‹ã‚ˆã†ã§ã™ãŒã€ã“ã“ã§ã¯è‡ªåˆ†ã§ä½œã£ã¦ã¿ã¾ã—ã‚‡ã†ã€‚

[2]: http://hackage.haskell.org/package/digestive-functors

```haskell
hoge :: Hoge a => a -> a -> a
hoge :: Hoge -> Hoge -> Hoge
```

hoge
