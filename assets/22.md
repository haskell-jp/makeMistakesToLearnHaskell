# `IO`以外でも`do`を使う: Either編

課題hoge(21?)のアプリケーションを改良して、連想配列に該当する要素が見つからなかった場合に、どの連想配列から見つからなかったのか出力しましょう。

1. コマンドライン引数のリストを取得します。
2. コマンドライン引数のリストの長さが
    1. 「1」であれば、その要素を用いて、課題hoge(21?)と同じ、3つの連想配列から対応する要素を検索します。
        1. 「名前からIDを割り出す連想配列」に該当する要素がなかった場合、「`ID not found. Who is that person?`」と出力し、アプリケーションを終了します。
        2. 「好きな果物」の連想配列に該当する要素がなかった場合、「`Fruit not found. He/She might like vegitables better.`」と出力し、アプリケーションを終了します。
        3. 「生年月日」の連想配列に該当する要素がなかった場合、「`Birthday not found. He/She might want to hide his/her age.`」と出力し、アプリケーションを終了します。
        4. 2つの連想配列**すべて**に該当する要素があった場合、それらをすべて標準出力に出力します （この場合における出力形式は課題21と同様です）。
    2. それ以外の場合は、「`Invalid arguments: <コマンドライン引数のリスト>`」という形式のメッセージを例外としてスローし、終了します。

## 必要な知識

### `Either`で「失敗の詳細」を表現する

今回の課題は、課題hoge(17?)で紹介した「直和型」のある意味での代表、`Either`型を用いて解いてください。ということで、直和型について軽く復習します。直和型は 「値の種類によって、保持できる値を切り替えられる型」なのでした。そして`Maybe`型も直和型の1つで、`Maybe`型はその直和型の性質を利用し、値コンストラクターが`Just`の場合のみ値を格納できるようにすることで、値をとれなかった場合の値`Nothing`を表現できるようにしたのでした:

```haskell
ghci> :i Maybe
data Maybe a = Nothing | Just a         -- Defined in ‘GHC.Maybe’
-- ... 以下略 ...
```

しかし、今回の課題のように「要素が見つからなかった場合に、どの連想配列から見つからなかったのか」という情報を処理する場合は、`Maybe`では不便です。`Nothing`はあくまでも処理が「失敗した」という情報しか持っていないため、「なぜ失敗したか」「どのように失敗したか」、本課題の場合「どの連想配列を検索した際見つからなかったか」といった情報を持てないのです。

そこで、直和型の「値の種類によって、保持できる値を切り替えられる」という性質を利用して、「失敗」を表す値にも値を保持できるようにしたのが`Either`型です。GHCiで定義を見てみましょう:

```haskell
ghci> :i Either
data Either a b = Left a | Right b      -- Defined in ‘Data.Either’
-- ... 以下略 ...
```

`Maybe`型の型引数が`a`の1つだけだったのに対して、`Either`では`data Either a b = ...`と定義されているとおり、型引数を2つとることに注目してください。増えた型引数は、2つの値コンストラクター`Left`・`Right`それぞれで1つずつ使用されています。結果、`Either`型の値は、`Left`の場合と`Right`の場合に分かれていて、`Left`の場合は1つ目の型引数`a`に指定した値のみを、`Right`の場合は2つ目の型引数`b`に指定した値のみをとることになっています。

この性質を利用して、`Either`型は通例「失敗するかも知れない関数」の結果として返す値に使用されます。具体的には、そうした関数は`Left`を返した場合は「失敗した」ということを表して、失敗の詳細と一緒に返します。そして`Right`を返した場合は「成功した」ということを表して、詳しい実行結果とともに返します[^1]。

[^1]: なぜ`Left`が「失敗」で`Right`が「成功」なのかは別途解説します。端的に言えば「[Eitherでは何故右に正しい結果が入るのか](2)」という記事の[最後の方](3)で言及していることを、具体例を持って説明する予定です。恐らくHaskell-jp Blogに記事を上げるでしょう。

[2]: https://qiita.com/matsu4ki/items/c5519f6d039d1a1b461a
[3]: https://qiita.com/matsu4ki/items/c5519f6d039d1a1b461a#haskell%E3%81%AE%E4%BB%95%E6%A7%98%E3%81%AB%E3%81%A4%E3%81%84%E3%81%A6%E8%AA%BF%E3%81%B9%E3%82%8B

### `Either`型を使う

そろそろ実際に`Either`型の値を作って遊んでみましょう！`Either`型の値を作る最も簡単な方法は、もちろん、各種値コンストラクター、`Left`と`Right`を使う方法です:

```haskell
ghci> :t Right 'r'
Right 'r' :: Either a Char
ghci> :t Left 'l'
Left 'l' :: Either Char b

ghci> Right 'r'
Right 'r'
ghci> Left 'l'
Left 'l'

ghci> Right 123
Right 123
ghci> Left 789
Left 789

ghci> Right True
Right True
ghci> Left True
Left True

ghci> Right [10, 20, 30]
Right [10,20,30]
ghci> Left [-10, 0, -20]
Left [-10,0,-20]

ghci> Right (123, 'r', True)
Right (123,'r',True)
ghci> Left (789, 'l', True)
Left (789,'l',True)
```

型引数で一般化しているので当然と言えば当然ですが、ご覧の通り、`Left`にも`Right`にもいろいろな型の値を入れることができますね。

`Maybe`と同様、`Either`も当然パターンマッチで`Left`なのか`Right`なのかをチェックして、値を取り出すことができます:

```haskell
ghci> a = Left "left"
ghci> b = Right 999

ghci> :{
ghci| case a of
ghci|   Right _ -> error "This should not be executed!"
ghci|   Left val -> putStrLn $ "Left value: " ++ val
ghci| :}
Left value: left

ghci> :{
ghci| case b of
ghci|   Right val -> putStrLn $ "Right value: " ++ show val
ghci|   Left _ -> error "This should not be executed!"
ghci| :}
Right value: 999
```

`Left`と`Right`に入れる型がそれぞれ異なる場合、お互いの型を入れ替えて使おうとしても、型エラーになります。

```haskell
ghci> import Data.Char

ghci> x = Right True :: Either Char Bool

ghci> :{
ghci| case x of
ghci|   Left t -> print $ not t
ghci|   Right c -> print $ toUpper c
ghci| :}

<interactive>:29:25: error:
    ? Couldn't match expected type ‘Bool’ with actual type ‘Char’
    ? In the first argument of ‘not’, namely ‘t’
      In the second argument of ‘($)’, namely ‘not t’
      In the expression: print $ not t

<interactive>:30:30: error:
    ? Couldn't match expected type ‘Char’ with actual type ‘Bool’
    ? In the first argument of ‘toUpper’, namely ‘c’
      In the second argument of ‘($)’, namely ‘toUpper c’
      In the expression: print $ toUpper c
```

上記の`case`式では実際の値が`Either Char Bool`という型であるのに対して、`Right`の型を`Char`、`Left`の型を`Bool`として取り扱っているため、両方の節で型エラーになってしまっています。表示された2つの型エラーにおける`expected type`と`actual type`が、それぞれでちょうど逆になっている点に注目してください。

#### `Either`にも`<$>`・`<*>`・`>>=`・`do`を使う

先ほど説明したとおり、`Either`型の値は逐一パターンマッチして処理することができますが、`Maybe`のように`<$>`や`<*>`、`>>=`を使って簡潔に処理することもできます。そう、`Either`も`Functor`・`Applicative`・`Monad`のインスタンスであり、「文脈を持った値」の一族なのです。

ではどのような「文脈」なのでしょう？それは、`Maybe`における「`Just`か`Nothing`かどうかを確認して、次の行を実行するかどうか決める」文脈ととてもよく似ています。具体的には、「`Left`か`Right`かどうかを確認して、次の行を実行するかどうか決める」という文脈です。

例えば`<$>`を試してみましょう:

```haskell
ghci> (* 2) <$> Right 123
Right 246
ghci> (* 2) <$> Left "error"
Left "error"
```

ご覧のとおり、

- 値が`Right`の場合は左辺に渡した関数を`Right`の値に対して実行し、結果をまた`Right`で包んで返し、
- 値が`Left`の場合は左辺に渡した関数を実行せず、`Left`の値をそのまま返す

という挙動になっています。例え`Left`の型が、左辺に渡した関数が受け取れるものであったとしても、値が`Left`の場合は関数は適用されません。そのまま`Left`が返ります。

```haskell
ghci> (* 2) <$> Left 123
Left 123
```

これは、`<*>`や`>>=`などについても同様です。

```haskell
ghci> (*) <$> Right 12 <*> Right 3
Right 36
ghci> (*) <$> Left 12 <*> Right 3
Left 12
ghci> (*) <$> Right 12 <*> Left 3
Left 3
ghci> (*) <$> Left 12 <*> Left 3
Left 12
```

`Either`における`<*>`は、ご覧の通り両辺の値が`Right`の場合のみ、関数を適用して`Right`に包んだ結果を返します。対して左辺か右辺、どちらかの値が`Left`だった場合、左から順に、最初に見つかった`Left`の値をそのまま返します。`Maybe`と同様、「失敗」の場合はその場で実行を中断してくれる、というイメージで捉えてください。

`>>=`も`do`を使った例で示しましょう。標準には`Either`型の値を返す関数はあまりないので、まずは自分で作ってみます👇

```haskell
import Data.Char

validateName :: String -> Either String String
validateName name =
  case name of
    [] -> Left "Empty name!"
    (first : _left) ->
      -- 最初の1文字目が大文字かどうかチェック
      if isUpper first
        then Right name -- ここまで問題なければそのまま返す
        else Left "Not capitalized name!"
```

作った`validateName`関数を使って、実際に`do`をいくつか書いてみましょう:

```haskell
ghci> :{
ghci| do
ghci|   name <- validateName "Name" -- 正常な名前
ghci|   validateName "" -- ここで空文字列によるエラーになる
ghci|   validateName ("lower chars " ++ name) -- 正常な名前を書き換えてエラーを起こす
ghci| :}
Left "Empty name!"
```

```haskell
ghci> :{
ghci| do
ghci|   name <- validateName "Name" -- 正常な名前
ghci|   validateName ("lower chars " ++ name) -- ここで正常な名前を書き換えてエラーを起こす
ghci|   validateName "" -- 空文字列によるエラーになる
ghci| :}
Left "Not capitalized name!"
```

```haskell
ghci> :{
ghci| do
ghci|   name <- validateName "Name" -- 正常な名前
ghci|   validateName ("Capitalized " ++ name) -- 書き換えるがエラーを起こさない名前に
ghci| :}
Right "Capitalized Name"
```

3つの例を比べてみてください。`validateName`が`Left`を返した行で、`do`は`Left`の値をそのまま返していることがわかりますね。最後の例のとおり、`do`の最後の行まで`Right`が返り続けると`Right`の値が返るようになっています。`Maybe`における`do`が、途中の行で`Nothing`が返ったら残りをやめて`Nothing`を返していたのに対し、`Either`における`do`では、`Left`が返ったときに実行をやめるだけでなく、`Left`の値をそのまま返すのが特徴ですね。

#### errorsパッケージの`note`関数などで、`Maybe`から`Either`に変換する

今回の課題では、「連想配列に該当する要素が見つからなかった場合に、どの連想配列から見つからなかったのか」を表示することになっています。そのため、前回の課題で使用した`Maybe`を返す関数（`Data.Map.Strict`の`lookup`関数）が返す値を`Either`に変換する関数があるとよいでしょう。

やり方自体は[`errors`というパッケージ][4]などが提供する同様の関数を使えば良いのですが、パターンマッチの練習も兼ねて、自分で作ってみましょう。課題hoge(18?)で紹介した、「ラムダ抽象や関数の引数でのパターンマッチ」を使います:

[4]: http://hackage.haskell.org/package/errors

```haskell
maybeToEither :: a -> Maybe b -> Either a b
maybeToEither err Nothing = Left err
maybeToEither _ (Just x) = Right x
```

第2引数に渡した`Maybe`型の値をチェックして、値が`Nothing`であれば第1引数に渡した値を`Left`に包み、第2引数の値が`Just`であれば、`Just`の値を今度は`Right`に包み直して返します。

早速使ってみましょう:

```haskell
ghci> maybeToEither "error!" Nothing
Left "error!"

ghci> maybeToEither "error!" (Just "success!")
Right "success!"
```

もちろん、先程触れたとおり、`errors`パッケージをインストールして`Control.Error`モジュールの`note`関数を使えば同じことができます:

```shell
shell> stack build errors
shell> stack exec ghci
```

```haskell
import Control.Error
ghci> note "error!" Nothing
Left "error!"

ghci> note "error!" (Just "success!")
Right "success!"
```

### 番外編: なぜ`Right`が「成功」を表すのか、もう少し詳しく

※直接役に立つ情報にはならなさそうなので、ブログ記事で捕捉する？

なぜかを一言で言うと、`Either`型の定義上、`Right`、すなわち左から数えて2番目の値コンストラクターに渡す型引数を「成功」を表す値の型にしないと、`Functor`・`Applicative`・`Monad`のインスタンスにすることができないからです。

不可能であることを再現するために、`Either`と名前以外は同じ定義の型を作ってみます。

```haskell
data MyEither a b = MyLeft a | MyRight b
```

それを、例えば`Functor`のインスタンスにしようとしてみましょう。  
`Functor`のインスタンスにするには`fmap`メソッドを実装する必要がありますが、今述べたいこととは関係がないので`undefined`で省略します。

```haskell
ghci> :{
ghci| instance Functor MyEither where
ghci|   fmap = undefined
ghci| :}

<interactive>:5:18: error:
    ? Expecting one more argument to ‘MyEither’
      Expected kind ‘* -> *’, but ‘MyEither’ has kind ‘* -> * -> *’
    ? In the first argument of ‘Functor’, namely ‘MyEither’
      In the instance declaration for ‘Functor MyEither’
```

エラーメッセージの`Expected kind ‘* -> *’, but ‘MyEither’ has kind ‘* -> * -> *’`という箇所に注目してください。  
`Expected type`ではなく`Expected kind`と書かれているとおり、これは型エラーではなく、課題17にも出てきた「kindエラー」と呼ばれるものです。  
要するに`Functor`のインスタンスとなる型は「型引数を**1つ**とる型（kindが`* -> *`な型）」でなくてはならないのに対して、`MyEither`は「型引数を**二つ**とる型（kindが`* -> * -> *`な型）」となっている、というエラーです。

これを回避するため、kindをそろえるために`MyEither`に型引数を「任意の型」として1つ与えてみます。

```haskell
ghci> :{
ghci| instance Functor (MyEither a) where
ghci|   fmap = undefined
ghci| :}
```

今度はkindエラーが起こりませんでした。  
しかし、`MyEither`の二つの型引数`a`・`b`がそれぞれどのように使われるかを思い出してください。

```haskell
data MyEither a b = MyLeft a | MyRight b
```

そう、`MyEither`、そしてその元ネタである`Either`では、必ず第一型引数が`MyLeft`（`Left`）の型で、第二型引数が`MyRight`（`Right`）の型として使われることが、決まっています。  
そして、先ほどの`instance Functor (MyEither a) ...`の行で、kindを合わせるために`(MyEither a)`と書いて型引数を1つ渡してしまっていることから、`Functor`型クラスのインスタンスとして渡される型引数（`fmap`の型注釈`Functor f => (a -> b) -> f a -> f b`における`f`）には、二つ目の型引数として渡すしかないのです。  
そのため、`MyRight`に渡す型引数の値しか`fmap`では操作できず、`fmap`に渡した関数によって操作する方の型の値を「成功」捉えると、結果的に`Right`が「成功」を表すことになるのです。

`MyLeft`の場合を「成功」と解釈して、`MyLeft`の場合に指定した関数を適用する`fmap`の実装を書いてみると、この問題が今度は型エラーとなって現れます。

```haskell
ghci> :{
ghci| instance Functor (MyEither a) where
ghci|   fmap f (MyLeft  a) = MyLeft (f a)
ghci|   fmap _ (MyRight b) = MyRight b
ghci| :}

<interactive>:21:24: error:
    ? Couldn't match type ‘b’ with ‘a’
      ‘b’ is a rigid type variable bound by
        the type signature for:
          fmap :: forall a1 b. (a1 -> b) -> MyEither a a1 -> MyEither a b
        at <interactive>:21:3-6
      ‘a’ is a rigid type variable bound by
        the instance declaration
        at <interactive>:20:10-29
      Expected type: MyEither a b
        Actual type: MyEither b b
    ? In the expression: MyLeft (f a)
      In an equation for ‘fmap’: fmap f (MyLeft a) = MyLeft (f a)
      In the instance declaration for ‘Functor (MyEither a)’
    ? Relevant bindings include
        a :: a (bound at <interactive>:21:19)
        f :: a1 -> b (bound at <interactive>:21:8)
        fmap :: (a1 -> b) -> MyEither a a1 -> MyEither a b
          (bound at <interactive>:21:3)

<interactive>:21:34: error:
    ? Couldn't match expected type ‘a1’ with actual type ‘a’
      ‘a1’ is a rigid type variable bound by
        the type signature for:
          fmap :: forall a1 b. (a1 -> b) -> MyEither a a1 -> MyEither a b
        at <interactive>:21:3-6
      ‘a’ is a rigid type variable bound by
        the instance declaration
        at <interactive>:20:10-29
    ? In the first argument of ‘f’, namely ‘a’
      In the first argument of ‘MyLeft’, namely ‘(f a)’
      In the expression: MyLeft (f a)
    ? Relevant bindings include
        a :: a (bound at <interactive>:21:19)
        f :: a1 -> b (bound at <interactive>:21:8)
        fmap :: (a1 -> b) -> MyEither a a1 -> MyEither a b
          (bound at <interactive>:21:3)
```

hoge

`Applicative`や`Monad`のインスタンスを定義しようとした場合も、同じ問題が起こります。  
このように、現在のHaskellの仕様上、hoge

※`newtype`を使うという方法もありますが、結果的に別の型を作ることになるし、まだ当入門では`newtype`を解説していないので、ここでは省略します。
