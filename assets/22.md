# `IO`以外でも`do`を使う: Either編

課題21のアプリケーションを改良して、連想配列に該当する要素が見つからなかった場合に、どの連想配列から見つからなかったのか出力しましょう。

1. コマンドライン引数のリストを取得します。
2. コマンドライン引数のリストの長さが
    1. 「1」であれば、その要素を用いて、課題21と同じ4つの連想配列から対応する要素を検索します。
        1. 「好きな果物」の連想配列に該当する要素がなかった場合、「`Fruit not found. He/She might like vegitables better.`」と出力し、アプリケーションを終了します。
        2. 「生年月日」の連想配列に該当する要素がなかった場合、「`Birthday not found. He/She might want to hide his/her age.`」と出力し、アプリケーションを終了します。
        3. 「メールアドレス」の連想配列に該当する要素がなかった場合、「`Mail address not found. He/She might be afraid of spams.`」と出力し、アプリケーションを終了します。
        4. 「住んでいる都道府県」の連想配列に該当する要素がなかった場合、「`Prefecture not found. Where does he/she live?`」と出力し、アプリケーションを終了します。
        5. 4つの連想配列**すべて**に該当する要素があった場合、それらをすべて標準出力に出力します （この場合における出力形式は課題21と同様です）。
    2. それ以外の場合は、「`Invalid arguments: <コマンドライン引数のリスト>`」という形式のメッセージを例外としてスローし、終了します。

## 必要な知識

### `Either`で「失敗の詳細」を表現する

課題17の直和型: 「値の種類によって、保持できる値を切り替えられる型」

`Maybe`はその直和型の性質を利用し、値コンストラクターが`Just`の場合のみ値を格納できるようにすることで、値をとれなかった場合の値`Nothing`を表現できるようにした

```haskell
ghci> :i Maybe
data Maybe a = Nothing | Just a         -- Defined in ‘GHC.Maybe’
-- ... 以下略 ...
```

しかし、今回の課題のように「要素が見つからなかった場合に、どの連想配列から見つからなかったのか」という情報を処理する場合は、`Maybe`では不便です。  
`Nothing`はあくまでも処理が「失敗した」という情報しか持っていないため、「なぜ失敗したか」「どのように失敗したか」、本課題の場合「どの連想配列を検索した際見つからなかったか」といった情報を持てないのです。

そこで、直和型の「値の種類によって、保持できる値を切り替えられる」という性質を利用して、「失敗」を表す値にも値を保持できるようにしたのが`Either`型です。  
GHCiで定義を見てみましょう。

```haskell
ghci> :i Either
data Either a b = Left a | Right b      -- Defined in ‘Data.Either’
-- ... 以下略 ...
```

`data Maybe a = ...`と定義されているとおり`Maybe`の型引数が`a`の一つだけだったのに対して、`Either`では`data Either a b = ...`と定義されているとおり、型引数を二つとることに注目してください。  
増えた型引数は、二つの値コンストラクター`Left`・`Right`それぞれで一つずつ使用されています。  
結果、`Either`型の値は、`Left`の場合と`Right`の場合に分かれていて、`Left`の場合は一つ目の型引数`a`に指定した値のみを、`Right`の場合は二つ目の型引数`b`に指定した値のみをとることになっています。

この性質を利用して、`Either`型は通例「失敗するかも知れない関数」の結果として返す値に使用されます。  
具体的にはそうした関数は`Left`を返した場合は「失敗した」ということを表して、失敗の詳細と一緒に返します。  
そして`Right`を返した場合は「成功した」ということを表して、詳しい実行結果とともに返します。  
（なぜ`Left`が「失敗」で`Right`が「成功」なのかは後ほど`Either`に対する`<$>`などを紹介する際に説明します）

### `Either`型を使う

そろそろ実際に`Either`型の値を作って遊んでみましょう！  
`Either`型の値を作る最も簡単な方法は、当然各種値コンストラクター、`Left`と`Right`を使う方法です。

```haskell
ghci> :t Right 'r'
Right 'r' :: Either a Char
ghci> :t Left 'l'
Left 'l' :: Either Char b

ghci> Right 'r'
Right 'r'
ghci> Left 'l'
Left 'l'

ghci> Right 123
Right 123
ghci> Left 789
Left 789

ghci> Right True
Right True
ghci> Left True
Left True

ghci> Right [10, 20, 30]
Right [10,20,30]
ghci> Left [-10, 0, -20]
Left [-10,0,-20]

ghci> Right (123, 'r', True)
Right (123,'r',True)
ghci> Left (789, 'l', True)
Left (789,'l',True)
```

型引数で一般化しているので当然ですが、ご覧の通り、`Left`にも`Right`にもいろいろな型の値を入れることができますね。

`Maybe`と同様、`Either`も当然パターンマッチで`Left`なのか`Right`なのかをチェックして、値を取り出すことができます。

```haskell
ghci> a = Left "left"
ghci> b = Right 999

ghci> :{
ghci| case a of
ghci|   Right _ -> error "This should not be executed!"
ghci|   Left val -> putStrLn $ "Left value: " ++ val
ghci| :}
Left value: left

ghci> :{
ghci| case b of
ghci|   Right val -> putStrLn $ "Right value: " ++ show val
ghci|   Left _ -> error "This should not be executed!"
ghci| :}
Right value: 999
```

`Left`と`Right`に入れる型がそれぞれ異なる場合、当然お互いの型を入れ替えて使おうとしても、型エラーになります。

```haskell
ghci> import Data.Char

ghci> x = Right True :: Either Char Bool

ghci> :{
ghci| case x of
ghci|   Right c -> print $ toUpper c
ghci|   Left t -> print $ not t
ghci| :}

<interactive>:78:30: error:
    ? Couldn't match expected type ‘Char’ with actual type ‘Bool’
    ? In the first argument of ‘toUpper’, namely ‘c’
      In the second argument of ‘($)’, namely ‘toUpper c’
      In the expression: print $ toUpper c

<interactive>:79:25: error:
    ? Couldn't match expected type ‘Bool’ with actual type ‘Char’
    ? In the first argument of ‘not’, namely ‘t’
      In the second argument of ‘($)’, namely ‘not t’
      In the expression: print $ not t
```

上記の`case`式では実際の値が`Either Char Bool`という型であるのに対して、`Right`の型を`Char`、`Left`の型を`Bool`として解釈してしまっているがために、両方の節で型エラーになってしまっています。  
`expected type`と`actual type`がそれぞれの型エラーでちょうど逆になっている点に注目してください。

#### `Either`にも`<$>`・`<*>`・`>>=`・`do`を使う

先ほど説明したとおり、`Either`型の値は逐一パターンマッチして処理することができますが、`Maybe`のように`<$>`や`<*>`、`>>=`を使って簡潔に処理することもできます。  
そう、`Either`も`Functor`・`Applicative`・`Monad`のインスタンスであり、「文脈を持った値」の一族なのです。

どのような「文脈」でしょう？  
それは、`Maybe`における「`Just`か`Nothing`かどうかを確認して、次の行を実行するかどうか決める」という文脈から、簡単に類推できます。  
そう、

hoge

#### errorsパッケージで`Maybe`から`Either`に変換する

hoge

### 番外編: 見つからなかった連想配列すべてを列挙する

hoge
