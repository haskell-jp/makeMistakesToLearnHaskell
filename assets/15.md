# 処理を繰り返し実行する (2)

コマンドラインからファイル名のリストを受け取って、その中身をファイル名と一緒に出力するコマンドを作りましょう。

1. コマンドライン引数のリストを取得します。
2. コマンドライン引数のリストの各要素に対して、次の処理を実行します:
    1. 各要素である文字列を、標準出力にputStrLn関数で出力します。
    2. 各要素である文字列をファイルのパスとして解釈し、その中身を読みます。
    3. 読んだファイルの中身を、改行で区切ったリストに変換します。
    4. 改行で区切ったリストの各要素の先頭に、スペースを2文字分付け足します。
    5. 各要素の先頭にスペースを付けた文字列のリストを、再び改行文字で結合します。
    6. 再び結合した文字列を、そのままputStr関数で出力します。

## 入出力例

どのような動作をするのかこの説明だけでは分かりづらいと思うので、実行結果の例を示します。

### コマンドライン引数に何も与えなかったとき

```shell
shell> runhaskell 15.hs
shell>
```

※何も出力しないで終わる

### ファイルの名前を複数与えたとき

a.txt:

```
line 1 in a.txt
line 2 in a.txt
line 3 in a.txt
```

b.txt:

```
line 1 in b.txt
```

c.txt:

```
line 1 in c.txt
line 2 in c.txt
```

empty.txt:

```
```

※空のファイル

```shell
shell> runhaskell 15.hs a.txt b.txt empty.txt c.txt
a.txt
  line 1 in a.txt
  line 2 in a.txt
  line 3 in a.txt
b.txt
  line 1 in b.txt
empty.txt
c.txt
  line 1 in c.txt
  line 2 in c.txt
shell>
```

※何も出力しないで終わる

## 必要な知識

### `readFile`関数で、ファイルの中身をすべて読む

コマンドライン引数を取得する関数は課題hoge(13)で紹介したので、ここではファイルの中身を読む関数を学習しましょう。まずは例えば下記のようなコマンドで、読み込むファイルを作っておきましょう:

```
shell> echo "Read this file later!" > read-later.txt
```

```
ghci> readFile "read-later.txt"
"Read this file later!\n"
```

### `map`関数で、リストの各要素に対して「純粋な関数」を実行し、結果をまたリストに入れる

「高階関数」とは、「関数」を引数として受け取ったり、戻り値として「関数」を返すことができる関数です。  
ここでは、その中でも特によく使う（そのうちいくつかは今回の課題を解くのに使う）3つに絞って説明しましょう。

```
ghci> import Data.Char
ghci> toUpper 'a' -- シングルクォートで囲うこと！
'A'
```

`toUpper`を文字列に対して実行したい。

```
ghci> map toUpper "hello!"
"HELLO!"
```

リストの各要素、文字列の場合は各文字に対して`toUpper`関数を実行して、結果を入れた新しいリスト（文字の場合は文字列）を作る。

```
ghci> f x = x * 2 + 3
```

```
ghci> map f [2, 5, 10]
[7,13,23]
```

```
ghci> f 2
7
ghci> f 5
13
ghci> f 10
23
```

### ラムダ式で、その場限りの関数を定義する

`map`関数などを試すときに、いちいち名前の付いた関数を定義するのが面倒くさい、というときに

```
ghci> map (\x -> x * 2 + 3) [2, 5, 10]
[7,13,23]
```

バックスラッシュ、右細い矢印

「すごいHaskell楽しく学ぼう」曰く小文字の「λ」と遠くから見るとよく似ているかららしい。

```
ghci> (\x -> x * 2 + 3) 10
23
```

そのまま変数に代入すれば、関数として使用することもできるようになります。

```
ghci> f = (\x -> x * 2 + 3)
```

実際にはカッコで囲う必要があるのは、他の式との境界を明確にする必要がある場所だけ

```
ghci> f = \x -> x * 2 + 3
```

これらは同じ意味！

```
ghci> f = \x -> x * 2 + 3
ghci> f x = x * 2 + 3
```

ちなみに、引数が複数の場合、以下のようにバックスラッシュと右細い矢印の間に書く、引数名をスペースで区切ります。

```
ghci> f = \x y -> x * y + 3
```

```
ghci> f = \x y -> x * y + 3
ghci> f x y = x * y + 3
```

```
ghci> map (\i -> f 2 i) [2, 3, 5]
[7,9,13]
```

### NOTE: 用語の意味の確認（変更）

TODO: 「命令」が初めて出てくるセクションに移す

- 純粋な関数: 値を受け取って返すだけ。数学における「関数」に近い。「関数型プログラミング」における「関数」とはこれのこと。
    - `引数の型 -> 結果となる値の型`という型で表される。
    - `splitOn`
    - `toUpper`
    - `+`, `*` などの四則演算に使う演算子
- ただの値: 純粋な関数が返した結果となる値。何もしない。純粋な関数から返されるだけ。
    - `"hello"`
    - `True`
    - `1`
- 命令: 何かしら入出力処理を実行した上で、結果となる（ただの）値を返したり返さなかったりするもの。一般的には「アクション」と呼ばれることの方が多いかも。
    - ほかのプログラミング言語で言うと、「引数をとらない関数オブジェクト」が近い。
        - Javaでいうところの`Callable`, Rubyでいうところの（引数をとらない）`Proc`, JavaScriptでいうところの（引数をとらない）`Function`, etc.
        - Haskell以外の言語は、普通の関数の中で入出力処理ができるので。
    - `IO 結果となる（ただの）値の型`という型で表される。
    - `IO ()`という型で、「値を返さない命令」を表す。
    - `getLine`
    - `putStrLn "hello"`
- 「引数をとる命令」のように見えていたもの:
    - 「命令」を返す「純粋な関数」
    - 引数をとるのは純粋な関数の役目で、戻り値を（入出力処理を実行して）とってくるのが「命令」の役目。
    - `引数の型 -> IO 結果となる値の型`で表される。
    - `putStrLn`
    - `readFile`

### `for_`関数で、リストの各要素に対して「命令」を実行する

「命令」を返す関数を`map`で実行しようとしてみたら...

```
ghci> map putStrLn ["Hello, Everyone!", "How are you?", "I'm fine!"]

<interactive>:3:1: error:
    ? No instance for (Show (IO ())) arising from a use of ‘print’
    ? In a stmt of an interactive GHCi command: print it
```

```
ghci> :t map putStrLn ["Hello, Everyone!", "How are you?", "I'm fine!"]
map putStrLn ["Hello, Everyone!", "How are you?", "I'm fine!"]
  :: [IO ()]
```

`[IO ()]`は`IO ()`じゃない！リスト`[]`に包まれている！

実行するには？
リストから取り出す。

リストなので先頭から一つずつ取り出せる。

```
ghci> actions = map putStrLn ["Hello, Everyone!", "How are you?", "I'm fine!"]
ghci> (x1 : left) = actions
ghci> :t x1
x1 :: IO ()
ghci> x1
Hello, Everyone!

ghci> (x2 : left2) = left
ghci> x2
How are you?

ghci> (x3 : left3) = left2
ghci> x3
I'm fine!
```

まとめて実行したいときは、`sequence_`関数を使う。

```
ghci> sequence_ actions
Hello, Everyone!
How are you?
I'm fine!
```

いちいち`sequence_`を使うのも面倒なので、「命令」を返す関数を特別扱いする高階関数があります。  
そのうちの一つが`for_`。

`putStrLn`のように、引数を一つだけ受け取って命令を返す関数に対して使える。

リストの各要素に対して、指定した関数を適用し、関数が返した命令を実行する

```
ghci> for_ ["Hello, Everyone!", "How are you?", "I'm fine!"] putStrLn

<interactive>:2:1: error:
    Variable not in scope: for_ :: [[Char]] -> (String -> IO ()) -> t
```

```
ghci> import Data.Foldable
```

```
ghci> for_ ["Hello, Everyone!", "How are you?", "I'm fine!"] putStrLn
Hello, Everyone!
How are you?
I'm fine!
```

### `IO` 型を使って、自分で命令を定義する

高階関数`for_`が引数として受け取った「命令を返す関数」に、リストの各要素を渡して呼び出している、という動作を確認するために、自分で「命令を返す関数」を定義してみましょう。

例として、リストの長さを返す関数`length`を利用して、受け取ったリストの中身を標準出力に出力し、その後にその長さを出力する命令を返す関数を定義してみます。

```
ghci> :{
ghci| printStringAndLength xs = do
ghci|   print xs
ghci|   print (length xs)
ghci| :}
```

```
ghci> printStringAndLength "abcdefghijk"
"abcdefghijk"
11
```

```
main = do
  ...
```

などと書いていたのと同じ。違いは引数があるかないか。

```
ghci> :{
ghci| printStringAndLength :: Show a => [a] -> IO ()
ghci| printStringAndLength xs = do
ghci|   print xs
ghci|   print (length xs)
ghci| :}
```

実際には`Show a => [a] -> IO ()`という型から読み取れるとおり、「引数（この場合`[a]`）を受け取って、命令を返す（純粋な）関数」によって、`putStrLn`関数といった、「引数を受け取る命令」は作られています。

`IO ()`の`()`は課題Xで説明したユニット型です。

`IO foo`で指定した型`foo`は、「命令を実行した結果返される値の型」を表します。

`getLine` は命令を実行した結果文字列を返すので`IO String`という型になってます。

```
ghci> :t getLine
getLine :: IO String
```

`IO ()`のように、ユニット型である場合、「結果として返す値が実質ない命令」を表します。  
C言語などで言うところの`void`の代わりだと思ってください。

`for_`が扱うのは、この`IO ()`な命令、「結果として返す値が実質ない命令」です。
「引数を一つ受け取って」「結果として返す値が実質ない命令」を、「リストの各要素に対して」実行する。

### `for`関数で、リストの各要素に対して「命令」を実行し、結果をまたリストに入れる

<!-- TODO: for -> for_ -> IO の順番で説明する -->

`getLine`や`readFile`のように、「結果となる値を持った命令」（を返す関数）がある。

指定したファイル名のリストから、中身のリストを返す。

例えば、下記のような2つのファイルを作ったとして、

file1.txt:

```
Lorem ipsum dolor sit amet,
consectetur adipiscing elit,
sed do eiusmod tempor incididunt ut labore et dolore magna aliqua.
```

file2.hs:

```
main = do
  putStrLn "Ut enim ad minim veniam,"
  putStrLn "quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat."
```

```
ghci> import Data.Traversable
```

```
ghci> for ["file1.txt", "file2.hs"] readFile
["Lorem ipsum dolor sit amet,\nconsectetur adipiscing elit,\nsed do eiusmod tempor incididunt ut labore et dolore magna aliqua.\n","main = do\n  putStrLn \"Ut enim ad minim veniam,\"\n  putStrLn \"quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat.\"\n"]
```

わかりやすくするために、リストの要素ごとに改行を挟みました。

```
["Lorem ipsum dolor sit amet,\nconsectetur adipiscing elit,\nsed do eiusmod tempor incididunt ut labore et dolore magna aliqua.\n",
 "main = do\n  putStrLn \"Ut enim ad minim veniam,\"\n  putStrLn \"quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat.\"\n"
]
```

```
ghci> :{
ghci| for ["file1.txt", "file2.hs"] (\path -> do
ghci|   content <- readFile path
ghci|   return (length content)
ghci|   )
ghci| :}
[124,144]
```

一方、「命令」の中には、`IO ()`な命令、「結果として返す値がない命令」があります。
「結果として返す値が実質ない命令」、つまり`IO ()`を`for`に渡すとどうなるでしょうか。

```
ghci> for ["Hello, Everyone!", "How are you?", "I'm fine!"] putStrLn
Hello, Everyone!
How are you?
I'm fine!
[(),(),()]
```

`Hello, Everyone!`などの`putStrLn`が実行した出力の最後に、`[(),(),()]`という妙な文字列が出力された

これは、`()`が3つ入ったリストです。

`for`はリストの各要素に対して「命令」を実行し、「結果をまたリストに入れる」ので、`putStrLn`の結果の値`()`がそのままリストに入ってしまう。

これでは役に立たないので、`for_`がある。

### `for_`, `for`, `map`の違いまとめ

- いずれもリストに入った各要素に対して関数を実行するための高階関数
- `map`は**純粋な関数**（ただの値を受け取ってただの値を返す関数）をリストの各要素に対して実行し、純粋な関数が返した値を、戻り値のリストに入れる。
- `for`は**「結果を返す命令」**を返す関数（ただの値を受け取って命令を返す関数）をリストの各要素に対して実行し、命令が返した値を、戻り値のリストに入れる。
- `for_`は**「結果を返さない命令」**を返す関数（ただの値を受け取って命令を返す関数）をリストの各要素に対して実行し、何も返さない（`IO ()`を返す）。

ちなみに、`for_`のように、名前がアンダースコアで終わる高階関数は、アンダースコアがない関数の「値を返さないバージョン」であることが多いです。
