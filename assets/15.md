# 処理を繰り返し実行する (2)

コマンドラインからファイル名のリストを受け取って、その中身をファイル名と一緒に出力するコマンドを作りましょう。

1. コマンドライン引数のリストを取得します。
2. コマンドライン引数のリストの各要素に対して、次の処理を実行します:
    1. 各要素である文字列を、標準出力にputStrLn関数で出力します。
    2. 各要素である文字列をファイルのパスとして解釈し、その中身を読みます。
    3. 読んだファイルの中身を、改行で区切ったリストに変換します。
    4. 改行で区切ったリストの各要素の先頭に、スペースを2文字分付け足します。
    5. 各要素の先頭にスペースを付けた文字列のリストを、再び改行文字で結合します。
    6. 再び結合した文字列を、そのままputStr関数で出力します。

## 入出力例

どのような動作をするのかこの説明だけでは分かりづらいと思うので、実行結果の例を示します。

### コマンドライン引数に何も与えなかったとき

```shell
shell> runhaskell 15.hs
shell>
```

※何も出力しないで終わる

### ファイルの名前を複数与えたとき

a.txt:

```
line 1 in a.txt
line 2 in a.txt
line 3 in a.txt
```

b.txt:

```
line 1 in b.txt
```

c.txt:

```
line 1 in c.txt
line 2 in c.txt
```

empty.txt:

```
```

※空のファイル

```shell
shell> runhaskell 15.hs a.txt b.txt empty.txt c.txt
a.txt
  line 1 in a.txt
  line 2 in a.txt
  line 3 in a.txt
b.txt
  line 1 in b.txt
empty.txt
c.txt
  line 1 in c.txt
  line 2 in c.txt
shell>
```

## 必要な知識

### `readFile`関数で、ファイルの中身をすべて読む

コマンドライン引数を取得する関数は課題hoge(13)で紹介したので、ここではファイルの中身を読む関数を学習しましょう。まずは例えば下記のようなコマンドで、読み込むファイルを作っておきましょう:

```
shell> echo "Read this file later!" > read-later.txt
```

上のコマンドのとおり`read-later.txt`という名前でファイルを作ったとして、次に進みます。`read-later.txt`を置いたのと同じディレクトリーでGHCiを起動し、次のように`readFile`関数を実行してください:

```haskell
ghci> readFile "read-later.txt"
"Read this file later!\n"
```

引数の文字列で指定したファイル`read-later.txt`の中身が返ってきました！

`readFile`関数は、`getLine`関数や`putStrLn`関数などと同様に、入出力を行う関数、すなわち「命令」です。なので原則として`do`記法の中で使用し、結果を`<-`で代入します。これまでに学習した`getContents`や、`getLine`、`getArgs`などもその仲間でした。先ほどの例のようにGHCiの中で使用する分には問題ないのですが、今回の課題のように`readFile`関数を使ったプログラムを作る場合は注意しましょう:

```haskell
main = do
    -- readFileはdoの中で使って、
    -- 「<-」で結果を代入する！
    contents <- readFile "read-later.txt"
    putStrLn contents
```

### `map`関数で、リストの各要素に対して「純粋な関数」を実行し、結果をまたリストに入れる

ここからは、リストの各要素を一つずつ処理する関数をいくつか学びましょう。これまでの課題で学んだリストを処理する方法は、ほとんどが要素の数が数パターンに決まったリストに対するものでした。「ホニャララのリストの要素数が『2』であれば～」などといった課題文はもう見飽きたかも知れません。この節と以降の節では、リストの要素数に関係なく、各要素をまとめて処理するのに便利な関数を紹介します。

その前に、説明のための便利なモジュールとその関数を紹介しましょう。[`Data.Char`モジュール](https://hackage.haskell.org/package/base/docs/Data-Char.html)には、文字通り（文字だけに）文字型`Char`の値を処理するための関数がたくさん入っています。そのうち`toUpper`は、指定した**文字**を大文字にすることができます:

```haskell
ghci> import Data.Char

-- 文字列ではなくただの文字なのでシングルクォートで囲うこと！
ghci> toUpper 'a'
'A'

-- 間違えて文字列を渡すとやっぱり型エラーに！
ghci> toUpper "a"

<interactive>:7:9: error:
    ? Couldn't match expected type ‘Char’ with actual type ‘[Char]’
    ? In the first argument of ‘toUpper’, namely ‘"a"’
      In the expression: toUpper "a"
      In an equation for ‘it’: it = toUpper "a"
```

上記のとおり、`toUpper`はあくまでも**単一の文字**に対する関数なので、0個や2個以上の文字を含みうる**文字列**に対しては使えません。でも、みなさんが普段書くプログラムで扱いたいのは、単なる文字よりも文字列である場合が圧倒的に多いでしょう。文字列に含まれている文字に対して、まとめて`toUpper`関数を適用するにはどうすればいいでしょうか？

そこで登場するのが`map`関数です:

```haskell
ghci> map toUpper "hello!"
"HELLO!"
```

`map`関数を使うことで、無事、文字列の中のすべての文字を（大文字小文字の区別がない「!」は除いて）大文字にすることができました！

詳しい仕組みを見てみましょう。まずはおなじみ`:t`コマンドで`map`関数の型を調べてみます:

```haskell
ghci> :t map
map :: (a -> b) -> [a] -> [b]
```

`(a -> b) -> ...`のように、型定義の中にカッコで囲われた関数`(a -> b)`を見かけるのは初めてかと思います。`a -> b`が「`a`という型の値を受け取って`b`という型の値を返す関数」を表しているとおり、カッコで囲われた`(a -> b)`は、関数を引数として受け取っていることを表します。つまり、上記の`map`関数の型定義は次のように読み取れます:

- `a -> b` という関数と、
- `[a]`（`a`のリスト）を引数として受け取り、
- `[b]`（`b`のリスト）を返す

では、`map`関数は「`a -> b` という関数」と「`[a]`（`a`のリスト）」という二つの引数から、どのように「`[b]`（`b`のリスト）」を作って返すのでしょうか？先ほどの例を振り返ってみましょう:

```haskell
ghci> map toUpper "hello!"
"HELLO!"
```

Haskellでは標準の文字列は`[Char]`、つまり文字のリストなので、上記の式では個々の文字`'h'`・`'e'`・`'l'`・`'l'`・`'o'`・`'!'`を処理することになります。`map`関数はこれらの文字一つ一つに`toUpper`関数を適用することで、それぞれを大文字にした`'H'`・`'E'`・`'L'`・`'L'`・`'O'`・`'!'`を取得し、それをまた（文字の）リストにした`"HELLO!"`を最終的に返しました。

一般化すると、`map`関数は第一引数に渡した「`a -> b` という関数」を、第二引数として渡した「`[a]`（`a`のリスト）」のそれぞれの要素に対してその関数を適用し、その結果を「`[b]`（`b`のリスト）」として返します。

もう一つ、今度は数値のリストを使った例を見てみましょう。まずは準備のため、`map`関数に渡す関数を定義します:

```haskell
ghci> f x = x * 2 + 3
```

一つの数、`x`に2をかけて3を足すだけの単純な関数`f`です。これに、リストに入った複数の数`[2, 5, 10]`におけるそれぞれの数を渡して実行した例がこちら👇️です:

```haskell
ghci> map f [2, 5, 10]
[7,13,23]
```

期待通りリストで返ってきましたね！結果として返ってきた`[7, 13, 23]`におけるそれぞれの数が正しいか、引数として渡した`[2, 5, 10]`の各要素を`f`に渡して確かめてみましょう:

```haskell
ghci> f 2
7
ghci> f 5
13
ghci> f 10
23
```

### ラムダ抽象で、その場限りの関数を定義する

これまでに紹介した例では、`map`関数に渡す関数 --- 具体的には`toUpper`や`f` --- は、すべて`map`関数を呼び出す箇所以外で定義した関数でした。この使用方法で全く問題ないのですが、`map`関数の引数としてしか渡さない関数を、それだけのために定義するのは無駄に感じるときもあるでしょう。そんなときに便利なのが「ラムダ抽象[^lambda-abstraction]」という機能です。

[^lambda-abstraction]: 慣習的に、この機能は「ラムダ式」と呼ぶ方が一般的ですが、本入門では[Haskell標準での表現](https://www.haskell.org/onlinereport/haskell2010/haskellch3.html#x8-260003.3)に合わせて「ラムダ抽象」と呼んでいます。

ラムダ抽象は、例えば次のように書くことで関数を表す式です:

```haskell
\x -> x * 2 + 3
```

上👆の式は、先ほどの👇で定義した関数と、同じ内容の関数を表しています。

```haskell
f x = x * 2 + 3
```

実際にGHCiに聞いてみると、確かにラムダ抽象による関数`\x -> x * 2 + 3`と`f`は同じ関数であることが察せられます:

```haskell
-- 型はどちらも、「数値型の値を受け取って数値型の値を返す関数」
ghci> :t f
f :: Num a => a -> a
ghci> :t \x -> x * 2 + 3
\x -> x * 2 + 3 :: Num a => a -> a

-- 何を与えてもやっぱり同じ値が返る！
---- ラムダ抽象で作った関数に直接引数を
---- 渡すときは、カッコで囲いましょう
ghci> f 5
13
ghci> (\x -> x * 2 + 3) 5
13

ghci> f 2
7
ghci> (\x -> x * 2 + 3) 2
7

ghci> f 19.5
42.0
ghci> (\x -> x * 2 + 3) 19.5
42.0
```

なので、ラムダ抽象で定義した関数を適当な変数に代入することは、同じ名前の変数で関数を定義するのと全く同じ意味になります:

```haskell
f = \x -> x * 2 + 3
-- ↑と↓は同じ意味！
f x = x * 2 + 3
```

（説明目的以外でこのように書くことは希ですが）

以上のラムダ抽象は、一般化すると次のような構文となっております:

```haskell
\（...引数の一覧...） -> （...関数の本体...）
```

バックスラッシュ`\`で始めて、そこから右向きの細い矢印`->`の間に引数を列挙します。`->`の後ろには、関数の本体である、結果となる式を書きます。

バックスラッシュを使っているのは、「すごいHaskell 楽しく学ぼう」という本曰く、「ラムダ抽象」の名前の由来であるギリシャ文字の「ラムダ」、その小文字の「λ」を遠くから見るとバックスラッシュによく似ているからだそうです。ホンマかいな。

引数が複数の場合、以下のようにバックスラッシュと右細い矢印の間に書く、引数名をスペースで区切ります:

```
ghci> f = \x y -> x * y + 3
ghci> f 2 9
21
```

そろそろ話を`map`関数に戻しましょう。前述のとおり、ラムダ抽象は`map`関数などを試すときに、いちいち名前の付いた関数を定義するのが面倒くさい、というときに便利です:

```haskell
-- 前述の map f [2, 5, 10] の代わりに、このように書ける！
ghci> map (\x -> x * 2 + 3) [2, 5, 10]
[7,13,23]
```

この後出てくる、他の「関数を受け取る関数」でも使えるので是非お試しください！

### 先に進む前に: 用語の整理

次の節でも、`map`関数のようにリストの各要素に対して関数を適用する関数（`for_`や`for`）を勉強します。これまでの知識だけだと、それぞれの違いがわかりづらいでしょう。それを区別するためのキーワードは、ズバリ「純粋な関数」や「命令」なのですが、これまで厳密な定義を述べないで使ってきました。次の節以降の理解を楽にするため、関連する用語と合わせて一通り解説しましょう。抽象的な説明が続いてしまいますがご容赦を！

#### ただの値

まずは「純粋な関数」や「命令」にとって必要不可欠な「値」について触れておきます。「値」は関数が返す結果や引数となります。「値」には「純粋な関数」や「命令」も含まれているのですが、どのような値であれ、それだけでは何もできません。詳細は後述しますが、「純粋な関数」や「命令」が何かするには、値との協力があってこそなのです。

「値」の例:

- `"hello"`
- `True`
- `123`
- `map`
- `print`
- `\x -> x + 2 * 3`

#### 純粋な関数

「純粋な関数」は、引数として「ただの値」を受け取ると新しく「ただの値」を返してくれます。原則としてそれ以外のことは行わないようになっていて、引数を渡したからと言って標準出力に文字列を書き込んだり、どこかのグローバル変数に書き込んだりはしません。「純粋な関数」は多くのプログラミング言語に備わる「関数」よりも、数学における「関数」という概念に近いです。

余談ですが「関数型プログラミング」と言う言葉における「関数」とはこの「純粋な関数」を指しています。「関数型プログラミング」は「純粋な関数」をなるべく多くの箇所で使うことを奨励したプログラミングスタイルなんですね。

Haskellにおける「純粋な関数」は、これまでに何度も見かけた`->`という型で表されます。`String -> Bool`といった具合に、`->`の左辺に引数の型、右辺に戻り値の型を書きます。

例: `words`関数は文字列（`String`）を受け取って文字列のリスト（`[String]`）を返す「純粋な関数」なので、型は`String -> [String]`:

```haskell
ghci> :t words
words :: String -> [String]
--       ^^^^^^    ^^^^^^^^
--      引数の型  戻り値の型
```

##### 二つ以上の引数を受け取る（ように見える）純粋な関数

`->`について初めてちゃんと紹介したので、ここまで詳しく説明してこなかった、二つ以上の引数を受け取る関数の正体を明かしましょう。前の節で、`->`は左辺に引数の型、右辺に戻り値の型を書くと説明したのですが、左辺・右辺には、それぞれ一つの型しか書くことができません。では、複数の値を受け取る関数を書きたい場合、どうすればよいのでしょう？

そこで、これまでに紹介した、二つ以上の引数を受け取る関数を思い出してください。ここでは、課題hoge(10)で例として定義した、`bmiExpression`関数を再度登場させましょう。GHCiに以下のように入力して、`:t`で型を確かめてみてください:

```haskell
ghci> :{
ghci| bmiExpression heightStr weightStr =
ghci|   weightStr
ghci|   ++ " / ("
ghci|   ++ heightStr ++ " * " ++ heightStr
ghci|   ++ ")"
ghci| :}

ghci> :t bmiExpression
bmiExpression :: [Char] -> [Char] -> [Char]
```

`bmiExpression`は、身長を表す文字列と体重を表す二つの文字列を受け取って、それらからBMIを計算する式を返す関数なのでした<small>（BMIそのものを計算して返すわけではないのでご注意）</small>。そしてその型を見てみると、`bmiExpression :: [Char] -> [Char] -> [Char]`と表示されたとおり、二つの引数と戻り値を区切るような形で`->`が二つ使われていますね。そう、これがHaskellの世界の関数における、二つ以上の引数を受け取る関数です。

とりあえず使用するだけであればこのように「二つ目以降の引数の型を`->`で区切る」という点だけを押さえておけばいいのですが、ここからが一風変わったポイントなのでご注意ください。Haskellの世界では厳密な意味で「二つ以上の引数を受け取る」関数は存在していません。一般に、「二つ以上の引数を受け取る関数」を定義したい場合は、「一つの引数を受け取る関数」`->`を重ねることで表現します。具体的には、引数を二つ受け取る関数の場合、「一つ目の引数を受け取ると『二つ目の引数を受け取って戻り値を返す関数』を返す関数」として表現します。

言葉で説明してもわかりづらいので、さらに具体的に、`bmiExpression`関数を例に確かめてみましょう。まずは`bmiExpression`に引数を一つも与えていないときの型を再確認します:

```haskell
ghci> :t bmiExpression
bmiExpression :: [Char] -> [Char] -> [Char]
```

それから、一つ目の引数として適当な文字列を与えた状態で`:t`してみます:

```haskell
ghci> :t bmiExpression "1.74"
bmiExpression "1.74" :: [Char] -> [Char]
```

`bmiExpression`の型が`[Char] -> [Char] -> [Char]`から`[Char] -> [Char]`に変わりました！引数として`[Char]`型の値を受け取ったことで、`bmiExpression`は`[Char] -> [Char]`、つまり「`[Char]`型の値を一つ受け取って`[Char]`型の値を返す関数」を返したのです。

そのため、もう一つ文字列を渡すと今度は関数ではない、ただの`[Char]`型を返すようになります:

```haskell
ghci> :t bmiExpression "1.74" "72"
bmiExpression "1.74" "72" :: [Char]
```

このようにHaskellにおける関数`->`は、`->`一つだけでは一つの値しか受け取れないところ、`->`を重ねて「引数を受け取ったら関数を返す関数」を作ることで、二つ以上の引数を受け取る関数になることができます。`->`は右結合なので、`[Char] -> [Char] -> [Char]`と書いた場合は、右側の`->`が優先的に解釈されて「`[Char]`を受け取って`[Char] -> [Char]`を返す関数」になるのです。以下のように、カッコを補ってみても分かりやすいでしょう:

```haskell
[Char] -> ([Char] -> [Char])
```

なお、Haskellで二つ以上の引数を受け取る関数が「関数を**返す**関数」として定義されることは、この節で紹介したとおりですが、先ほどの`map`関数のように関数を**受け取る**関数を定義する場合は、`map`関数の型定義にあったとおり、引数として関数を受け取りたい箇所をカッコで囲う、というルールも重要なので覚えておいてください:

```haskell
ghci> :t map
map :: (a -> b) -> [a] -> [b]
```

第一引数である関数`a -> b`がカッコで囲われて`(a -> b)`になっていますね。このように書かずに`a -> b -> [a] -> [b]`と書いてしまうと、全く違う引数を受け取る関数になってしまうのでご注意ください。練習問題として、この`a -> b -> [a] -> [b]`という関数が、どんな引数をいくつ受け取ってどんな値を返すか、考えてみるのも面白いでしょう。

#### 命令

「命令」には、ここまで紹介した「ただの値」や「純粋な関数」とは一線を画す特徴があります。それは、「入出力処理など、何かしら副作用のある処理を実行できる」という特徴[^1]です。一般的には「アクション」と呼ばれることの方が多いかも知れません。

[^1]: 詳細は先の課題で述べますが、実際にその「副作用のある処理」を実行するには、`do`記法で列挙されている、直前の命令から続いて呼ばれる必要があります。「ただの値」として純粋な関数でやりとりしている限りは何も起こりません。

加えて、「命令」は「純粋な関数」と異なり引数を受け取ることができません。「じゃあどうやって引数を受け取るの？」という疑問には後ほど回答しましょう。

一方、「命令」は普通の関数のように「何かしら副作用のある処理」をした後に「ただの値」を返すことができます。例えば次のように`getLine`を呼び出すと、ユーザーが入力した文字列を「ただの値」として`line`という変数に代入できますね。これが`getLine`が返す「ただの値」です。

```haskell
do
    line <- getLine
```

次のように`getLine`の型を`:t`で見てみると、「命令」は`IO`という型の値であり、`IO`の型引数として受け取った型 --- `getLine`関数の場合`String`ですね --- の値を「ただの値」として返すことが読み取れます:

```haskell
ghci> :t getLine
getLine :: IO String
```

「命令」の例:

- `getLine`
- `getContents`

#### 「引数をとる命令」のように見えていたもの:

前節では、「命令」は引数を受け取ることができない、と説明しました。ではこれまで私たちが出会った、「命令」のように入出力処理しながら引数を受け取る関数 --- 具体的には`putStrLn`関数や本課題で登場した`readFile`関数 --- は、一体何なのでしょう？

これも答えはGHCiの`:t`コマンドを使えば見えてきます。早速やってみましょう:

```haskell
ghci> :t putStrLn
putStrLn :: String -> IO ()
```

そう、これまでに何度も見かけたあの`->`という型、「純粋な関数」が現れました！`String -> IO ()`という型が表すとおり、`putStrLn`は文字列`String`を受け取って`IO ()`という型の「命令」を返します。つまり、`putStrLn`を含む、「引数によって動作を変えたい命令」は、引数を「純粋な関数」`->`に受け取らせて、「純粋な関数」`->`の結果となる値として「命令」を返すことで実現されているのです。

「純粋な関数」と「命令」を組み合わせることによって、「引数を受け取る命令」のように振る舞う関数の例:

- `putStrLn`
- `readFile`

なお今後は、説明を簡単にするために「命令」という言葉で上記のような「引数を受け取る命令」も含めて「命令」と呼ぶことがあります。あらかじめご了承ください。「命令」と同義である前述の「アクション」についてもそのような意味で使われることが多いので、覚えておくといいでしょう。

##### 謎の型 `()`

ところで、先ほど`:t putStrLn`したとき出てきた`IO ()`の`()`がなんなのかも気になりますよね？`()`は、`()`というとても変な名前の型です。Haskellで`()`以外にカッコを含めた名前の型を作ることはできません。

`()`という型は、値の名前も変わっています。`()`という型には`()`という名前の唯一の**値**があります。これもまた名前が変わっている上に、型と値の名前が同じなのでややこしいですね！ちなみに、どちらも発音するときは「ユニット」です。

実はこの`()`、名前が特別なだけで、それ以外に特別な点は特にありません。「値が一つしかない」というのも大きな特徴ですが、そうした型はみなさんも簡単に作れます（自分で型を定義する方法はまた改めて紹介しましょう）。名前が変なことと、「値が一つしかない」型の標準として広く使われている、という点だけ抑えておきましょう。

さて「値が一つしかない」型、`()`はどのように役に立つのでしょうか。Haskellの世界では、関数の引数・戻り値の型が決まれば、どんな値を受け取るか、あるいは返すかが決まってしまうので、「値が一つしかない」型を引数・戻り値の型として選んだ時点で、その引数・戻り値は必ず**無意味な値**になります。だって引数の値が一つしか取り得ないのであれば、「純粋な関数」はその値によって結果を変えることができないし、戻り値が一つの値しか取り得ないのであれば、どんな値を渡しても同じ結果にしかならないじゃないですか。`()`は、それだけでは何の意味も為さない値なのです。

そのため、`()`は最もポピュラーな用途として、「命令」を表す`IO`型と組み合わせて使う、つまり`IO ()`として使うことで「値を何も返さない命令」を表すのに用いられます。`putStrLn`や`print`などの`IO ()`を返す関数は、引数として受け取った値を元に、入出力を行うためだけにあるので、値を何も返す必要がなく、そのため「命令」の結果として`()`を返すのです。

#### 要点の整理: ただの値、純粋な関数、命令

ここまでのことを整理すると、次の表に要約されます:

| 種類           | 型          | 引数を受け取るか | 実行して副作用を起こせるか | 値の例                          |
|----------------+-------------+------------------+----------------------------+---------------------------------|
| ただの値       | `a`         | 受け取らない     | 起こせない                 | `True`, `'A'`, `getLine`, `map` |
| 純粋な関数     | `a -> b`    | 受け取る         | 起こせない                 | `words`, `map`, `\x -> x + 3`   |
| 命令           | `IO a`      | 受け取らない     | 起こせる                   | `getLine`, `putStrLn "a"`       |
| 命令を返す関数 | `a -> IO b` | 受け取る         | 起こせる                   | `putStrLn`, `readFile`          |

### `for_`関数で、リストの各要素に対して「命令」を実行する

「命令」を返す関数を`map`で実行しようとしてみたら...

```
ghci> map putStrLn ["Hello, Everyone!", "How are you?", "I'm fine!"]

<interactive>:3:1: error:
    ? No instance for (Show (IO ())) arising from a use of ‘print’
    ? In a stmt of an interactive GHCi command: print it
```

```
ghci> :t map putStrLn ["Hello, Everyone!", "How are you?", "I'm fine!"]
map putStrLn ["Hello, Everyone!", "How are you?", "I'm fine!"]
  :: [IO ()]
```

`[IO ()]`は`IO ()`じゃない！リスト`[]`に包まれている！

実行するには？
リストから取り出す。

リストなので先頭から一つずつ取り出せる。

```
ghci> actions = map putStrLn ["Hello, Everyone!", "How are you?", "I'm fine!"]
ghci> (x1 : left) = actions
ghci> :t x1
x1 :: IO ()
ghci> x1
Hello, Everyone!

ghci> (x2 : left2) = left
ghci> x2
How are you?

ghci> (x3 : left3) = left2
ghci> x3
I'm fine!
```

まとめて実行したいときは、`sequence_`関数を使う。

```
ghci> sequence_ actions
Hello, Everyone!
How are you?
I'm fine!
```

いちいち`sequence_`を使うのも面倒なので、「命令」を返す関数を特別扱いする高階関数があります。  
そのうちの一つが`for_`。

`putStrLn`のように、引数を一つだけ受け取って命令を返す関数に対して使える。

リストの各要素に対して、指定した関数を適用し、関数が返した命令を実行する

```
ghci> for_ ["Hello, Everyone!", "How are you?", "I'm fine!"] putStrLn

<interactive>:2:1: error:
    Variable not in scope: for_ :: [[Char]] -> (String -> IO ()) -> t
```

```
ghci> import Data.Foldable
```

```
ghci> for_ ["Hello, Everyone!", "How are you?", "I'm fine!"] putStrLn
Hello, Everyone!
How are you?
I'm fine!
```

### `IO` 型を使って、自分で命令を定義する

高階関数`for_`が引数として受け取った「命令を返す関数」に、リストの各要素を渡して呼び出している、という動作を確認するために、自分で「命令を返す関数」を定義してみましょう。

例として、リストの長さを返す関数`length`を利用して、受け取ったリストの中身を標準出力に出力し、その後にその長さを出力する命令を返す関数を定義してみます。

```
ghci> :{
ghci| printStringAndLength xs = do
ghci|   print xs
ghci|   print (length xs)
ghci| :}
```

```
ghci> printStringAndLength "abcdefghijk"
"abcdefghijk"
11
```

```
main = do
  ...
```

などと書いていたのと同じ。違いは引数があるかないか。

```
ghci> :{
ghci| printStringAndLength :: Show a => [a] -> IO ()
ghci| printStringAndLength xs = do
ghci|   print xs
ghci|   print (length xs)
ghci| :}
```

実際には`Show a => [a] -> IO ()`という型から読み取れるとおり、「引数（この場合`[a]`）を受け取って、命令を返す（純粋な）関数」によって、`putStrLn`関数といった、「引数を受け取る命令」は作られています。

`IO ()`の`()`は課題Xで説明したユニット型です。

`IO foo`で指定した型`foo`は、「命令を実行した結果返される値の型」を表します。

`getLine` は命令を実行した結果文字列を返すので`IO String`という型になってます。

```
ghci> :t getLine
getLine :: IO String
```

`IO ()`のように、ユニット型である場合、「結果として返す値が実質ない命令」を表します。  
C言語などで言うところの`void`の代わりだと思ってください。

`for_`が扱うのは、この`IO ()`な命令、「結果として返す値が実質ない命令」です。
「引数を一つ受け取って」「結果として返す値が実質ない命令」を、「リストの各要素に対して」実行する。

### `for`関数で、リストの各要素に対して「命令」を実行し、結果をまたリストに入れる

<!-- TODO: for -> for_ -> IO の順番で説明する -->

`getLine`や`readFile`のように、「結果となる値を持った命令」（を返す関数）がある。

指定したファイル名のリストから、中身のリストを返す。

例えば、下記のような2つのファイルを作ったとして、

file1.txt:

```
Lorem ipsum dolor sit amet,
consectetur adipiscing elit,
sed do eiusmod tempor incididunt ut labore et dolore magna aliqua.
```

file2.hs:

```
main = do
  putStrLn "Ut enim ad minim veniam,"
  putStrLn "quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat."
```

```
ghci> import Data.Traversable
```

```
ghci> for ["file1.txt", "file2.hs"] readFile
["Lorem ipsum dolor sit amet,\nconsectetur adipiscing elit,\nsed do eiusmod tempor incididunt ut labore et dolore magna aliqua.\n","main = do\n  putStrLn \"Ut enim ad minim veniam,\"\n  putStrLn \"quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat.\"\n"]
```

わかりやすくするために、リストの要素ごとに改行を挟みました。

```
["Lorem ipsum dolor sit amet,\nconsectetur adipiscing elit,\nsed do eiusmod tempor incididunt ut labore et dolore magna aliqua.\n",
 "main = do\n  putStrLn \"Ut enim ad minim veniam,\"\n  putStrLn \"quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat.\"\n"
]
```

```
ghci> :{
ghci| for ["file1.txt", "file2.hs"] (\path -> do
ghci|   content <- readFile path
ghci|   return (length content)
ghci|   )
ghci| :}
[124,144]
```

一方、「命令」の中には、`IO ()`な命令、「結果として返す値がない命令」があります。
「結果として返す値が実質ない命令」、つまり`IO ()`を`for`に渡すとどうなるでしょうか。

```
ghci> for ["Hello, Everyone!", "How are you?", "I'm fine!"] putStrLn
Hello, Everyone!
How are you?
I'm fine!
[(),(),()]
```

`Hello, Everyone!`などの`putStrLn`が実行した出力の最後に、`[(),(),()]`という妙な文字列が出力された

これは、`()`が3つ入ったリストです。

`for`はリストの各要素に対して「命令」を実行し、「結果をまたリストに入れる」ので、`putStrLn`の結果の値`()`がそのままリストに入ってしまう。

これでは役に立たないので、`for_`がある。

### `for_`, `for`, `map`の違いまとめ

- いずれもリストに入った各要素に対して関数を実行するための高階関数
- `map`は**純粋な関数**（ただの値を受け取ってただの値を返す関数）をリストの各要素に対して実行し、純粋な関数が返した値を、戻り値のリストに入れる。
- `for`は**「結果を返す命令」**を返す関数（ただの値を受け取って命令を返す関数）をリストの各要素に対して実行し、命令が返した値を、戻り値のリストに入れる。
- `for_`は**「結果を返さない命令」**を返す関数（ただの値を受け取って命令を返す関数）をリストの各要素に対して実行し、何も返さない（`IO ()`を返す）。

ちなみに、`for_`のように、名前がアンダースコアで終わる高階関数は、アンダースコアがない関数の「値を返さないバージョン」であることが多いです。
