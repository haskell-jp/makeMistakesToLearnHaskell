# 処理を繰り返し実行する (2)

コマンドラインからファイル名のリストを受け取って、その中身をファイル名と一緒に出力するコマンドを作りましょう。

1. コマンドライン引数のリストを取得します。
2. コマンドライン引数のリストの各要素に対して、次の処理を実行します:
    1. 各要素である文字列を、標準出力にputStrLn関数で出力します。
    2. 各要素である文字列をファイルのパスとして解釈し、その中身を読みます。
    3. 読んだファイルの中身を、改行で区切ったリストに変換します。
    4. 改行で区切ったリストの各要素の先頭に、スペースを2文字分付け足します。
    5. 各要素の先頭にスペースを付けた文字列のリストを、再び改行文字で結合します。
    6. 再び結合した文字列を、そのままputStr関数で出力します。

## 入出力例

どのような動作をするのかこの説明だけでは分かりづらいと思うので、実行結果の例を示します。

### コマンドライン引数に何も与えなかったとき

```shell
shell> runhaskell 15.hs
shell>
```

※何も出力しないで終わる

### ファイルの名前を複数与えたとき

a.txt:

```
line 1 in a.txt
line 2 in a.txt
line 3 in a.txt
```

b.txt:

```
line 1 in b.txt
```

c.txt:

```
line 1 in c.txt
line 2 in c.txt
```

empty.txt:

```
```

※空のファイル

```shell
shell> runhaskell 15.hs a.txt b.txt empty.txt c.txt
a.txt
  line 1 in a.txt
  line 2 in a.txt
  line 3 in a.txt
b.txt
  line 1 in b.txt
empty.txt
c.txt
  line 1 in c.txt
  line 2 in c.txt
shell>
```

※何も出力しないで終わる

## 必要な知識

### `readFile`関数で、ファイルの中身をすべて読む

コマンドライン引数を取得する関数は課題hoge(13)で紹介したので、ここではファイルの中身を読む関数を学習しましょう。まずは例えば下記のようなコマンドで、読み込むファイルを作っておきましょう:

```
shell> echo "Read this file later!" > read-later.txt
```

上のコマンドのとおり`read-later.txt`という名前でファイルを作ったとして、次に進みます。`read-later.txt`を置いたのと同じディレクトリーでGHCiを起動し、次のように`readFile`関数を実行してください:

```haskell
ghci> readFile "read-later.txt"
"Read this file later!\n"
```

引数の文字列で指定したファイル`read-later.txt`の中身が返ってきました！

`readFile`関数は、`getLine`関数や`putStrLn`関数などと同様に、入出力を行う関数、すなわち「命令」です。なので原則として`do`記法の中で使用し、結果を`<-`で代入します。これまでに学習した`getContents`や、`getLine`、`getArgs`などもその仲間でした。先ほどの例のようにGHCiの中で使用する分には問題ないのですが、今回の課題のように`readFile`関数を使ったプログラムを作る場合は注意しましょう:

```haskell
main = do
    -- readFileはdoの中で使って、
    -- 「<-」で結果を代入する！
    contents <- readFile "read-later.txt"
    putStrLn contents
```

### `map`関数で、リストの各要素に対して「純粋な関数」を実行し、結果をまたリストに入れる

ここからは、リストの各要素を一つずつ処理する関数をいくつか学びましょう。これまでの課題で学んだリストを処理する方法は、ほとんどが要素の数が数パターンに決まったリストに対するものでした。「ホニャララのリストの要素数が『2』であれば～」などといった課題文はもう見飽きるほど目にしたかも知れません。この節と以降のいくつかの節では、リストの要素数に関係なく、リストの各要素をまとめて処理するのに便利な関数を紹介します。

その前に、説明のための便利なモジュールとその関数を紹介しましょう。[`Data.Char`モジュール](https://hackage.haskell.org/package/base/docs/Data-Char.html)には、文字通り（文字だけに）文字型`Char`の値を処理するための関数がたくさん入っています。そのうち`toUpper`は、指定した**文字**を大文字にすることができます:

```haskell
ghci> import Data.Char

-- 文字列ではなくただの文字なのでシングルクォートで囲うこと！
ghci> toUpper 'a'
'A'

-- 間違えて文字列を渡すとやっぱり型エラーに！
ghci> toUpper "a"

<interactive>:7:9: error:
    ? Couldn't match expected type ‘Char’ with actual type ‘[Char]’
    ? In the first argument of ‘toUpper’, namely ‘"a"’
      In the expression: toUpper "a"
      In an equation for ‘it’: it = toUpper "a"
```

上記のとおり、`toUpper`はあくまでも単一の文字に対する関数なので、0個や2個以上の文字を含みうる「文字列」に対しては使えません。でも、みなさんが普段書くプログラムで扱いたいのは単なる文字よりも文字列である場合の方が圧倒的に多いでしょう。文字列に含まれている文字に対してまとめて`toUpper`関数を適用するにはどうすればいいでしょうか？

そこで登場するのが`map`関数です:

```haskell
ghci> map toUpper "hello!"
"HELLO!"
```

`map`関数を使うことで、無事、文字列の中のすべての文字を（大文字小文字の区別がない「!」は除いて）大文字にすることができました！

詳しい仕組みを見てみましょう。まずはおなじみ`:t`コマンドで`map`関数の型を調べてみます:

```haskell
ghci> :t map
map :: (a -> b) -> [a] -> [b]
```

`(a -> b) -> ...`のように、型定義の中にカッコで囲われた関数`(a -> b)`を見かけるのは初めてかと思います。`a -> b`が「`a`という型の値を受け取って`b`という型の値を返す関数」を表しているとおり、カッコで囲われた`(a -> b)`は、関数を引数として受け取っていることを表します。つまり、上記の`map`関数の型定義は次のように読み取れます:

- `a -> b` という関数と、
- `[a]`（`a`のリスト）を引数として受け取り、
- `[b]`（`b`のリスト）を返す

では、`map`関数は「`a -> b` という関数」と「`[a]`（`a`のリスト）」という二つの引数から、どのように「`[b]`（`b`のリスト）」を作って返すのでしょうか？先ほどの例を振り返ってみましょう:

```haskell
ghci> map toUpper "hello!"
"HELLO!"
```

Haskellでは標準の文字列は`[Char]`、つまり文字のリストなので、上記の式では個々の文字`'h'`・`'e'`・`'l'`・`'l'`・`'o'`・`'!'`を処理することになります。`map`関数はこれらの文字一つ一つに`toUpper`関数を適用することで、それぞれを大文字にした`'H'`・`'E'`・`'L'`・`'L'`・`'O'`・`'!'`を取得し、それをまた（文字の）リストにした`"HELLO!"`を最終的に返しました。

一般化すると、`map`関数は第一引数に渡した「`a -> b` という関数」を、第二引数として渡した「`[a]`（`a`のリスト）」のそれぞれの要素に対してを適用し、その結果を「`[b]`（`b`のリスト）」として返します。

もう一つ、今度は数値のリストを使った例を見てみましょう:

```haskell
ghci> f x = x * 2 + 3
```

```haskell
ghci> map f [2, 5, 10]
[7,13,23]
```

```haskell
ghci> f 2
7
ghci> f 5
13
ghci> f 10
23
```

hoge

### ラムダ式で、その場限りの関数を定義する

`map`関数などを試すときに、いちいち名前の付いた関数を定義するのが面倒くさい、というときに

```
ghci> map (\x -> x * 2 + 3) [2, 5, 10]
[7,13,23]
```

バックスラッシュ、右細い矢印

「すごいHaskell楽しく学ぼう」曰く小文字の「λ」と遠くから見るとよく似ているかららしい。

```
ghci> (\x -> x * 2 + 3) 10
23
```

そのまま変数に代入すれば、関数として使用することもできるようになります。

```
ghci> f = (\x -> x * 2 + 3)
```

実際にはカッコで囲う必要があるのは、他の式との境界を明確にする必要がある場所だけ

```
ghci> f = \x -> x * 2 + 3
```

これらは同じ意味！

```
ghci> f = \x -> x * 2 + 3
ghci> f x = x * 2 + 3
```

ちなみに、引数が複数の場合、以下のようにバックスラッシュと右細い矢印の間に書く、引数名をスペースで区切ります。

```
ghci> f = \x y -> x * y + 3
```

```
ghci> f = \x y -> x * y + 3
ghci> f x y = x * y + 3
```

```
ghci> map (\i -> f 2 i) [2, 3, 5]
[7,9,13]
```

### NOTE: 用語の意味の確認（変更）

TODO: 「命令」が初めて出てくるセクションに移す

- 純粋な関数: 値を受け取って返すだけ。数学における「関数」に近い。「関数型プログラミング」における「関数」とはこれのこと。
    - `引数の型 -> 結果となる値の型`という型で表される。
    - `splitOn`
    - `toUpper`
    - `+`, `*` などの四則演算に使う演算子
- ただの値: 純粋な関数が返した結果となる値。何もしない。純粋な関数から返されるだけ。
    - `"hello"`
    - `True`
    - `1`
- 命令: 何かしら入出力処理を実行した上で、結果となる（ただの）値を返したり返さなかったりするもの。一般的には「アクション」と呼ばれることの方が多いかも。
    - ほかのプログラミング言語で言うと、「引数をとらない関数オブジェクト」が近い。
        - Javaでいうところの`Callable`, Rubyでいうところの（引数をとらない）`Proc`, JavaScriptでいうところの（引数をとらない）`Function`, etc.
        - Haskell以外の言語は、普通の関数の中で入出力処理ができるので。
    - `IO 結果となる（ただの）値の型`という型で表される。
    - `IO ()`という型で、「値を返さない命令」を表す。
    - `getLine`
    - `putStrLn "hello"`
- 「引数をとる命令」のように見えていたもの:
    - 「命令」を返す「純粋な関数」
    - 引数をとるのは純粋な関数の役目で、戻り値を（入出力処理を実行して）とってくるのが「命令」の役目。
    - `引数の型 -> IO 結果となる値の型`で表される。
    - `putStrLn`
    - `readFile`

### `for_`関数で、リストの各要素に対して「命令」を実行する

「命令」を返す関数を`map`で実行しようとしてみたら...

```
ghci> map putStrLn ["Hello, Everyone!", "How are you?", "I'm fine!"]

<interactive>:3:1: error:
    ? No instance for (Show (IO ())) arising from a use of ‘print’
    ? In a stmt of an interactive GHCi command: print it
```

```
ghci> :t map putStrLn ["Hello, Everyone!", "How are you?", "I'm fine!"]
map putStrLn ["Hello, Everyone!", "How are you?", "I'm fine!"]
  :: [IO ()]
```

`[IO ()]`は`IO ()`じゃない！リスト`[]`に包まれている！

実行するには？
リストから取り出す。

リストなので先頭から一つずつ取り出せる。

```
ghci> actions = map putStrLn ["Hello, Everyone!", "How are you?", "I'm fine!"]
ghci> (x1 : left) = actions
ghci> :t x1
x1 :: IO ()
ghci> x1
Hello, Everyone!

ghci> (x2 : left2) = left
ghci> x2
How are you?

ghci> (x3 : left3) = left2
ghci> x3
I'm fine!
```

まとめて実行したいときは、`sequence_`関数を使う。

```
ghci> sequence_ actions
Hello, Everyone!
How are you?
I'm fine!
```

いちいち`sequence_`を使うのも面倒なので、「命令」を返す関数を特別扱いする高階関数があります。  
そのうちの一つが`for_`。

`putStrLn`のように、引数を一つだけ受け取って命令を返す関数に対して使える。

リストの各要素に対して、指定した関数を適用し、関数が返した命令を実行する

```
ghci> for_ ["Hello, Everyone!", "How are you?", "I'm fine!"] putStrLn

<interactive>:2:1: error:
    Variable not in scope: for_ :: [[Char]] -> (String -> IO ()) -> t
```

```
ghci> import Data.Foldable
```

```
ghci> for_ ["Hello, Everyone!", "How are you?", "I'm fine!"] putStrLn
Hello, Everyone!
How are you?
I'm fine!
```

### `IO` 型を使って、自分で命令を定義する

高階関数`for_`が引数として受け取った「命令を返す関数」に、リストの各要素を渡して呼び出している、という動作を確認するために、自分で「命令を返す関数」を定義してみましょう。

例として、リストの長さを返す関数`length`を利用して、受け取ったリストの中身を標準出力に出力し、その後にその長さを出力する命令を返す関数を定義してみます。

```
ghci> :{
ghci| printStringAndLength xs = do
ghci|   print xs
ghci|   print (length xs)
ghci| :}
```

```
ghci> printStringAndLength "abcdefghijk"
"abcdefghijk"
11
```

```
main = do
  ...
```

などと書いていたのと同じ。違いは引数があるかないか。

```
ghci> :{
ghci| printStringAndLength :: Show a => [a] -> IO ()
ghci| printStringAndLength xs = do
ghci|   print xs
ghci|   print (length xs)
ghci| :}
```

実際には`Show a => [a] -> IO ()`という型から読み取れるとおり、「引数（この場合`[a]`）を受け取って、命令を返す（純粋な）関数」によって、`putStrLn`関数といった、「引数を受け取る命令」は作られています。

`IO ()`の`()`は課題Xで説明したユニット型です。

`IO foo`で指定した型`foo`は、「命令を実行した結果返される値の型」を表します。

`getLine` は命令を実行した結果文字列を返すので`IO String`という型になってます。

```
ghci> :t getLine
getLine :: IO String
```

`IO ()`のように、ユニット型である場合、「結果として返す値が実質ない命令」を表します。  
C言語などで言うところの`void`の代わりだと思ってください。

`for_`が扱うのは、この`IO ()`な命令、「結果として返す値が実質ない命令」です。
「引数を一つ受け取って」「結果として返す値が実質ない命令」を、「リストの各要素に対して」実行する。

### `for`関数で、リストの各要素に対して「命令」を実行し、結果をまたリストに入れる

<!-- TODO: for -> for_ -> IO の順番で説明する -->

`getLine`や`readFile`のように、「結果となる値を持った命令」（を返す関数）がある。

指定したファイル名のリストから、中身のリストを返す。

例えば、下記のような2つのファイルを作ったとして、

file1.txt:

```
Lorem ipsum dolor sit amet,
consectetur adipiscing elit,
sed do eiusmod tempor incididunt ut labore et dolore magna aliqua.
```

file2.hs:

```
main = do
  putStrLn "Ut enim ad minim veniam,"
  putStrLn "quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat."
```

```
ghci> import Data.Traversable
```

```
ghci> for ["file1.txt", "file2.hs"] readFile
["Lorem ipsum dolor sit amet,\nconsectetur adipiscing elit,\nsed do eiusmod tempor incididunt ut labore et dolore magna aliqua.\n","main = do\n  putStrLn \"Ut enim ad minim veniam,\"\n  putStrLn \"quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat.\"\n"]
```

わかりやすくするために、リストの要素ごとに改行を挟みました。

```
["Lorem ipsum dolor sit amet,\nconsectetur adipiscing elit,\nsed do eiusmod tempor incididunt ut labore et dolore magna aliqua.\n",
 "main = do\n  putStrLn \"Ut enim ad minim veniam,\"\n  putStrLn \"quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat.\"\n"
]
```

```
ghci> :{
ghci| for ["file1.txt", "file2.hs"] (\path -> do
ghci|   content <- readFile path
ghci|   return (length content)
ghci|   )
ghci| :}
[124,144]
```

一方、「命令」の中には、`IO ()`な命令、「結果として返す値がない命令」があります。
「結果として返す値が実質ない命令」、つまり`IO ()`を`for`に渡すとどうなるでしょうか。

```
ghci> for ["Hello, Everyone!", "How are you?", "I'm fine!"] putStrLn
Hello, Everyone!
How are you?
I'm fine!
[(),(),()]
```

`Hello, Everyone!`などの`putStrLn`が実行した出力の最後に、`[(),(),()]`という妙な文字列が出力された

これは、`()`が3つ入ったリストです。

`for`はリストの各要素に対して「命令」を実行し、「結果をまたリストに入れる」ので、`putStrLn`の結果の値`()`がそのままリストに入ってしまう。

これでは役に立たないので、`for_`がある。

### `for_`, `for`, `map`の違いまとめ

- いずれもリストに入った各要素に対して関数を実行するための高階関数
- `map`は**純粋な関数**（ただの値を受け取ってただの値を返す関数）をリストの各要素に対して実行し、純粋な関数が返した値を、戻り値のリストに入れる。
- `for`は**「結果を返す命令」**を返す関数（ただの値を受け取って命令を返す関数）をリストの各要素に対して実行し、命令が返した値を、戻り値のリストに入れる。
- `for_`は**「結果を返さない命令」**を返す関数（ただの値を受け取って命令を返す関数）をリストの各要素に対して実行し、何も返さない（`IO ()`を返す）。

ちなみに、`for_`のように、名前がアンダースコアで終わる高階関数は、アンダースコアがない関数の「値を返さないバージョン」であることが多いです。
