# 処理を繰り返し実行する (2)

コマンドラインからファイル名のリストを受け取って、その中身をファイル名と一緒に出力するコマンドを作りましょう。

1. コマンドライン引数のリストを取得します。
2. コマンドライン引数のリストの各要素に対して、次の処理を実行します:
    1. 各要素である文字列を、標準出力にputStrLn関数で出力します。
    2. 各要素である文字列をファイルのパスとして解釈し、その中身を読みます。
    3. 読んだファイルの中身を、改行で区切ったリストに変換します。
    4. 改行で区切ったリストの各要素の先頭に、スペースを2文字分付け足します。
    5. 各要素の先頭にスペースを付けた文字列のリストを、再び改行文字で結合します。
    6. 再び結合した文字列を、そのままputStr関数で出力します。

<!-- TODO: 入出力例を追加 -->

## 必要な知識

### `readFile`関数で、ファイルの中身をすべて読む

```
shell> echo "Read this file later!" > read-later.txt
```

```
ghci> readFile "read-later.txt"
"Read this file later!\n"
```

### `map`関数で、リストの各要素に対して「純粋な関数」を実行し、結果をまたリストに入れる

「高階関数」とは、「関数」を引数として受け取ったり、戻り値として「関数」を返すことができる関数です。  
ここでは、その中でも特によく使う（そのうちいくつかは今回の課題を解くのに使う）3つに絞って説明しましょう。

```
ghci> import Data.Char
ghci> toUpper 'a' -- シングルクォートで囲うこと！
'A'
```

`toUpper`を文字列に対して実行したい。

```
ghci> map toUpper "hello!"
"HELLO!"
```

リストの各要素、文字列の場合は各文字に対して`toUpper`関数を実行して、結果を入れた新しいリスト（文字の場合は文字列）を作る。

```
ghci> f x = x * 2 + 3
```

```
ghci> map f [2, 5, 10]
[7,13,23]
```

```
ghci> f 2
7
ghci> f 5
13
ghci> f 10
23
```

### ラムダ式で、その場限りの関数を定義する

`map`関数などを試すときに、いちいち名前の付いた関数を定義するのが面倒くさい、というときに

```
ghci> map (\x -> x * 2 + 3) [2, 5, 10]
[7,13,23]
```

バックスラッシュ、右細い矢印

```
ghci> (\x -> x * 2 + 3) 10
23
```

そのまま変数に代入すれば、関数として使用することもできるようになります。

```
ghci> f = (\x -> x * 2 + 3)
```

実際にはカッコで囲う必要があるのは、他の式との境界を明確にする必要がある場所だけ

```
ghci> f = \x -> x * 2 + 3
```

これらは同じ意味！

```
ghci> f = \x -> x * 2 + 3
ghci> f x = x * 2 + 3
```

ちなみに、引数が複数の場合、以下のようにバックスラッシュと右細い矢印の間に書く、引数名をスペースで区切ります。

```
ghci> f = \x y -> x * y + 3
```

```
ghci> f = \x y -> x * y + 3
ghci> f x y = x * y + 3
```

```
ghci> map (\i -> f 2 i) [2, 3, 5]
[7,9,13]
```

### `for_`関数で、リストの各要素に対して「命令」を実行する

Haskellでは「命令」という特別な関数と、それ以外の「純粋な関数」があります。

- 命令
    - `putStrLn`
    - `getLine`
- 純粋な関数
    - `splitOn`
    - `toUpper`
    - `+`, `*` などの四則演算に使う演算子

「命令」も関数の一つ。命令を受け取る高階関数もあります。
そのうちの一つが`for_`。

`putStrLn`のように、引数を一つだけ受け取る命令に対して使える。

リストの各要素に対して、指定した命令を実行する

```
ghci> for_ ["Hello, Everyone!", "How are you?", "I'm fine!"] putStrLn

<interactive>:2:1: error:
    Variable not in scope: for_ :: [[Char]] -> (String -> IO ()) -> t
```

```
ghci> import Data.Foldable
```

```
ghci> for_ ["Hello, Everyone!", "How are you?", "I'm fine!"] putStrLn
Hello, Everyone!
How are you?
I'm fine!
```

### `IO` 型を使って、自分で命令を定義する

高階関数`for_`が引数として受け取った命令に、リストの各要素を渡して呼び出している、という動作を確認するために、自分で命令を定義してみましょう。

例として、リストの長さを返す関数`length`を利用して、受け取ったリストの中身を標準出力に出力し、その後にその長さを出力する命令を定義してみます。

```
ghci> :{
ghci| printStringAndLength xs = do
ghci|   print xs
ghci|   print (length xs)
ghci| :}
```

```
ghci> printStringAndLength "abcdefghijk"
"abcdefghijk"
11
```

```
ghci> :{
ghci| printStringAndLength :: Show a => [a] -> IO ()
ghci| printStringAndLength xs = do
ghci|   print xs
ghci|   print (length xs)
ghci| :}
```

`IO`は引数を受け取らない命令です。
これまで「命令」と呼んでいたものには、引数を受け取るものが含まれてました（例えば`putStrLn`や、今定義した`printExerciseList`など）。
実際には`Show a => [a] -> IO ()`という型から読み取れるとおり、「引数（この場合`[a]`）を受け取って、命令を返す（純粋な）関数」によって、`putStrLn`関数といった、「引数を受け取る命令」は作られています。

`IO ()`の`()`は課題Xで説明したユニット型です。

`IO foo`で指定した型`foo`は、「命令を実行した結果返される値の型」を表します。

`getLine` は命令を実行した結果文字列を返すので`IO String`という型になってます。

```
ghci> :t getLine
getLine :: IO String
```

`IO ()`のように、ユニット型である場合、「実質結果として返す値がない命令」を表します。  
C言語などで言うところの`void`の代わりだと思ってください。

`for_`が扱うのは、この`IO ()`な命令、「実質結果として返す値がない命令」です。
「引数を一つ受け取って」「実質結果として返す値がない命令」を、「リストの各要素に対して」実行する。

### `for`関数で、リストの各要素に対して「命令」を実行し、結果をまたリストに入れる

<!-- TODO: for -> for_ -> IO の順番で説明する -->

### `for_`, `for`, `map`の違いまとめ

`for_`のように、名前がアンダースコアで終わる高階関数は、アンダースコアがない関数の「値を返さないバージョン」であることが多いです。

