# 処理を繰り返し実行する (1)

前の課題、課題10のプログラムをさらに書き換え、次のような動作をするようにしましょう（課題9と異なる箇所については**太字**にしておきます）。

1. **(A)** プロンプトとして「`Height Weight: `」と表示します。
2. 標準入力から1行の入力を受け取ります。
3. 受け取った入力を、空白で区切った文字列のリストとして代入します。
4. 代入した文字列のリストの要素数が
    1. 「2以上」であれば、1つめの要素を身長、2つめの要素を体重が書かれた文字列として解釈して、BMIを計算し、標準出力に出力してください。
    2. 「1」であれば、取得した要素を身長として解釈しつつ、下記の処理を行います。
        1. **(B)** プロンプトとして「`Weight: `」と表示します。
        2. 標準入力から1行の入力を受け取ります。
        3. **受け取った入力を、空白で区切った文字列のリストとして代入します。**
        4. **代入した文字列のリストの要素数が**
            1. **「1以上」であれば、1つめの要素を体重が書かれた文字列として解釈して、**BMIを計算し、標準出力に出力してください。
            2. **それ以外の場合は、「`Invalid input`」という形式のメッセージを標準出力に出力して、再度**(B)**から実行します。
    3. それ以外の場合は、「`Invalid input`」という形式のメッセージを標準出力に出力して、再度**(A)**から実行します。

要約すると、最初の「`Height Weight: `」を入力する箇所で間違っていたら最初からやり直して実行し、「`Weight: `」を入力する箇所で間違っていたら「`Weight: `」を入力する箇所からやり直す、ということです。

## 必要な知識

### 再帰呼び出しで「命令」を繰り返す

関数の再帰呼び出しというテクニックを使います。関数の再帰呼び出しは、Haskellで「処理を繰り返したい場合」における、最も基本的な方法です。他のプログラミング言語で処理を繰り返したい場合に使うであろう`for`文と似たものも、再帰呼び出しを利用して関数として定義されています（そうした関数については今後紹介します）。

#### 無限に再帰する（副題: 兵庫県警に逮捕されるには）

まずは再帰呼び出しの最も単純な形を紹介します。次のような関数を書いてみてください:

```haskell
loop = loop
```

はい、`loop = loop`という、文字通りトートロジーのような関数が出来てしまいした。GHCiで呼んでみましょう:

```haskell
ghci> loop

```

何も起きませんね...。しかもプロンプト`ghci>`がいつまで経っても表示されず、入力も一切受け付けてくれなくなります。

そう、これは`loop`関数が`loop`関数自身を何度も何度も呼び出して、無限ループを作ってしまっている状態です。何も起きず、延々と実行し続けてしまいます😴。

このままでは何が起きているかも分からないし、GHCiに新しい式を入力することすら出来ないので「Ctrl + C」を押して、強制的に中断させてください。残念ながら環境によっては、「Ctrl + C」によって`loop`関数の実行ばかりかGHCiまでもが終了してしまうことがあります。その場合は止むなく再起動しましょう。

この`loop`関数が再帰呼び出しの最も単純な形です。`loop`関数が`loop`関数自身を呼び出すことで処理の繰り返しを行っていることから「再帰呼び出し」と呼ばれています。このままでは無限ループすることしか出来ないので、実際には終了条件を設定して、条件を満たしたら再帰呼び出しをしないようにすることが多いです（終了条件をどのように設定するかは、後で例を示します）。

さて、`loop`関数によって再帰呼び出しの最も単純な形を知ることが出来ましたが、このままでは何が起きているかわからないので、`"aaaaaaaaaaaa"`と無限に叫び続ける関数に書き換えてみましょう:

```haskell
aaa = 'a' : aaa
```

`:` という演算子にリストの「先頭の要素」と「残りのリスト」を指定することで新しいリストを作れる、と言うことを思い出してください。この場合、`'a'`という文字を`aaa`と言うリストの先頭に置くことで、新しいリストを作っています。そう、`aaa`というリストの定義の中で`aaa`自身を参照していますね。これも`loop`と同様に再帰呼び出しをしているわけです。

さぁ何が起こるか、実行して確かめてみましょう:

```haskell
ghci> aaa
"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaInterupted.
```

※上記の例では途中で`Ctrl + C`で止めているので最後に`Interrupted.`と出力されています。`loop`の例と同様に、みなさんも`Ctrl + C`で止めましょう。

ダブルクォート`"`を出力した後、無限に`a`を繰り返し出力し続けたのがわかるでしょうか？GHCは大雑把に以下の操作を繰り返して`aaa`の中身をなんとかすべて読み取ろうと頑張ります:

1. `aaa`が表す文字列を`show`するために、`show`関数を文字列に対して適用した結果の最初の文字、すなわちダブルクォートを出力する
    - 課題hogeで学習したとおり、GHCiに入力した式は`show`関数を適用されることを思い出してください
2. 文字列の残りの文字も表示するために、`aaa`の定義`'a' : aaa`を参照する
3. `'a' : aaa`というリストの先頭の文字、つまり`:`の左辺である`'a'`を出力する
4. `'a' : aaa`から残りの文字を出力する必要があるので、`:`の右辺にあたる`aaa`を参照する
5. `aaa`の中身を参照すると、やはり`aaa`の定義である`'a' : aaa`なので、2.に戻る

このようにGHCは、与えられた式を必要に応じて少しずつ読み出すことで、`aaa`や`loop`のように再帰的に参照された式も、部分的にせよ評価してくれます。

再帰呼び出しは「命令」の中でも使えます。今度は文字を出力する`putChar`関数を使って、`oooooooooooo`と叫んでみましょう:

```haskell
ooo = do
  putChar 'o'
  ooo
```

早速定義をGHCiに読み込ませて実行してみると、期待通り`ooooooooooo`と延々出力し続けるのが分かります:

```haskell
> ooo
oooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooInterrupted.
```

※繰り返しになりますがこの例もやはり`Ctrl + C`で止めてください。無限ループの例はこれで最後です！

`putChar 'o'`という命令で文字`o`を出力した後、やはり`ooo`自身をもう一度呼び出しています。そのためまた`ooo`関数の定義を参照して、`do`における最初の命令`putChar 'o'`を実行して... の繰り返しです。先ほどの`aaa`とそっくりですね。

このように、定義している関数自身を呼び出す、つまり関数の再帰呼び出しを行うことで、同じ処理を何度でも繰り返すことが出来ます。でも、このままのやり方では`Ctrl + C`を押さないと実行を中断出来ませんし、とても不便ですよね？今回の課題では「受け取った入力を、空白で区切った文字列のリストとして代入」してから、その内容に応じて処理を繰り返したり、繰り返しを止めたりしなければなりません。そこで次の節では、`getLine`した結果に応じて中断出来る再帰関数を書いてみましょう。

#### 条件を満たしたら切り上げる

いよいよ、条件に応じて繰り返しを止めることが出来る関数を書いてみましょう。ここまで紹介したとおり、再帰呼び出しをすると関数は繰り返し呼び出されるので、条件を満たしているかチェックしたあと、再帰呼び出しを**しない**ことによって繰り返しを止めることができます。

例として「空文字列以外の文字列が入力される」という条件が満たされるまで、「名前を`getLine`する」という関数を紹介します:

```haskell
askUntilNonEmpty = do
    putStrLn "Enter your name:"
    string <- getLine
    case string of
        [] -> do
            putStrLn "Empty! Try again!"
            askUntilNonEmpty
        _ ->
            putStrLn ("Thanks, " ++ string ++ " san!")
```

実行した結果の例は以下の通りです:

```haskell
Enter your name:
-- <- 何も入力していない！
Empty! Try again!
Enter your name:
-- <- 何も入力していない！
Empty! Try again!
Enter your name:
Yuji -- <- 「Yuji」と入力した！
Thanks, Yuji san!
```

⚠️「--」で始まる行は、この`askUntilNonEmpty`関数を実行したユーザーが`getLine`関数に与えた入力に対するコメントです。実際には入力しないでくださいね。Haskellのソースコードにおけるコメントに倣って「--」で始めています。

実行例を見た限り、`askUntilNonEmpty`関数は期待通り動いているようです。ユーザーが何も入力していないときは`Empty! Try again!`と出力した上で再度`Enter your name:`と出力してユーザーに入力を求め、ユーザーが何か入力して初めて実行を終了しています。

では改めて、`askUntilNonEmpty`関数がどのように実装されているか確認してみましょう。

`getLine`で取得した`string`変数に対して、`case`式でパターンマッチすることで、`sting`が`[]`、すなわち空文字列かそうでないかで分岐しています。ここで「空文字列以外の文字列が入力される」という条件が満たされるかをチェックしているわけですね。そして`string`が空であれば、`askUntilNonEmpty`自身をもう一度呼び出します。そう、ここで再帰呼び出しをしているのです。「空文字列以外の文字列が入力される」までが`askUntilNonEmpty`を繰り返す条件なので、条件を満たしていない、`string`が空の場合は再帰呼び出しをしています。

一方、`string`が`[]`以外、つまり空文字列でない場合（上述の`case`式における`_ ->`で始まる箇所）は、再帰呼び出しをしていません。条件を満たしたのだから、もう繰り返す必要がないのです。結果、`askUntilNonEmpty`の繰り返し実行が終了します。

以上が、「条件に応じて繰り返しを止めることが出来る関数」の例です。再帰呼び出しをした場合は関数が繰り返し呼ばれるのだから、条件を満たした状態では単純に再帰呼び出しをしないことで繰り返しを止められる、ということが伝わったでしょうか？

もう1つ、条件を満たしたら繰り返しを止める関数の例を紹介させてください。先ほどの`askUntilNonEmpty`関数は「命令」を再帰呼び出しした例でしたが、今度は「命令」を伴わず、「純粋な計算」のみを行う関数（「純粋な関数」とも言います）の再帰呼び出しです。数値のリストに対して、リストのすべての要素に2をかける関数です:

```haskell
doubles xs =
    case xs of
        [] -> []
        x : xsLeft -> x * 2 : doubles xsLeft
```

念のため動作例も確認してみます:

```haskell
ghci> doubles [1, 2, 3]
[2,4,6]
```

ちゃんとすべての要素を2倍してますね！

先ほどの`askUntilNonEmpty`と同様に、`case`式で条件分岐することで、条件を満たしたら再帰呼び出しをしないことで繰り返しを止めています。`askUntilNonEmpty`が`getLine`という命令の結果によって分岐しているのに対して、`doubles`関数では引数`xs`の値を見て分岐しています。これは、「純粋な関数」とそうでない「命令」の重要な違いによるものです。

課題hoge(5?)で触れたとおり、「純粋な関数」は「同じ関数や演算子に同じ値を同じ順番で渡した場合、必ず同じ値を返す」という特徴があるので、関数に渡す値、すなわち引数を変えない限り、永遠に関数の実行結果も変わらないのです。従って「純粋な関数」がもう一度再帰するか判断するのにも、引数を見る以外に方法がありません。他の言語で繰り返しを行う`for`文などでは、変数を書き換えることでループを進めていたところ、「純粋な関数」の再帰呼び出しでは、**引数の値を変えることでループを進める**、と理解してください。

##### `doubles`関数が再帰を終えるまで

`doubles`関数の再帰の終了条件や、終了条件に向けて引数を変化させている、ということが分かったところで、`case`式の各条件分岐を詳細に見てみましょう。`case xs of`で始まる`case`式で、引数`xs`が空のリストであった場合とそれ以外、リストの先頭の要素`x`と残りのリスト`xsLeft`が取得できる場合とで分岐していますね。

第1に`xs`が空のリストであった場合、`[] -> []`と書かれているとおり、空のリストを返します。`doubles`関数は「リストのすべての要素に2をかける関数」ですが、空のリストが相手だと2をかける要素がないので、空のリストをそのまま返すしかありません。加えて、ここでは再帰呼び出しをしていないので、引数`xs`が空のリストになったら実行を止める、という点にも注目してください。

第2の場合、すなわち`x : xsLeft ->`で始まる行では、課題hoge(9?)で学習したリストの値コンストラクター`:`を利用して、`xs`がリストの先頭の要素`x`と残りのリスト`xsLeft`に分解できる場合を表しています。`:`の左辺がリストの先頭の要素、右辺が残りのリストをそれぞれ表していて、それぞれを指定した変数`x`と`xsLeft`に代入しているのでした。

その`x`・`xsLeft`を使って作った式が`x * 2 : doubles xsLeft`です。結構複雑なので1つずつ説明しましょう。まず、`x * 2`で、`xs`の先頭の要素`x`に2をかけています。次の`:`は、これまた課題hoge(9?)で学習したリストの値コンストラクターです。先ほどは`xs`を先頭の要素と残りのリストに**分解する**ために使用していましたが、ここでは左辺に先頭の要素、右辺に残りのリストを指定することで、**新しいリストを作る**関数として使われています。左辺は前述の`x * 2`でいいとして、注目すべきは右辺の`doubles xsLeft`です。ここで`doubles`関数の再帰呼び出しが出てきました！もう一度`doubles`関数が呼び出されます！その、もう一度呼び出した結果を`:`で新しいリストとしてくっつけているのが`x * 2 : doubles xsLeft`という式です。

`doubles xsLeft`という式で`doubles`関数をもう一度呼び出すとどうなるのか考えてみましょう。`xs`を分解してできた残りのリスト`xsLeft`は、必ず`xs`より要素が1つ少ないリストとなります。`x : xsLeft ->`というパターンマッチで分解した際、先頭の要素を取り出しているからです。なので、ここで再帰呼び出しされる`doubles`関数は、元々の`doubles`関数に渡した引数`xs`より要素が1つ少ないリストを受け取ることとなります。そして`doubles xsLeft`という式で再度呼ばれた`doubles`関数は、（変数名が変わって紛らわしいですが、前の呼び出しで`xsLeft`と呼ばれていた）引数`xs`を`case`式で分解します。そして`xs`が空のリストでなければ、また先頭の要素と残りのリストに分解します。このケースで`xs`を分解して作られた`xsLeft`はやはり`xs`より要素が1つ少ないリストです。

そうして`doubles`関数は、再帰呼び出しされる毎に受け取った引数`xs`より要素が1つ少ないリスト`xsLeft`を、もう一度`doubles`関数自身に渡して処理を繰り返します。結果、最終的に`xsLeft`は最も要素が少ないリスト、すなわち空のリストとして`doubles`関数に渡され、空のリストを受け取った`doubles`関数は、前述のとおり空のリストを返して、再帰呼び出しを止めます。以上が`doubles`関数がリストに対して再帰呼び出しをして止めるまでの流れです。

具体例で考えてみましょう。`doubles [100, 40]`という式を例にしてみます。

```hs
doubles [100, 40]
```

という式を👆に書いた`doubles`関数の定義に従って、👇のように書き換えてみます:

```hs
case [100, 40] of
    [] -> []
    x : xsLeft -> x * 2 : doubles xsLeft
```

これは`doubles`関数の定義における引数`xs`を実際に渡している`[100, 40]`で書き換えた式です。やはり`case`式で`[100, 40]`の中身をチェックしていますね。`[100, 40]`は空のリスト、すなわち`[]`ではないので、`x : xsLeft -> x * 2 : doubles xsLeft`のケースが実行されます。ここで、`x`には`[100, 40]`の先頭の要素`100`が、`xsLeft`には`[100, 40]`の残りのリスト`[40]`が代入されます。結果、`x * 2 : doubles xsLeft`という式は次のように書き換えられます:

```hs
100 * 2 : doubles [40]
```

`[100, 40]`の先頭の要素`100`に`2`をかけ、`:`で新しいリストの先頭の要素としてくっつけています。`:`の右辺、すなわち`100 * 2`を先頭としたリストの残りの要素はどうなるのでしょう？ ...と、ここで`doubles`関数の再帰呼び出し`doubles [40]`が出てきました！`[100, 40]`から先頭の要素`100`を抜いた`[40]`をさらに`doubles`関数で処理するわけですね！それではこの`doubles [40]`も`doubles`関数の定義に従って書き換えてみます👇:

```hs
case [40] of
    [] -> []
    x : xsLeft -> x * 2 : doubles xsLeft
```

先ほど`doubles [100, 40]`を書き換えたときに現れた`case [100, 40] of ...`と異なり、先頭の要素`100`を取り除いた`[40]`に対する`case`式が出てきました。抜け落ちた`100`はどこに行ったのか、って？最初の`doubles`関数の呼び出し（`doubles [100, 40]`）における`case`式で、`[100, 40]`を`100`と`[40]`に分解したとき、結果となる式`100 * 2 : doubles [40]`の`100`にあります！

このようにして、`doubles`関数は最初に受け取った引数の要素を1つずつ取り出しては処理しながら再帰呼び出しすることで、確実に再帰呼び出しを終わらせることができます。`case [40] of`で始まる`case`式では、`[40]`はまだ空のリスト`[]`ではないので`[40]`は`x`に`40`を、`xsLeft`に`[]`を代入しつつ分解されます。結果、


```hs
x * 2 : doubles xsLeft
```

という式は今度は👇という式に書き換えられます。

```hs
40 * 2 : doubles []
```

`:`の右辺に注目してください。`doubles []`とあるとおり、またしても`doubles`関数を再帰呼び出ししているのですが、いよいよ引数が空のリスト`[]`になりました！`doubles []`の結果は先ほども触れたとおり、単に空のリスト`[]`を返すので、これ以上再帰呼び出しをすることもなく、`doubles`関数の呼び出しは終了します。

従って、上記👆の式は、

```hs
40 * 2 : []
```

と置き換えられます。そして遡ると👆の結果は`doubles [40]`の結果ですので、さらに遡って`doubles [100, 40]`の結果であった、

```hs
100 * 2 : doubles [40]
```

この👆式も下👇のとおり書き換えられます。

```hs
100 * 2 : 40 * 2 : []
```

あとはリストの各要素に対するかけ算`*`を計算して、`:`を見慣れたリストのリテラルに置き換えれば、`doubles [100, 40]`の答えができあがりです！:

```hs
[200,80]
```

ちゃんとすべての要素を2倍にできてますね！

こちらの例のとおり、`doubles`関数は最初に受け取った引数のリストから、1つずつ要素を取り出しては残りのリストを引数にして再帰呼び出ししています。原則として、リストは要素を1つ取り出すとその分小さくなり、やがては空のリストになるので、`doubles`関数は引数として空のリストを受け取り、再帰呼び出しを終了させます。

以上のように純粋な関数の再帰呼び出しでは、関数への引数を変えながら再帰呼び出しをすることで処理を進めます。繰り返しになりますが、他の言語における`for`文などでは変数を書き換えることでループを進めていたところ、「純粋な関数」の再帰呼び出しでは、**引数の値を変えることでループを進める**、という点を改めて抑えておいてください。

なお、以上のように関数の定義に対して具体的な値を当てはめたり、その他の定理に従って書き換えることを「等式変形」といいます。本節のように関数の性質を理解するのを補助するほか、関数の性質を定理として証明することもできます。これに関連して「定理証明支援系」で調べてみると、面白い世界が覗けるでしょう。

### 何もしない「命令」で値を返す

続いて紹介するのは、今回の課題を解くのにおそらく必要になるであろう、`return`という関数です。`return`は他のプログラミング言語における`return`と意味が大きく異なりますが、使用する**場所**は他のプログラミング言語の`return`とちょっと似ています。「`IO`などの『命令』から何もしないで値を返す」ために使うと覚えてください。

早速使い方を紹介しましょう... といいたいところですが、その前に`return`がないとどういう場面で困るのか解説させてください。例えば、当課題で「条件を満たしたら切り上げる」関数として最初に紹介した`askUntilNonEmpty`関数を思い出してみてください。下👇に再掲します:

```haskell
askUntilNonEmpty = do
    putStrLn "Enter your name:"
    string <- getLine
    case string of
        [] -> do
            putStrLn "Empty! Try again!"
            askUntilNonEmpty
        _ ->
            putStrLn ("Thanks, " ++ string ++ " san!")
```

この関数は、GHCiで実行した結果をよくみると分かるとおり、実行した結果からなんらかの（便利な）値を得られるものではありません。例えば次のようにGHCiで実行した場合を見てみてください:

```haskell
ghci> askUntilNonEmpty
Enter your name:
 -- <-- ここはユーザーの入力
Empty! Try again!
Enter your name:
yuji -- <-- ここもユーザーの入力
Thanks, yuji san!
ghci> -- ^ putStrLn した文字列しか表示されてない！
```

GHCiは通常、入力した式の結果を表示してくれるものですが、`askUntilNonEmpty`を実行したときに出力されたものを探しても、`putStrLn`関数が表示した`Enter your name:`や`Thanks, yuji san!`という文字列しかありません！ユーザーが入力した文字列が表示されると便利そうですが、残念ながら実際にはそうなっていません。

なぜこうなるのかというと、それは`askUntilNonEmpty`関数の中で最後に実行される命令が「実行した結果からなんらかの（便利な）値を得られるもの」ではないからです。順を追って説明しましょう。まず、「`askUntilNonEmpty`関数の中で最後に実行される命令」とは、`askUntilNonEmpty`関数自身か、あるいは`putStrLn`関数です。`askUntilNonEmpty`における（最初の）`do`記法は👇の`case`式で終わっていますよね:

```haskell
    case string of
        [] -> do
            putStrLn "Empty! Try again!"
            askUntilNonEmpty
        _ ->
            putStrLn ("Thanks, " ++ string ++ " san!")
```

この大きな`case`式で最後に実行される命令が、`askUntilNonEmpty`関数で実行される最後の命令となります。`do`記法では、改行で区切って並べた命令を順番に実行して、最後に実行した命令の結果を返します。`askUntilNonEmpty`関数で言えば、`putStrLn "Enter your name:"`して`string <- getLine`した後の`case string of`で始まる式に、最後に実行される命令があるわけです。

では、件の`case`式で「最後に実行される命令」とはなにかというと、そう、それが`askUntilNonEmpty`関数自身か、あるいは`putStrLn`関数です。具体的にはこちら👇です。

```haskell
    case string of
        [] -> do
            putStrLn "Empty! Try again!"
            -- 👇この行か:
            askUntilNonEmpty
        _ ->
            -- 👇この行:
            putStrLn ("Thanks, " ++ string ++ " san!")
```

`case`式は、指定した式の値がどのような値であるかに応じて列挙した「いずれかの」命令を実行してくれるので、`case`式で「最後に実行される命令」は列挙した数だけあり得ます。上記👆の`case`式では`askUntilNonEmpty`と`putStrLn ("Thanks, " ++ string ++ " san!")`がその、最後に実行されうる命令の候補なのです。そのうち、`askUntilNonEmpty`という命令は文字通り`askUntilNonEmpty`関数の再帰呼び出しですので、この式からは`askUntilNonEmpty`関数において実際に最後に実行される命令が何かは分かりません。

というわけで、残った`putStrLn ("Thanks, " ++ string ++ " san!")`という命令が`askUntilNonEmpty`関数で「最後に実行される命令」です。そして、この`putStrLn ("Thanks, " ++ string ++ " san!")`という命令こそが、「実行した結果からなんらかの（便利な）値を得られるもの」ではないのです。`putStrLn`は単に引数として受け取った文字列を標準出力に書き出すだけで、それ以降役に立つ値を返してくれるものでもないのです。

さて、長々と`askUntilNonEmpty`関数が返す値について説明しましたが、この`askUntilNonEmpty`が`getLine`のように、値を返す命令にするにはどうすればよいでしょうか？特にこの場合、`string <- getLine`の行でユーザーが最後に入力した文字列を返すということにしましょう。

これまでに学習した「命令」の中で「実行した結果から便利な値を得られるもの」のうち、最もよく使ったであろう命令は`getLine`です。ではこれを、`askUntilNonEmpty`関数の最後の命令として実行してみるのはいかがでしょうか。つまり下記のように書き足すと言うことです:

```haskell
askUntilNonEmpty = do
    putStrLn "Enter your name:"
    string <- getLine
    case string of
        [] -> do
            putStrLn "Empty! Try again!"
            askUntilNonEmpty
        _ -> do     -- ここを`do`にして、
            putStrLn ("Thanks, " ++ string ++ " san!")
            getLine -- <- この行を追加！
```

試しに実行してみましょう:

```haskell
ghci> askUntilNonEmpty
Enter your name:
yuji -- <-- ここはユーザーの入力
Thanks, yuji san!

```

実行できました！... が、なぜか`Thanks, yuji san!`と出力したところで止まってしまいました。GHCiのプロンプト`ghci>`が表示されていないことから、まだ`askUntilNonEmpty`関数の実行が終了していないようです。

どうしたものかと思ってEnterキー（またはReturnキー）を押してみると、空の文字列らしきもの`""`に続いて、GHCiのプロンプト`ghci>`が表示されました。無事`askUntilNonEmpty`関数の実行が終了したようです😌。

```haskell
ghci> askUntilNonEmpty
Enter your name:
yuji -- <-- ここはユーザーの入力
Thanks, yuji san!
 -- ここでEnterまたはReturn
""
ghci>
```

なぜこのような振る舞いになったのでしょう？答えは単純で、`putStrLn ("Thanks, " ++ string ++ " san!")`でユーザーが入力した`string`を出力した後に、もう一度`getLine`を呼んだからです。`getLine`関数は文字通り標準入力から1行文字列を読む命令であり、**呼び出した時点で**標準入力を読み取り始め、その場で読み取った文字列を返します。なので、手前の`string <- getLine`の行で取得した`string`なんて、知ったこっちゃないのです。先ほどの実行例で空の文字列らしきもの`""`が表示されたのは、最後の`getLine`の実行時に何も入力せず、すぐにEnter（またはReturn）を押したためです。

以上のとおり、`getLine`は呼び出したらその場で何かの入出力処理を行った上で値を返す命令なので、今回のように手前の行でとってきた文字列（`string`変数）を何もしないでそのまま返す、ということはできません。そう、欲しいのは`string`に対して**何もしない**、つまり一切の入出力処理を行わずに、単に命令の実行結果として返す関数なのです。

そこでやっと出てくるのが`return`関数です！`askUntilNonEmpty`関数における「最後に実行される命令」を次のように`return string`にしてください:

```haskell
askUntilNonEmpty = do
    putStrLn "Enter your name:"
    string <- getLine
    case string of
        [] -> do
            putStrLn "Empty! Try again!"
            askUntilNonEmpty
        _ -> do           -- やっぱりここを`do`にして、
            putStrLn ("Thanks, " ++ string ++ " san!")
            return string -- <- この行を追加しよう！
```

他のプログラミング言語に慣れているとすごく紛らわしいですが、`return`はHaskellの特別な構文ではなく、**ただの関数**です。単に**何もしないで指定した値を返すだけ**の「命令」を作るための関数です。仮に複数行ある`do`記法の途中で実行しても、`do`記法に書いた「命令」の実行が中断されることはありません。なので例えば👇のように`askUntilNonEmpty`関数の途中に書いても、`askUntilNonEmpty`関数の実行は中断されず、特に何の意味もありません:

```haskell
askUntilNonEmpty = do
    putStrLn "Enter your name:"
    string <- getLine
    return "Useless return!" -- ここに return と書いても意味がない！無視される！
    case string of
        -- ... 省略 ...
```

たまたま「命令」における`do`の最後で実行されることが多いため、`return`と呼ぶことで、なんだか命令型言語っぽい見た目になるから`return`と呼ぶのだと覚えてください。
