# 処理を繰り返し実行する (1)

前の課題、課題10のプログラムをさらに書き換え、次のような動作をするようにしましょう。  
（課題9と異なる箇所については**太字**にしておきます。）

1. **(A)** プロンプトとして「`Height Weight: `」と表示します。
2. 標準入力から1行の入力を受け取ります。
3. 受け取った入力を、空白で区切った文字列のリストとして代入します。
4. 代入した文字列のリストの要素数が
    1. 「2以上」であれば、1つめの要素を身長、2つめの要素を体重が書かれた文字列として解釈して、BMIを計算し、標準出力に出力してください。
    2. 「1」であれば、取得した要素を身長として解釈しつつ、下記の処理を行います。
        1. **(B)** プロンプトとして「`Weight: `」と表示します。
        2. 標準入力から1行の入力を受け取ります。
        3. **受け取った入力を、空白で区切った文字列のリストとして代入します。**
        4. **代入した文字列のリストの要素数が**
            1. **「1以上」であれば、1つめの要素を体重が書かれた文字列として解釈して、**BMIを計算し、標準出力に出力してください。
            2. **それ以外の場合は、「`Invalid input`」という形式のメッセージを標準出力に出力して、再度**(B)**から実行します。
    3. それ以外の場合は、「`Invalid input`」という形式のメッセージを標準出力に出力して、再度**(A)**から実行します。

要約すると、最初の「`Height Weight: `」を入力する箇所で間違っていたら最初からやり直して実行し、「`Weight: `」を入力する箇所で間違っていたら「`Weight: `」を入力する箇所からやり直す、ということです。

## 必要な知識

### 再帰呼び出しで「命令」を繰り返す

関数の再帰呼び出しというテクニックを使います。  
関数の再帰呼び出しは、Haskellで「処理を繰り返したい場合」における、最も基本的な方法です。  
他のプログラミング言語で処理を繰り返したい場合に使うであろう`for`文と似たものも、再帰呼び出しを利用して関数として定義されています（そうした関数については今後紹介します）。

#### 無限に再帰する（副題: 兵庫県警に逮捕されるには）

```haskell
loop = loop
```

```haskell
ghci> loop

```

何も起きないで実行し続ける。  
特に終了条件を指定しない限り、そのまま実行し続ける。  
終了条件を指定する方法は後ほど説明します。

いずれにしても、このままでは何が起きているかわからないので、`"aaaaaaaaaaaa"`と叫び続ける関数を定義しましょう。

```haskell
aaaaaaa = 'a' : aaaaaaa
```

`:` という演算子にリストの「先頭の要素」と「残りのリスト」を指定することで、新しいリストを作れる、と言うことを思い出してください。

この場合、`'a'`という文字を`aaaaaaa`と言うリストの先頭に置くことで、新しいリストを作っています。  

実行してみましょう。

```haskell
ghci> aaaaaaa
"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaInterupted.
```

ダブルクォート`"`を出力した後、無限に`a`を繰り返し出力し続けたのがわかるでしょうか？

「命令」の中でも再帰呼び出しは使えます。  
今度は文字を出力する`putChar`関数を使って、`oooooooooooo`と叫んでみましょう。

```haskell
ooooooo = do
  putChar 'o'
  ooooooo
```

```haskell
> ooooooo
oooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooInterrupted.
```

#### 条件を満たしたら切り上げる

「空文字以外の文字列が入力される」という条件が満たされるまで、「名前を`getLine`する」という命令を繰り返す。

```haskell
askUntilNonEmpty = do
    putStrLn "Enter your name:"
    string <- getLine
    case string of
        [] -> do
            putStrLn "Empty! Try again!"
            askUntilNonEmpty
        _ ->
            putStrLn ("Thanks, " ++ string ++ " san!")
```

「リストが空になる」という条件が満たされるまで、「リストの各要素を2倍にする」という計算を繰り返す。  
`getLine`のような「命令」は実行する度に結果が変わるけど、普通の引数は変わらないので、自分で引数を変える必要がある。

```haskell
doubles xs =
    case xs of
        [] -> []
        x : xsLeft -> x * 2 : doubles xsLeft
```

他の言語の`for`では、変数を書き換えることでループを進めていたところ、普通の関数の再帰呼び出しでは、**引数の値を変える**ことでループを進める。

### 何もしない「命令」で値を返す

今回の課題を解くに当たり、おそらく必要になるであろう知識

```haskell
ghci> askUntilNonEmpty
Enter your name:

Empty! Try again!
Enter your name:
yuji
Thanks, yuji san!
ghci> -- ^^^^^ 値が返ってきてない！
```

`askUntilNonEmpty`は値を返さない！最後に実行しているのが`putStrLn`だから。  
`getLine`のように、値を返す命令にするには？

`getLine`をもう一度実行するのはおかしい。  
`getLine`がもう一度ユーザーに入力を求める上、戻り値が変わってしまう。

```haskell
askUntilNonEmpty = do
    putStrLn "Enter your name:"
    string <- getLine
    case string of
        [] -> do
            putStrLn "Empty! Try again!"
            askUntilNonEmpty
        _ -> do
            putStrLn ("Thanks, " ++ string ++ " san!")
            getLine -- <- この行を追加してもダメ！
```

返したいのは、`string <- getLine`の行で代入される`string`。  
`getLine`のように「標準入力から入力を受け取って値を返す」のではなく、`string`を**何もしないで`askUntilNonEmpty`という「命令」の結果として返す**には？

```haskell
askUntilNonEmpty = do
    putStrLn "Enter your name:"
    string <- getLine
    case string of
        [] -> do
            putStrLn "Empty! Try again!"
            askUntilNonEmpty
        _ -> do
            putStrLn ("Thanks, " ++ string ++ " san!")
            return string -- <- この行を追加しよう！
```

`return`はHaskellの特別な構文ではなく、単に**何もしないで指定した値を返すだけの「命令」**。  
「命令」の途中で実行しても、「命令」の実行が**中断されることはない**。

```haskell
askUntilNonEmpty = do
    putStrLn "Enter your name:"
    string <- getLine
    return "Useless return!" -- ここに return と書いても意味がない！無視される！
    case string of
        [] -> do
            putStrLn "Empty! Try again!"
            askUntilNonEmpty
        _ -> do
            putStrLn ("Thanks, " ++ string ++ " san!")
            return string -- <- この行を追加しよう！
```

たまたま「命令」における`do`の最後で実行されることが多いから、`return`と呼ぶことで、なんか命令型言語っぽい見た目になるから`return`と呼ぶのだと覚えてください。

なので、下記のようにも書ける。

「何もしない命令」を実行して、その結果を`x`に代入

```haskell
ghci> x <- return 1
ghci> x
1
```

実質やっていることは下記と同じ。

```haskell
ghci> x = 1
ghci> x
1
```
