# 処理を繰り返し実行する (1)

前の課題、課題10のプログラムをさらに書き換え、次のような動作をするようにしましょう。  
（課題9と異なる箇所については**太字**にしておきます。）

1. **(A)** プロンプトとして「`Height Weight: `」と表示します。
2. 標準入力から1行の入力を受け取ります。
3. 受け取った入力を、空白で区切った文字列のリストとして代入します。
4. 代入した文字列のリストの要素数が
    1. 「2以上」であれば、1つめの要素を身長、2つめの要素を体重が書かれた文字列として解釈して、BMIを計算し、標準出力に出力してください。
    2. 「1」であれば、取得した要素を身長として解釈しつつ、下記の処理を行います。
        1. **(B)** プロンプトとして「`Weight: `」と表示します。
        2. 標準入力から1行の入力を受け取ります。
        3. **受け取った入力を、空白で区切った文字列のリストとして代入します。**
        4. **代入した文字列のリストの要素数が**
            1. **「1以上」であれば、1つめの要素を体重が書かれた文字列として解釈して、**BMIを計算し、標準出力に出力してください。
            2. **それ以外の場合は、「`Invalid input`」という形式のメッセージを標準出力に出力して、再度**(B)**から実行します。
    3. それ以外の場合は、「`Invalid input`」という形式のメッセージを標準出力に出力して、再度**(A)**から実行します。

要約すると、最初の「`Height Weight: `」を入力する箇所で間違っていたら最初からやり直して実行し、「`Weight: `」を入力する箇所で間違っていたら「`Weight: `」を入力する箇所からやり直す、ということです。

## 必要な知識

### 再帰呼び出しで「命令」を繰り返す

関数の再帰呼び出しというテクニックを使います。関数の再帰呼び出しは、Haskellで「処理を繰り返したい場合」における、最も基本的な方法です。他のプログラミング言語で処理を繰り返したい場合に使うであろう`for`文と似たものも、再帰呼び出しを利用して関数として定義されています（そうした関数については今後紹介します）。

#### 無限に再帰する（副題: 兵庫県警に逮捕されるには）

まずは再帰呼び出しの最も単純な形を紹介します。次のような関数を書いてみてください:

```haskell
loop = loop
```

はい、`loop = loop`という、文字通りトートロジーのような関数が出来てしまいした。GHCiで呼んでみましょう:

```haskell
ghci> loop

```

何も起きませんね...。しかもプロンプト`ghci>`がいつまで経っても表示されず、入力も一切受け付けてくれなくなります。

そう、これは`loop`関数が`loop`関数自身を何度も何度も呼び出して、無限ループを作ってしまっている状態です。何も起きず、延々と実行し続けてしまいます😴。

このままでは何が起きているかも分からないし、GHCiに新しい式を入力することすら出来ないので「Ctrl + C」を押して、強制的に中断させてください。残念ながら環境によっては、「Ctrl + C」によって`loop`関数の実行ばかりかGHCiまでもが終了してしまうことがあります。その場合は止むなく再起動しましょう。

この`loop`関数が再帰呼び出しの最も単純な形です。`loop`関数が`loop`関数自身を呼び出すことで処理の繰り返しを行っていることから「再帰呼び出し」と呼ばれています。このままでは無限ループすることしか出来ないので、実際には終了条件を設定して、条件を満たしたら再帰呼び出しをしないようにすることが多いです（終了条件をどのように設定するかは、後で例を示します）。

さて、`loop`関数によって再帰呼び出しの最も単純な形を知ることが出来ましたが、このままでは何が起きているかわからないので、`"aaaaaaaaaaaa"`と無限に叫び続ける関数に書き換えてみましょう:

```haskell
aaa = 'a' : aaa
```

`:` という演算子にリストの「先頭の要素」と「残りのリスト」を指定することで新しいリストを作れる、と言うことを思い出してください。この場合、`'a'`という文字を`aaa`と言うリストの先頭に置くことで、新しいリストを作っています。そう、`aaa`というリストの定義の中で`aaa`自身を参照していますね。これも`loop`と同様に再帰呼び出しをしているわけです。

さぁ何が起こるか、実行して確かめてみましょう:

```haskell
ghci> aaa
"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaInterupted.
```

※上記の例では途中で`Ctrl + C`で止めているので最後に`Interrupted.`と出力されています。`loop`の例と同様に、みなさんも`Ctrl + C`で止めましょう。

ダブルクォート`"`を出力した後、無限に`a`を繰り返し出力し続けたのがわかるでしょうか？GHCは大雑把に以下の操作を繰り返して`aaa`の中身をなんとかすべて読み取ろうと頑張ります:

1. `aaa`が表す文字列を`show`するために、`show`関数を文字列に対して適用した結果の最初の文字、すなわちダブルクォートを出力する
    - 課題hogeで学習したとおり、GHCiに入力した式は`show`関数を適用されることを思い出してください
2. 文字列の残りの文字も表示するために、`aaa`の定義`'a' : aaa`を参照する
3. `'a' : aaa`というリストの先頭の文字、つまり`:`の左辺である`'a'`を出力する
4. `'a' : aaa`から残りの文字を出力する必要があるので、`:`の右辺にあたる`aaa`を参照する
5. `aaa`の中身を参照すると、やはり`aaa`の定義である`'a' : aaa`なので、2.に戻る

このようにGHCは、与えられた式を必要に応じて少しずつ読み出すことで、`aaa`や`loop`のように再帰的に参照された式も、部分的にせよ評価してくれます。

再帰呼び出しは「命令」の中でも使えます。今度は文字を出力する`putChar`関数を使って、`oooooooooooo`と叫んでみましょう:

```haskell
ooo = do
  putChar 'o'
  ooo
```

早速定義をGHCiに読み込ませて実行してみると、期待通り`ooooooooooo`と延々出力し続けるのが分かります:

```haskell
> ooo
oooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooInterrupted.
```

※繰り返しになりますがこの例もやはり`Ctrl + C`で止めてください。無限ループの例はこれで最後のはずです！

`putChar 'o'`という命令で文字`o`を出力した後、やはり`ooo`自身をもう一度呼び出しています。そのためまた`ooo`の定義を参照して、`do`における最初の命令`putChar 'o'`を実行して... の繰り返しです。先ほどの`aaa`とそっくりですね。

このように、定義している関数自身を呼び出す、つまり関数の再帰呼び出しを行うことで、同じ処理を何度でも繰り返すことが出来ます。でも、このままのやり方では`Ctrl + C`を押さないと実行を中断出来ませんし、とても不便ですよね？今回の課題では「受け取った入力を、空白で区切った文字列のリストとして代入」してから、その内容に応じて処理を繰り返したり、繰り返しを止めたりしなければなりません。そこで次の節では、`getLine`した結果に応じて中断出来る再帰関数を書いてみましょう。

#### 条件を満たしたら切り上げる

いよいよ、条件に応じて繰り返しを止めることが出来る関数を書いてみましょう。ここまで紹介したとおり、再帰呼び出しをすると関数は繰り返し呼び出されるので、条件を満たしているかチェックしたあと、再帰呼び出しをしないことによって繰り返しを止めることができます。

例として「空文字列以外の文字列が入力される」という条件が満たされるまで、「名前を`getLine`する」という関数を紹介します:

```haskell
askUntilNonEmpty = do
    putStrLn "Enter your name:"
    string <- getLine
    case string of
        [] -> do
            putStrLn "Empty! Try again!"
            askUntilNonEmpty
        _ ->
            putStrLn ("Thanks, " ++ string ++ " san!")
```

実行した結果の例は以下の通りです:

```haskell
Enter your name:
-- <- 何も入力していない！
Empty! Try again!
Enter your name:
-- <- 何も入力していない！
Empty! Try again!
Enter your name:
Yuji -- <- 「Yuji」と入力した！
Thanks, Yuji san!
```

「--」で始まる行は、この`askUntilNonEmpty`関数のユーザーが`getLine`関数を実行した際に与えた入力に対するコメントです。Haskellのソースコードにおけるコメントに倣って「--」で始めています。

実行例を見た限り、`askUntilNonEmpty`関数は期待通り動いているようです。ユーザーが何も入力していないときは`Empty! Try again!`と出力した上でもう一度`Enter your name:`と尋ねて再度ユーザーに入力を求め、ユーザーが何か入力して初めて実行を終了しています。

では改めて、`askUntilNonEmpty`関数がどのように実装されているか確認してみましょう。

`getLine`で取得した`string`変数に対して、`case`式でパターンマッチすることで、`sting`が`[]`、すなわち空文字列かそうでないかで分岐しています。ここで「空文字列以外の文字列が入力される」という条件が満たされるかをチェックしているわけですね。そして`string`が空であれば、`askUntilNonEmpty`自身をもう一度呼び出します。そう、ここで再帰呼び出しをしているのです。「空文字列以外の文字列が入力される」までが`askUntilNonEmpty`を繰り返す条件なので、条件を満たしていない、`string`が空の場合は再帰呼び出しをしています。

一方、`string`が`[]`以外、つまり空文字列でない場合（上述の`case`式における`_ ->`で始まる箇所）は、再帰呼び出しをいていません。条件を満たしたのだから、もう繰り返す必要がないので、再帰呼び出しもしません。結果、`askUntilNonEmpty`の繰り返し実行が終了します。

以上が、「条件に応じて繰り返しを止めることが出来る関数」の例です。再帰呼び出しをした場合は関数が繰り返し呼ばれるので、条件を満たした状態では、単純に再帰呼び出しをしないことで、繰り返しを止められる、ということが伝わったでしょうか？

もう一つ、条件を満たしたら繰り返しを止める関数の例を紹介させてください。先ほどの`askUntilNonEmpty`関数は「命令」を再帰呼び出しした例でしたが、今度は「命令」を伴わず、「純粋な計算」のみを行う関数（「純粋な関数」とも言います）での再帰呼び出しです。

hoge

「リストが空になる」という条件が満たされるまで、「リストの各要素を2倍にする」という計算を繰り返す。  
`getLine`のような「命令」は実行する度に結果が変わるけど、普通の引数は変わらないので、自分で引数を変える必要がある。

```haskell
doubles xs =
    case xs of
        [] -> []
        x : xsLeft -> x * 2 : doubles xsLeft
```

他の言語の`for`では、変数を書き換えることでループを進めていたところ、普通の関数の再帰呼び出しでは、**引数の値を変える**ことでループを進める。

### 何もしない「命令」で値を返す

今回の課題を解くに当たり、おそらく必要になるであろう知識

```haskell
ghci> askUntilNonEmpty
Enter your name:

Empty! Try again!
Enter your name:
yuji
Thanks, yuji san!
ghci> -- ^^^^^ 値が返ってきてない！
```

`askUntilNonEmpty`は値を返さない！最後に実行しているのが`putStrLn`だから。  
`getLine`のように、値を返す命令にするには？

`getLine`をもう一度実行するのはおかしい。  
`getLine`がもう一度ユーザーに入力を求める上、戻り値が変わってしまう。

```haskell
askUntilNonEmpty = do
    putStrLn "Enter your name:"
    string <- getLine
    case string of
        [] -> do
            putStrLn "Empty! Try again!"
            askUntilNonEmpty
        _ -> do
            putStrLn ("Thanks, " ++ string ++ " san!")
            getLine -- <- この行を追加してもダメ！
```

返したいのは、`string <- getLine`の行で代入される`string`。  
`getLine`のように「標準入力から入力を受け取って値を返す」のではなく、`string`を**何もしないで`askUntilNonEmpty`という「命令」の結果として返す**には？

```haskell
askUntilNonEmpty = do
    putStrLn "Enter your name:"
    string <- getLine
    case string of
        [] -> do
            putStrLn "Empty! Try again!"
            askUntilNonEmpty
        _ -> do
            putStrLn ("Thanks, " ++ string ++ " san!")
            return string -- <- この行を追加しよう！
```

`return`はHaskellの特別な構文ではなく、単に**何もしないで指定した値を返すだけの「命令」**。  
「命令」の途中で実行しても、「命令」の実行が**中断されることはない**。

```haskell
askUntilNonEmpty = do
    putStrLn "Enter your name:"
    string <- getLine
    return "Useless return!" -- ここに return と書いても意味がない！無視される！
    case string of
        [] -> do
            putStrLn "Empty! Try again!"
            askUntilNonEmpty
        _ -> do
            putStrLn ("Thanks, " ++ string ++ " san!")
            return string -- <- この行を追加しよう！
```

たまたま「命令」における`do`の最後で実行されることが多いから、`return`と呼ぶことで、なんか命令型言語っぽい見た目になるから`return`と呼ぶのだと覚えてください。

なので、下記のようにも書ける。

「何もしない命令」を実行して、その結果を`x`に代入

```haskell
ghci> x <- return 1
ghci> x
1
```

実質やっていることは下記と同じ。

```haskell
ghci> x = 1
ghci> x
1
```
