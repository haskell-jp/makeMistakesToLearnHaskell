# 処理を繰り返し実行する (1)

前の課題、課題10のプログラムをさらに書き換え、次のような動作をするようにしましょう。  
（課題9と異なる箇所については**太字**にしておきます。）

1. **(A)** プロンプトとして「`Height Weight: `」と表示します。
2. 標準入力から1行の入力を受け取ります。
3. 受け取った入力を、空白で区切った文字列のリストとして代入します。
4. 代入した文字列のリストの要素数が
    1. 「2以上」であれば、1つめの要素を身長、2つめの要素を体重が書かれた文字列として解釈して、BMIを計算し、標準出力に出力してください。
    2. 「1」であれば、下記の処理を行います。
        1. **(B)** プロンプトとして「`Weight: `」と表示します。
        2. 標準入力から1行の入力を受け取ります。
        3. **受け取った入力を、空白で区切った文字列のリストとして代入します。**
        4. **代入した文字列のリストの要素数が**
            1. **「1以上」であれば、1つめの要素を体重が書かれた文字列として解釈して、**BMIを計算し、標準出力に出力してください。
            2. **それ以外の場合は、「`Invalid input: <入力した文字列>`」という形式のメッセージを標準出力に出力して、**再度(B)から実行します**。
    3. それ以外の場合は、「`Invalid input: <入力した文字列>`」という形式のメッセージを標準出力に出力して、**再度(A)から実行**します。

要約すると、最初の「`Height Weight: `」を入力する箇所で間違っていたら最初から実行し、「`Weight: `」を入力する箇所で間違っていたら「`Weight: `」を入力する箇所からやり直す、ということです。

## 必要な知識

### 再帰呼び出しで「命令」を繰り返す

関数の再帰呼び出しというテクニックを使います。  
再帰呼び出しは、Haskellで「処理を繰り返したい場合」における、最も基本的な方法です。  
他のプログラミング言語で処理を繰り返したい場合に使うであろう`for`文と似たものも、関数として再帰呼び出しを利用して定義されています。

#### 無限に再帰する（副題: 兵庫県警に逮捕されるには）

```haskell
loop = loop
```

```haskell
ghci> loop

```

何も起きないで実行し続ける。  
特に終了条件を指定しない限り、そのまま実行し続ける。  
終了条件を指定する方法は後ほど説明します。

いずれにしても、このままでは何が起きているかわからないので、`"aaaaaaaaaaaa"`と叫び続ける関数を定義しましょう。

```haskell
aaaaaaa = 'a' : aaaaaaa
```

`:` という演算子にリストの「先頭の要素」と「残りのリスト」を指定することで、新しいリストを作れる、と言うことを思い出してください。

この場合、`'a'`という文字を`aaaaaaa`と言うリストの先頭に置くことで、新しいリストを作っています。  

実行してみましょう。

```haskell
ghci> aaaaaaa
"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaInterupted.
```

ダブルクォート`"`を出力した後、無限に`a`を繰り返し出力し続けたのがわかるでしょうか？

「命令」の中でも再帰呼び出しは使えます。  
今度は文字を出力する`putChar`関数を使って、`oooooooooooo`と叫んでみましょう。

```haskell
ooooooo = do
  putChar 'o'
  ooooooo
```

```haskell
> ooooooo
oooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooInterrupted.
```

#### 条件を満たしたら切り上げる

```haskell
askUntilNonEmpty = do
    putStrLn "Enter your name:"
    string <- getLine
    case string of
        [] -> do
            putStrLn "Empty! Try again!"
            askUntilNonEmpty
        _ -> 
            putStrLn ("Thanks, " ++ string ++ " san!")
```

「命令」は実行する度に結果が変わるけど、普通の引数は変わらないので、自分で引数を変える必要がある

```haskell
doubles xs =
    case xs of
        [] -> []
        x : xsLeft -> x * 2 : doubles xsLeft
```

### 何もしない「命令」で値を返す

```haskell
askUntilNonEmpty = do
    putStrLn "Enter your name:"
    string <- getLine
    case string of
        [] -> do
            putStrLn "Empty! Try again!"
            askUntilNonEmpty
        _ -> 
            putStrLn ("Thanks, " ++ string ++ " san!")
            return string
```
