# 処理を繰り返し実行する (1)

前の課題、課題10のプログラムをさらに書き換え、次のような動作をするようにしましょう。  
（課題9と異なる箇所については**太字**にしておきます。）

1. **(A)** プロンプトとして「`Height Weight: `」と表示します。
2. 標準入力から1行の入力を受け取ります。
3. 受け取った入力を、空白で区切った文字列のリストとして代入します。
4. 代入した文字列のリストの要素数が
    1. 「2以上」であれば、1つめの要素を身長、2つめの要素を体重が書かれた文字列として解釈して、BMIを計算し、標準出力に出力してください。
    2. 「1」であれば、取得した要素を身長として解釈しつつ、下記の処理を行います。
        1. **(B)** プロンプトとして「`Weight: `」と表示します。
        2. 標準入力から1行の入力を受け取ります。
        3. **受け取った入力を、空白で区切った文字列のリストとして代入します。**
        4. **代入した文字列のリストの要素数が**
            1. **「1以上」であれば、1つめの要素を体重が書かれた文字列として解釈して、**BMIを計算し、標準出力に出力してください。
            2. **それ以外の場合は、「`Invalid input`」という形式のメッセージを標準出力に出力して、再度**(B)**から実行します。
    3. それ以外の場合は、「`Invalid input`」という形式のメッセージを標準出力に出力して、再度**(A)**から実行します。

要約すると、最初の「`Height Weight: `」を入力する箇所で間違っていたら最初からやり直して実行し、「`Weight: `」を入力する箇所で間違っていたら「`Weight: `」を入力する箇所からやり直す、ということです。

## 必要な知識

### 再帰呼び出しで「命令」を繰り返す

関数の再帰呼び出しというテクニックを使います。関数の再帰呼び出しは、Haskellで「処理を繰り返したい場合」における、最も基本的な方法です。他のプログラミング言語で処理を繰り返したい場合に使うであろう`for`文と似たものも、再帰呼び出しを利用して関数として定義されています（そうした関数については今後紹介します）。

#### 無限に再帰する（副題: 兵庫県警に逮捕されるには）

まずは再帰呼び出しの最も単純な形を紹介します。次のような関数を書いてみてください:

```haskell
loop = loop
```

はい、`loop = loop`という、文字通りトートロジーのような関数が出来てしまいした。GHCiで呼んでみましょう:

```haskell
ghci> loop

```

何も起きませんね...。しかもプロンプト`ghci>`がいつまで経っても表示されず、入力も一切受け付けてくれなくなります。

そう、これは`loop`関数が`loop`関数自身を何度も何度も呼び出して、無限ループを作ってしまっている状態です。何も起きず、延々と実行し続けてしまいます😴。

このままでは何が起きているかも分からないし、GHCiに新しい式を入力することすら出来ないので「Ctrl + C」を押して、強制的に中断させてください。残念ながら環境によっては、「Ctrl + C」によって`loop`関数の実行ばかりかGHCiまでもが終了してしまうことがあります。その場合は止むなく再起動しましょう。

この`loop`関数が再帰呼び出しの最も単純な形です。`loop`関数が`loop`関数自身を呼び出すことで処理の繰り返しを行っていることから「再帰呼び出し」と呼ばれています。このままでは無限ループすることしか出来ないので、実際には終了条件を設定して、条件を満たしたら再帰呼び出しをしないようにすることが多いです（終了条件をどのように設定するかは、後で例を示します）。

さて、`loop`関数によって再帰呼び出しの最も単純な形を知ることが出来ましたが、このままでは何が起きているかわからないので、`"aaaaaaaaaaaa"`と無限に叫び続ける関数に書き換えてみましょう:

```haskell
aaa = 'a' : aaa
```

`:` という演算子にリストの「先頭の要素」と「残りのリスト」を指定することで新しいリストを作れる、と言うことを思い出してください。この場合、`'a'`という文字を`aaa`と言うリストの先頭に置くことで、新しいリストを作っています。そう、`aaa`というリストの定義の中で`aaa`自身を参照していますね。これも`loop`と同様に再帰呼び出しをしているわけです。

さぁ何が起こるか、実行して確かめてみましょう:

```haskell
ghci> aaa
"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaInterupted.
```

※上記の例では途中で`Ctrl + C`で止めているので最後に`Interrupted.`と出力されています。`loop`の例と同様に、みなさんも`Ctrl + C`で止めましょう。

ダブルクォート`"`を出力した後、無限に`a`を繰り返し出力し続けたのがわかるでしょうか？GHCは大雑把に以下の操作を繰り返して`aaa`の中身をなんとかすべて読み取ろうと頑張ります:

1. `aaa`が表す文字列を`show`するために、`show`関数を文字列に対して適用した結果の最初の文字、すなわちダブルクォートを出力する
    - 課題hogeで学習したとおり、GHCiに入力した式は`show`関数を適用されることを思い出してください
2. 文字列の残りの文字も表示するために、`aaa`の定義`'a' : aaa`を参照する
3. `'a' : aaa`というリストの先頭の文字、つまり`:`の左辺である`'a'`を出力する
4. `'a' : aaa`から残りの文字を出力する必要があるので、`:`の右辺にあたる`aaa`を参照する
5. `aaa`の中身を参照すると、やはり`aaa`の定義である`'a' : aaa`なので、2.に戻る

このようにGHCは、与えられた式を必要に応じて少しずつ読み出すことで、`aaa`や`loop`のように再帰的に参照された式も、部分的にせよ評価してくれます。

再帰呼び出しは「命令」の中でも使えます。今度は文字を出力する`putChar`関数を使って、`oooooooooooo`と叫んでみましょう:

```haskell
ooo = do
  putChar 'o'
  ooo
```

早速定義をGHCiに読み込ませて実行してみると、期待通り`ooooooooooo`と延々出力し続けるのが分かります:

```haskell
> ooo
oooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooInterrupted.
```

※繰り返しになりますがこの例もやはり`Ctrl + C`で止めてください。無限ループの例はこれで最後のはずです！

`putChar 'o'`という命令で文字`o`を出力した後、やはり`ooo`自身をもう一度呼び出しています。そのためまた`ooo`の定義を参照して、`do`における最初の命令`putChar 'o'`を実行して... の繰り返しです。先ほどの`aaa`とそっくりですね。

このように、定義している関数自身を呼び出す、つまり関数の再帰呼び出しを行うことで、同じ処理を何度でも繰り返すことが出来ます。でも、このままのやり方では`Ctrl + C`を押さないと実行を中断出来ませんし、とても不便ですよね？今回の課題では「受け取った入力を、空白で区切った文字列のリストとして代入」してから、その内容に応じて処理を繰り返したり、繰り返しを止めたりしなければなりません。そこで次の節では、`getLine`した結果に応じて中断出来る再帰関数を書いてみましょう。

#### 条件を満たしたら切り上げる

いよいよ、条件に応じて繰り返しを止めることが出来る関数を書いてみましょう。ここまで紹介したとおり、再帰呼び出しをすると関数は繰り返し呼び出されるので、条件を満たしているかチェックしたあと、再帰呼び出しをしないことによって繰り返しを止めることができます。

例として「空文字列以外の文字列が入力される」という条件が満たされるまで、「名前を`getLine`する」という関数を紹介します:

```haskell
askUntilNonEmpty = do
    putStrLn "Enter your name:"
    string <- getLine
    case string of
        [] -> do
            putStrLn "Empty! Try again!"
            askUntilNonEmpty
        _ ->
            putStrLn ("Thanks, " ++ string ++ " san!")
```

実行した結果の例は以下の通りです:

```haskell
Enter your name:
-- <- 何も入力していない！
Empty! Try again!
Enter your name:
-- <- 何も入力していない！
Empty! Try again!
Enter your name:
Yuji -- <- 「Yuji」と入力した！
Thanks, Yuji san!
```

「--」で始まる行は、この`askUntilNonEmpty`関数のユーザーが`getLine`関数を実行した際に与えた入力に対するコメントです。Haskellのソースコードにおけるコメントに倣って「--」で始めています。

実行例を見た限り、`askUntilNonEmpty`関数は期待通り動いているようです。ユーザーが何も入力していないときは`Empty! Try again!`と出力した上でもう一度`Enter your name:`と尋ねて再度ユーザーに入力を求め、ユーザーが何か入力して初めて実行を終了しています。

では改めて、`askUntilNonEmpty`関数がどのように実装されているか確認してみましょう。

`getLine`で取得した`string`変数に対して、`case`式でパターンマッチすることで、`sting`が`[]`、すなわち空文字列かそうでないかで分岐しています。ここで「空文字列以外の文字列が入力される」という条件が満たされるかをチェックしているわけですね。そして`string`が空であれば、`askUntilNonEmpty`自身をもう一度呼び出します。そう、ここで再帰呼び出しをしているのです。「空文字列以外の文字列が入力される」までが`askUntilNonEmpty`を繰り返す条件なので、条件を満たしていない、`string`が空の場合は再帰呼び出しをしています。

一方、`string`が`[]`以外、つまり空文字列でない場合（上述の`case`式における`_ ->`で始まる箇所）は、再帰呼び出しをいていません。条件を満たしたのだから、もう繰り返す必要がないので、再帰呼び出しもしません。結果、`askUntilNonEmpty`の繰り返し実行が終了します。

以上が、「条件に応じて繰り返しを止めることが出来る関数」の例です。再帰呼び出しをした場合は関数が繰り返し呼ばれるので、条件を満たした状態では、単純に再帰呼び出しをしないことで、繰り返しを止められる、ということが伝わったでしょうか？

もう一つ、条件を満たしたら繰り返しを止める関数の例を紹介させてください。先ほどの`askUntilNonEmpty`関数は「命令」を再帰呼び出しした例でしたが、今度は「命令」を伴わず、「純粋な計算」のみを行う関数（「純粋な関数」とも言います）での再帰呼び出しです。数値のリストに対して、リストのすべての要素に2をかける関数です:

```haskell
doubles xs =
    case xs of
        [] -> []
        x : xsLeft -> x * 2 : doubles xsLeft
```

念のため動作例も確認してみます:

```haskell
ghci> doubles [1, 2, 3]
[2,4,6]
```

ちゃんとすべての要素を2倍してますね！

先ほどの`askUntilNonEmpty`と同様に、`case`式で条件分岐することで、条件を満たしたら再帰呼び出しをしないことで繰り返しを止めています。`askUntilNonEmpty`が`getLine`という命令の結果によって分岐しているのに対して、`doubles`関数では引数`xs`の値を見て分岐しています。これは、「純粋な関数」とそうでない「命令」の重要な違いによるものです。

課題5で触れたとおり、「純粋な関数」は「同じ関数や演算子に同じ値を同じ順番で渡した場合、必ず同じ値を返す」という特徴があるので、関数に渡す値すなわち引数を変えない限り、永遠に関数の実行結果も変わらないのです。従って「純粋な関数」がもう一度再帰するか判断するのにも、引数を見る以外に方法がありません。他の言語で繰り返しを行う`for`文などでは、変数を書き換えることでループを進めていたところ、「純粋な関数」の再帰呼び出しでは、**引数の値を変えることでループを進める**、と理解してください。

##### `doubles`関数が再帰を終えるまで

`doubles`関数の再帰の終了条件や、終了条件に向けてどのよう値を変化させているか分かったところで、`case`式の各条件分岐を詳細に見てみましょう。`case xs of`で始まる`case`式で、引数`xs`が空のリストであった場合とそれ以外、リストの先頭の要素`x`と残りのリスト`xsLeft`が取得できる場合とで分岐していますね。

第一に`xs`が空のリストであった場合、`[] -> []`と書かれているとおり、空のリストを返します。`doubles`関数は「リストのすべての要素に2をかける関数」ですが、空のリストが相手だと2をかける要素がないので、空のリストをそのまま返すしかありません。加えて、ここでは再帰呼び出しをしていないので、引数`xs`が空のリストになったら実行を止める、という点にも注目してください。

第二の場合、すなわち`x : xsLeft ->`で始まる行では、課題hoge(9?)で学習したリストの値コンストラクター`:`を利用して、`xs`がリストの先頭の要素`x`と残りのリスト`xsLeft`に分解できる場合を表しています。`:`の左辺がリストの先頭の要素、右辺が残りのリストをそれぞれ表していて、それぞれを指定した変数`x`と`xsLeft`に代入しているのでした。その`x`・`xsLeft`を使って作った式が`x * 2 : doubles xsLeft`です。結構複雑なので一つずつ説明しましょう。まず、`x * 2`で、`xs`の先頭の要素`x`に2をかけています。次の`:`は、これまた課題hoge(9?)で学習したリストの値コンストラクターです。先ほどは`xs`を先頭の要素と残りのリストに**分解する**ために使用していましたが、ここでは左辺に先頭の要素、右辺に残りのリストを指定することで、**新しいリストを作る**関数として使われています。左辺は前述の`x * 2`でいいとして、注目すべきは右辺の`doubles xsLeft`です。ここで`doubles`関数の再帰呼び出しが出てきました！もう一度`doubles`関数が呼び出されます！その、もう一度呼び出した結果を`:`で新しいリストとしてくっつけているのが`x * 2 : doubles xsLeft`という式です。

`doubles xsLeft`という式で`doubles`関数をもう一度呼び出すとどうなるのか考えてみましょう。`xs`を分解してできた残りのリスト`xsLeft`は、必ず`xs`より要素が一つ少ないリストとなります。`x : xsLeft ->`というパターンマッチで分解した際、先頭の要素を取り出しているからです。なので、ここで再帰呼び出しされる`doubles`関数は、元々の`doubles`関数に渡した引数`xs`より要素が一つ少ないリストを受け取ることとなります。そして`doubles xsLeft`という式で再度呼ばれた`doubles`関数は、（変数名が変わって紛らわしいですが、前の呼び出しで`xsLeft`と呼ばれていた）引数`xs`を`case`式で分解します。そして`xs`が空のリストでなければ、また先頭の要素と残りのリストに分解します。このケースで`xs`を分解して作られた`xsLeft`はやはり`xs`より要素が一つ少ないリストです。そうして`doubles`関数は、再帰呼び出しされる毎に受け取った引数`xs`より要素が一つ少ないリスト`xsLeft`を、もう一度`doubles`関数自身に渡して処理を繰り返します。結果、最終的に`xsLeft`は最も要素が少ないリスト、すなわち空のリストとして`doubles`関数に渡され、空のリストを受け取った`doubles`関数は、前述のとおり空のリストを返して、再帰呼び出しを止めます。以上が`doubles`関数がリストに対して再帰呼び出しをして止めるまでの流れです。

具体例で考えてみましょう。`doubles [100, 40]`という式を例にしてみます。

```hs
doubles [100, 40]
```

という式を👆に書いた`doubles`関数の定義に従って、👇のように書き換えてみます:

```hs
case [100, 40] of
    [] -> []
    x : xsLeft -> x * 2 : doubles xsLeft
```

これは`doubles`関数の定義における引数`xs`を実際に渡している`[100, 40]`で書き換えた式です。やはり`case`式で`[100, 40]`の中身をチェックしていますね。`[100, 40]`は空のリスト、すなわち`[]`ではないので、`x : xsLeft -> x * 2 : doubles xsLeft`のケースが実行されます。ここで、`x`には`[100, 40]`の先頭の要素`100`が、`xsLeft`には`[100, 40]`の残りのリスト`[40]`が代入されます。結果、`x * 2 : doubles xsLeft`という式は次のように書き換えられます:

```hs
100 * 2 : doubles [40]
```

`[100, 40]`の先頭の要素`100`に`2`をかけ、`:`で新しいリストの先頭の要素としてくっつけています。`:`の右辺、すなわち`100 * 2`を先頭としたリストの残りの要素はどうなるのでしょう？ ...と、ここで`doubles`関数の再帰呼び出し`doubles [40]`が出てきました！`[100, 40]`から先頭の要素`100]`を抜いた`[40]`をさらに`doubles`関数で処理するわけですね！それではこの`doubles [40]`も`doubles`関数の定義に従って書き換えてみます👇:

```hs
case [40] of
    [] -> []
    x : xsLeft -> x * 2 : doubles xsLeft
```

先ほど`doubles [100, 40]`を書き換えたときに現れた`case [100, 40] of ...`と異なり、先頭の要素`100`を取り除いた`[40]`に対する`case`式が出てきました。抜け落ちた`100`はどこに行ったのか、って？最初の`doubles`関数の呼び出し（`doubles [100, 40]`）における`case`式で、`[100, 40]`を`100`と`[40]`に分解したとき、結果となる式`100 * 2 : doubles [40]`の`100`にあります！

このようにして、`doubles`関数は最初に受け取った引数の要素を一つずつ取り出しては処理しながら再帰呼び出しすることで、確実に再帰呼び出しを終わらせることができます。`case [40] of`で始まる`case`式では、`[40]`はまだ空のリスト`[]`ではないので`[40]`は`x`に`40`を、`xsLeft`に`[]`を代入しつつ分解されます。結果、


```hs
x * 2 : doubles xsLeft
```

という式は今度は👇という式に書き換えられます。

```hs
40 * 2 : doubles []
```

`:`の右辺に注目してください。`doubles []`とあるとおり、またしても`doubles`関数を再帰呼び出ししているのですが、いよいよ引数が空のリスト`[]`になりました！`doubles []`の結果は先ほども触れたとおり、単に空のリスト`[]`を返すので、これ以上再帰呼び出しをすることもなく、`doubles`関数の呼び出しは終了します。

従って、上記👆の式は、

```hs
40 * 2 : []
```

と置き換えられます。そして遡ると👆の結果は`doubles [40]`の結果ですので、さらに遡って`doubles [100, 40]`の結果であった、

```hs
100 * 2 : doubles [40]
```

この👆式も下👇のとおり書き換えられます。

```hs
100 * 2 : 40 * 2 : []
```

あとはリストの各要素に対するかけ算`*`を計算して、`:`を見慣れたリストのリテラルに置き換えれば、`doubles [100, 40]`の答えができあがりです！:

```hs
[200,80]
```

ちゃんとすべての要素を2倍にできてますね！

こちらの例のとおり、`doubles`関数は最初に受け取った引数のリストから、一つずつ要素を取り出しては残りのリストを引数にして再帰呼び出ししています。原則として、リストは要素を一つ取り出すとその分小さくなり、やがては空のリストになるので、`doubles`関数は引数として空のリストを受け取り、再帰呼び出しを終了させます。

以上のように純粋な関数の再帰呼び出しでは、関数への引数を変えながら再帰呼び出しをすることで処理を進めます。繰り返しになりますが、他の言語における`for`文などでは変数を書き換えることでループを進めていたところ、「純粋な関数」の再帰呼び出しでは、**引数の値を変えることでループを進める**、という点を改めて抑えておいてください。

なお、以上のように関数の定義に対して具体的な値を当てはめたり、その他の定理に従って書き換えることを「等式変形」といいます。本節のように関数の性質を理解するのを補助するほか、関数の性質を定理として証明することもできます。これに関連して「定理証明支援系」で調べてみると、面白い世界が覗けるでしょう。

### 何もしない「命令」で値を返す

今回の課題を解くに当たり、おそらく必要になるであろう知識

```haskell
ghci> askUntilNonEmpty
Enter your name:

Empty! Try again!
Enter your name:
yuji
Thanks, yuji san!
ghci> -- ^^^^^ 値が返ってきてない！
```

`askUntilNonEmpty`は値を返さない！最後に実行しているのが`putStrLn`だから。  
`getLine`のように、値を返す命令にするには？

`getLine`をもう一度実行するのはおかしい。  
`getLine`がもう一度ユーザーに入力を求める上、戻り値が変わってしまう。

```haskell
askUntilNonEmpty = do
    putStrLn "Enter your name:"
    string <- getLine
    case string of
        [] -> do
            putStrLn "Empty! Try again!"
            askUntilNonEmpty
        _ -> do
            putStrLn ("Thanks, " ++ string ++ " san!")
            getLine -- <- この行を追加してもダメ！
```

返したいのは、`string <- getLine`の行で代入される`string`。  
`getLine`のように「標準入力から入力を受け取って値を返す」のではなく、`string`を**何もしないで`askUntilNonEmpty`という「命令」の結果として返す**には？

```haskell
askUntilNonEmpty = do
    putStrLn "Enter your name:"
    string <- getLine
    case string of
        [] -> do
            putStrLn "Empty! Try again!"
            askUntilNonEmpty
        _ -> do
            putStrLn ("Thanks, " ++ string ++ " san!")
            return string -- <- この行を追加しよう！
```

`return`はHaskellの特別な構文ではなく、単に**何もしないで指定した値を返すだけの「命令」**。  
「命令」の途中で実行しても、「命令」の実行が**中断されることはない**。

```haskell
askUntilNonEmpty = do
    putStrLn "Enter your name:"
    string <- getLine
    return "Useless return!" -- ここに return と書いても意味がない！無視される！
    case string of
        [] -> do
            putStrLn "Empty! Try again!"
            askUntilNonEmpty
        _ -> do
            putStrLn ("Thanks, " ++ string ++ " san!")
            return string -- <- この行を追加しよう！
```

たまたま「命令」における`do`の最後で実行されることが多いから、`return`と呼ぶことで、なんか命令型言語っぽい見た目になるから`return`と呼ぶのだと覚えてください。

なので、下記のようにも書ける。

「何もしない命令」を実行して、その結果を`x`に代入

```haskell
ghci> x <- return 1
ghci> x
1
```

実質やっていることは下記と同じ。

```haskell
ghci> x = 1
ghci> x
1
```
