# `do`における変数への代入を抑える 1

課題4のアプリケーションを、`<-`もカッコも使わずに書き換えましょう。今回も&純粋にリファクタリングをしてください。特に振る舞いを変える必要はありません。

## 必要な知識

今回は、これまで「命令」を列挙したり`<-`で「命令」から結果を変数に代入するのに用いていた「`do`記法」が各「命令」をどのように処理しているのかを知ることで、`do`記法を使わずに書き換える方法を学びます。前の課題と同様、Haskellを書くときに必ずしもこの知識を使う必要はないですが（実際、多くの場合`do`記法の方が分かりやすいですし）、あの「モナド(`Monad`)」を理解する上で必要不可欠な知識となっていますので、是非理解しておいてください。

### `do`記法の正体1: `do`をなくす`>>`

まずは、次👇のように`do`記法を使って`putStrLn`を連続して実行する関数を、`do`記法を使わずに書き換える方法を紹介します:

```haskell
loremIpsum = do
    putStrLn "Lorem ipsum dolor sit amet,"
    putStrLn "consectetur adipiscing elit,"
    putStrLn "sed do eiusmod tempor incididunt"
    putStrLn "ut labore et dolore magna aliqua."
```

結論から言いましょう。上記👆のコードから`do`をなくすと、下記👇のように書き換えられます:

```haskell
loremIpsum =
    putStrLn "Lorem ipsum dolor sit amet,"
    >> putStrLn "consectetur adipiscing elit,"
    >> putStrLn "sed do eiusmod tempor incididunt"
    >> putStrLn "ut labore et dolore magna aliqua."
```

`do`を消した上で、最初の行を除いて各行の頭に`>>`を追加しました。`>>`は、`putStrLn ".."`のような「命令」を「繋げる」演算子です。当然、`+`や`*`のような、Haskellにおける他の演算子と全く同じように扱えるようになっています。

従って`>>`も、次のように左辺も右辺も含めて1行で書くことができます:

```haskell
loremIpsum =
    putStrLn "Lorem ipsum dolor sit amet," >> putStrLn "consectetur adipiscing elit," >> putStrLn "sed do eiusmod tempor incididunt" >> putStrLn "ut labore et dolore magna aliqua."
```

一つや二つならともかく、ここまで多くの「命令」を繋げると読みづらくなってしまいますが😅。

通常、Haskellの`do`において次👇のように書いた場合、

```haskell
do
    action1
    action2
    action3
```

コンパイルの際、次👇のようなコードに内部で置き換えられます:

```haskell
action1 >> action2 >> action3
```

このような置き換えが行われることから、`do`は`>>`の「糖衣構文(syntax sugar)」である、とも言います。課題hoge(9?)で紹介した、リストを書くときの二つの記法（例えば`[a, b, c]`と`a : b : c : []`）の関係と同じです。

#### 型で知る`>>`

Haskellにおける`>>`は演算子なので、`:t`を使えばどんな型かが分かるようになっています。早速見てみましょう:

```haskell
ghci> :t (>>)
(>>) :: Monad m => m a -> m b -> m b
```

`Monad`が出てきました。そう、あの「モナド(`Monad`)」です。我々はこれまで`IO`型の「命令」の話をしていたはずなのに一体なぜここで`Monad`が出てきたのでしょうか？

どういう理由であれ、`=>`の左辺に出てくると言うことは`Monad`は型クラスのようです。GHCiの`:i`コマンドを使って調べてみましょう:

```haskell
ghci> :i Monad
class Applicative m => Monad (m :: * -> *) where
  (>>=) :: m a -> (a -> m b) -> m b
  (>>) :: m a -> m b -> m b
  return :: a -> m a
  fail :: String -> m a
  {-# MINIMAL (>>=) #-}
        -- Defined in ‘GHC.Base’
instance Monad (Either e) -- Defined in ‘Data.Either’
instance Monad [] -- Defined in ‘GHC.Base’
instance Monad Maybe -- Defined in ‘GHC.Base’
instance Monad IO -- Defined in ‘GHC.Base’
instance Monad ((->) r) -- Defined in ‘GHC.Base’
instance Monoid a => Monad ((,) a) -- Defined in ‘GHC.Base’
```

何だかたくさん出力されましたね！ここで注目して欲しいのは、最後の方に書かれている、

```haskell
instance Monad IO -- Defined in ‘GHC.Base’
```

という行です。これは、`IO`型が`Monad`型クラスのインスタンスであることを示しています。これまで何度も使ってきた`IO`型、本入門の言葉で言うところの「命令」は`Monad`の一つなのです。

そして、前述のGHCiの`:i Monad`の結果から察せられるとおり、`Monad`型クラスのインスタンスは他にもたくさんあることも、頭の片隅に置いておいて下さい。他のインスタンスについては次の次の課題hoge(21?)で触れますので、乞うご期待。

ここまでのポイントは以下の通りです:

- `Monad`は型クラス
- `>>`は、`Monad`型クラスのインスタンス全般に対して使える関数（演算子）
- 今まで使ってきた、`putStrLn`や`getLine`が返す`IO`（命令）も`Monad`のインスタンス

##### GHCの言語拡張`TypeApplications`で、分かりやすく見てみる

`>>`は`Monad`型クラスのインスタンス全般に対して使える関数で、`IO`型も`Monad`型クラスのインスタンスなので`>>`が使えることはここまででお伝えしたとおりです。とは言ったものの、`>>`のことをよりよく理解する上で、`Monad m => m a -> m b -> m b`という型は少々抽象的で分かりづらく感じられるかも知れません。そこで、`TypeApplications`というGHCの言語拡張を使うことで、`IO`専用の`>>`を作ってみましょう。`Monad`のことを意識しなくて良い分、より分かりやすくなるはずです。

###### そもそも言語拡張とは？

「GHCの言語拡張」とは何でしょうか？GHCが提供する、現行のHaskellの仕様[Haskell 2010][1]ではサポートされていない、実験的な機能です。通常、下記のような特別な形式のコメントを、`.hs`ファイルにおける一番最初の箇所に書くことで、そのファイルの中でのみ指定した言語拡張（下記の例は`TypeApplications`）を有効にして使います:

[1]: https://www.haskell.org/onlinereport/haskell2010/

```haskell
{-# LANGUAGE TypeApplications #-}
```

あるいは、GHCiで言語拡張を有効にしたい場合、↓のように書くことで`TypeApplications`を有効にできます。

```haskell
ghci> :set -XTypeApplications
```

`-XTypeApplications`とあるとおり、`-X`と`TypeApplications`の間にスペースがない点にご注意ください。スペースを書くとエラーになってしまいます:

```haskell
ghci> :set -X TypeApplications
Some flags have not been recognized: -X, TypeApplications
```

GHCiを起動している間に言語拡張を**無効**にしたくなった場合、下記のように書きます:

```haskell
ghci> :set -XNoTypeApplications
-- もちろん例は TypeApplications ですが、他の言語拡張も同様です
```

###### `TypeApplications`を使う

いよいよ、`TypeApplications`を使ってみましょう:

```haskell
ghci> :set -XTypeApplications
```

ここでは例として、`map`関数に`TypeApplications`を使ってみます:

```haskell
ghci> :t map
map :: (a -> b) -> [a] -> [b]
```

`map`関数は、上👆の`:t`コマンドの結果の通り、`a`と`b`という二つの型変数を使っています。`TypeApplications`を使えば、それぞれの型変数を手動で代入することができます。例えば、次のように`map @Bool @Integer`と書くと、型変数`a`に`Bool`、型変数`b`に`Integer`を代入した`map`関数が出来上がります:

```haskell
ghci> :t map @Bool @Integer
map @Bool @Integer :: (Bool -> Integer) -> [Bool] -> [Integer]
```

通常、この、型変数に具体的な型を代入する処理は型推論によってコンパイル時に自動で行われますが、`TypeApplications`を有効にすると、ユーザーが自ら制御できるようになるのです。

`TypeApplications`で作られた`map @Bool @Integer`は、`Bool`型のリストを受け取って、その各要素に`Bool -> Integer`関数を適用し、`Integer`型のリストを返す、専用の関数となっています。そのため、通常の`map`関数と異なり必ず`Bool -> Integer`型の関数を渡さなければなりません:

```haskell
-- 引数の型が`Bool`ではなく`Integer`なのでエラー
ghci> :t map @Bool @Integer (+1)

<interactive>:1:21: error:
    ? Couldn't match type ‘Bool’ with ‘Integer’
      Expected: Bool -> Integer
        Actual: Bool -> Bool
    ? In the third argument of ‘map’, namely ‘(+ 1)’
      In the expression: map @Bool @Integer (+ 1)

-- 戻り値の型が`Integer`ではなく`String`なのでエラー
ghci> :t map @Bool @Integer show

<interactive>:1:20: error:
    ? Couldn't match type ‘[Char]’ with ‘Integer’
      Expected: Bool -> Integer
        Actual: Bool -> String
    ? In the third argument of ‘map’, namely ‘show’
      In the expression: map @Bool @Integer show

-- これはOK。if式を利用し、Bool型の値からInteger型の値を返す関数
ghci> :t map @Bool @Integer (\x -> if x then 1 else 0)
map @Bool @Integer (\x -> if x then 1 else 0)
  :: [Bool] -> [Integer]
```

このように、`TypeApplications`を使うことで、`map`関数が受け取る型変数に手動で具体的な型を代入することができるようになります。

今回は、`Monad`のことを考えないために`(>>)`の`m`を`TypeApplications`で`IO`に置き換えてみるのに使いましょう。

```haskell
ghci> :t (>>) @IO
(>>) @IO :: IO a -> IO b -> IO b
```

2つの引数と戻り値:

- 第1引数（左辺）の`IO a`: `getLine`や`putStrLn "hello"`などの命令。
- 第2引数（右辺）の`IO b`: 同じく`getLine`や`putStrLn "hello"`などの命令。
- 戻り値の`IO b`: 第2引数（右辺）の命令と、同じ型の値を返す命令。

「右辺の命令の結果をそのまま返す命令」を返すことが読み取れる。  
例えば

```
ask =
    putStrLn "Hello, how are you?"
    >> getLine
```

と書くと、`putStrLn "Hello, how are you?"`と`getLine`を続けて実行して、`getLine`の実行結果を返す命令が作られる。

```
ghci> ask
Hello, how are you?
Fine! -- ここはユーザーによる入力
"Fine!"
```

`do`を使ってやってもやっぱり同じ。

```
ghci> :{
ghci| ask = do
ghci|     putStrLn "Hello, how are you?"
ghci|     getLine
ghci| :}
ghci> ask
Hello, how are you?
Alright. -- ここはユーザーによる入力
"Alright."
```

まとめると、`>>`は、「両辺の命令を続けて実行して、右辺の命令の結果を返す命令」を作る演算子。  
ほかのプログラミング言語でよく出てくるセミコロン `;`とよく似てる。

### `do`記法の正体2: `<-`をなくす `>>=`

今度は`do`の中で単に命令を列挙する処理だけでなく、`do`の中で`<-`を使って変数に代入をする処理を、`do`を使わないで書き換えてみましょう。

```
echo = do
  line <- getLine
  putStrLn line
```

↓のように置き換えられる！

```
echo = getLine >>= putStrLn
```

1行だけ。またしても`do`がない！  
`>>=`とは何者？

```
ghci> :t (>>=)
(>>=) :: Monad m => m a -> (a -> m b) -> m b
```

また`Monad`が出てきたので、`TypeApplications`で`IO`に置き換えてみる。

```
ghci> :t (>>=) @IO
(>>=) @IO :: IO a -> (a -> IO b) -> IO b
```

`>>`と違って第二引数が関数`a -> IO b`になっているのがポイント。

2つの引数と戻り値:

- `IO a`: 第二引数の関数`a -> IO b`の、**引数**と同じ型`a`の値を返す`IO`（命令）。
- `a -> IO b`: 何か（`IO`でない、普通の）値`a`を受け取って、命令`IO b`を返す。
- `IO b`: 第二引数の関数`a -> IO b`の、**結果**と同じ型`b`の値を返す`IO`（命令）。

「左辺の命令の実行結果を受け取って、右辺の『命令を返す関数』につなげて、続けて実行する命令」を返す演算子

```
echo = getLine >>= putStrLn
```

両辺の型を調べてみると

```
ghci> :t getLine
getLine :: IO String
```

左辺に当たる`getLine`が結果として`String`を返して、

```
ghci> :t putStrLn
putStrLn :: String -> IO ()
```

右辺に当たる`putStrLn`の引数として渡す。

最終的に`putStrLn`が返すのは`IO ()`なので、`echo`の型は`IO ()`となる。

```
ghci> echo = getLine >>= putStrLn
ghci> :t echo
echo :: IO ()
```

でもこれ↓はダメ

```
ghci> getLine >>= length

<interactive>:4:13: error:
    ? Couldn't match type ‘Int’ with ‘IO b’
      Expected type: String -> IO b
        Actual type: [Char] -> Int
    ? In the second argument of ‘(>>=)’, namely ‘length’
      In the expression: getLine >>= length
      In an equation for ‘it’: it = getLine >>= length
    ? Relevant bindings include it :: IO b (bound at <interactive>:4:1)
```

あくまでも、`>>=`の右辺に渡されるのは`IO`（命令）を返す関数

`length`のような純粋な関数を`>>=`に渡すには、`return`などで、`IO`に変換しないといけない。

```
ghci> getLine >>= return . length
12345 -- ここは自分で入力した行。
5
```

ラムダ抽象で置き換えるとこう↓

```
getLine >>= (\line -> return (length line))
```

`do`で書き換えるとこう↓

```
do
    line <- getLine
    return (length line)
```

このとおり、実際に`do`記法の中で`<-`を使った場合、例えば上記の「`line <- getLine`」で始まる2行は、その前の`getLine >>= (\line -> return (length line))`という式に置き換えられる（`do`における`<-`は`>>=`の糖衣構文）。

`return`ではなく、`print`で`IO`に変えても型チェックは通る！

```
getLine >>= print . length
```

普通の純粋な関数を使っている場面でもっと気軽に、`return`を使わずに`do`を消す方法は次の課題で！

### 番外編: 他によく使われる`do`を消すために使う関数

```
ghci> :t (=<<)
(=<<) :: Monad m => (a -> m b) -> m a -> m b

ghci> :t (=<<) @IO
(=<<) @IO :: (a -> IO b) -> IO a -> IO b
```

`>>=`の引数の順番を逆にしただけ！  
「右辺の`IO a`の実行結果を左辺の関数`a -> IO b`に渡して`IO b`として返す」命令を返す。

個人的にはこちらをよく使う。

↓のように、普通の関数呼び出しと同じ順番で書けるから！

```
putStrLn =<< getLine
```

### 番外編: 各種演算子の読み方（発音）

今回説明した演算子`>>`と`>>=`は、次のように読みます。

- `>>`: then
- `>>=`: bind

ほかの演算子については<https://wiki.haskell.org/Pronunciation>をご覧ください。  
