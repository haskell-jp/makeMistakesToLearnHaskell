# `do`における変数への代入を抑える 1

課題4のアプリケーションを、`<-`とカッコを使わずに書き換えましょう。

## 必要な知識

### `do`記法の正体1: `do`をなくす `>>`

```
loremIpsum = do
    putStrLn "Lorem ipsum dolor sit amet,"
    putStrLn "consectetur adipiscing elit,"
    putStrLn "sed do eiusmod tempor incididunt
    putStrLn "ut labore et dolore magna aliqua."
```

から`do`をなくすと...

```
loremIpsum =
    putStrLn "Lorem ipsum dolor sit amet,"
        >> putStrLn "consectetur adipiscing elit,"
        >> putStrLn "sed do eiusmod tempor incididunt
        >> putStrLn "ut labore et dolore magna aliqua."
```

1行で書くと...

```
loremIpsum =
    putStrLn "Lorem ipsum dolor sit amet," >> putStrLn "consectetur adipiscing elit," >> putStrLn "sed do eiusmod tempor incididunt >> putStrLn "ut labore et dolore magna aliqua."
```

読みづらい！

要するにほかのプログラミング言語における`;`（文の区切り記号）と似てる！

```
ghci> putStrLn "Hello," >> putStrLn "World!"
Hello,
World!
```

通常、Haskellの`do`において

```
do
    action1
    action2
    action3
```

と書いた場合、

```
action1 >> action2 >> action3
```

というコードにコンパイル時に内部で置き換えられる。  
`do`は`>>`の「糖衣構文」である、とも言う。

#### 型で知る `>>`

Haskellにおける`>>`は演算子なので、`:t`を使えばどんな型かがわかる！見てみよう。

```
ghci> :t (>>)
(>>) :: Monad m => m a -> m b -> m b
```

`Monad`が出てきた...

`=>`の左辺に出てくると言うことは型クラスらしいので`:i`で見てみる。

```
ghci> :i Monad
class Applicative m => Monad (m :: * -> *) where
  (>>=) :: m a -> (a -> m b) -> m b
  (>>) :: m a -> m b -> m b
  return :: a -> m a
  fail :: String -> m a
  {-# MINIMAL (>>=) #-}
        -- Defined in ‘GHC.Base’
instance Monad (Either e) -- Defined in ‘Data.Either’
instance Monad [] -- Defined in ‘GHC.Base’
instance Monad Maybe -- Defined in ‘GHC.Base’
instance Monad IO -- Defined in ‘GHC.Base’
instance Monad ((->) r) -- Defined in ‘GHC.Base’
instance Monoid a => Monad ((,) a) -- Defined in ‘GHC.Base’
```

なんかたくさんある！

特に注目して欲しいのは、

```
instance Monad IO -- Defined in ‘GHC.Base’
```

と書かれていること。

ここでのポイントは以下の通り

- `Monad`は型クラス。
- `>>`は、`Monad`型クラスのインスタンス全般に対して使える多相関数（演算子）
- 今まで使ってきた、`putStrLn`や`getLine`が返す`IO`も`Monad`のインスタンス。

##### GHCの言語拡張`TypeApplications`で、分かりやすく見てみる

`Monad`のことを一旦忘れるために、便利なGHCの言語拡張を有効にする。

###### そもそも言語拡張とは？

現行のHaskellの仕様[Haskell 2010](https://www.haskell.org/onlinereport/haskell2010/)に書かれている仕様でサポートされていない、実験的な機能。  
通常、下記のような特別な形式のコメントを`.hs`ファイルの先頭に書くことで、そのファイルの中のみで指定した言語拡張を有効にすることができる。

```
{-# LANGUAGE <言語拡張の名前> #-}
```

今回有効にする`TypeApplications`の場合は以下の通り。

```
{-# LANGUAGE TypeApplications #-}
```

あるいは、GHCiで言語拡張を有効にしたい場合、↓のように書くと、`TypeApplications`を有効にすることができる。

```
ghci> :set -XTypeApplications
```

`-XTypeApplications`とあるとおり、`-X`と`TypeApplications`の間にスペースがない点に注意。

スペースを書くとエラーになる。

```
ghci> :set -X TypeApplications
Some flags have not been recognized: -X, TypeApplications
```

GHCiを起動している間に言語拡張を無効にしたくなったら、下記のように書く。

```
ghci> :set -XNoTypeApplications
```

###### `TypeApplications`を使う

```
ghci> :set -XTypeApplications
ghci> :t map
map :: (a -> b) -> [a] -> [b]
ghci> map length ["aaa", "bb", "cccc"]
[3,2,4]
```

`map @Bool`と書くことで、`Bool`専用の`map`ができる。  
`map :: (a -> b) -> [a] -> [b]`の最初の型引数`a`に`Bool`を代入するのと同じ。  
通常、この、型変数に具体的な型を代入する処理は型推論によって自動で行われるが、`TypeApplications`を有効にすることで、ユーザー自ら制御できるようになる。

```
ghci> :t map @Bool
map @Bool :: (Bool -> b) -> [Bool] -> [b]
ghci> map @Bool length ["aaa", "bb", "cccc"]

<interactive>:8:11: error:
    ? Couldn't match type ‘Bool’ with ‘[a0]’
      Expected type: Bool -> Int
        Actual type: [a0] -> Int
    ? In the second argument of ‘map’, namely ‘length’
      In the expression: map @Bool length ["aaa", "bb", "cccc"]
      In an equation for ‘it’:
          it = map @Bool length ["aaa", "bb", "cccc"]

<interactive>:8:19: error:
    ? Couldn't match expected type ‘Bool’ with actual type ‘[Char]’
    ? In the expression: "aaa"
      In the third argument of ‘map’, namely ‘["aaa", "bb", "cccc"]’
      In the expression: map @Bool length ["aaa", "bb", "cccc"]

<interactive>:8:26: error:
    ? Couldn't match expected type ‘Bool’ with actual type ‘[Char]’
    ? In the expression: "bb"
      In the third argument of ‘map’, namely ‘["aaa", "bb", "cccc"]’
      In the expression: map @Bool length ["aaa", "bb", "cccc"]

<interactive>:8:32: error:
    ? Couldn't match expected type ‘Bool’ with actual type ‘[Char]’
    ? In the expression: "cccc"
      In the third argument of ‘map’, namely ‘["aaa", "bb", "cccc"]’
      In the expression: map @Bool length ["aaa", "bb", "cccc"]
```

今回は、`Monad`のことを考えないために、`(>>)`の`m`を`TypeApplications`で`IO`に置き換えて見てみるのに使いましょう。

```
ghci> :t (>>) @IO
(>>) @IO :: IO a -> IO b -> IO b
```

2つの引数と戻り値:

- 第1引数（左辺）の`IO a`: `getLine`や`putStrLn "hello"`などの命令。
- 第2引数（右辺）の`IO b`: 同じく`getLine`や`putStrLn "hello"`などの命令。
- 戻り値の`IO b`: 第2引数（右辺）の命令と、同じ型の値を返す命令。

右辺の命令の結果をそのまま返すことが読み取れる。  
例えば

```
ghci> ask = putStrLn "Hello, how are you?" >> getLine
```

と書くと、`putStrLn "Hello, how are you?"`と`getLine`を続けて実行して、`getLine`の実行結果を返す命令が作られる。

```
ghci> ask
Hello, how are you?
Fine! -- ここはユーザーによる入力
"Fine!"
```

`do`を使ってやってもやっぱり同じ。

```
ghci> :{
ghci| ask = do
ghci|     putStrLn "Hello, how are you?"
ghci|     getLine
ghci| :}
ghci> ask
Hello, how are you?
Alright. -- ここはユーザーによる入力
"Alright."
```

### `do`記法の正体1: `<-`をなくす `>>=`

今度は`do`の中で単に命令を列挙するだけでなく、`do`の中で`<-`を使って変数に代入をする処理を書き換える

```
echo = do
  line <- getLine
  putStrLn line
```

↓のように置き換えられる！

```
echo = putStrLn >>= getLine
```

1行だけ。またしても`do`がない！  
`>>=`とは何者？

```
ghci> :t (>>=)
(>>=) :: Monad m => m a -> (a -> m b) -> m b
```

また`Monad`が出てきたので、`TypeApplications`で`IO`に置き換えてみる。

```
ghci> :t (>>=) @IO
(>>=) @IO :: IO a -> (a -> IO b) -> IO b
```

2つの引数と戻り値:

- `IO a`: 第二引数の関数`a -> IO b`の、**引数**と同じ型の値を返す`IO`（命令）。
- `a -> IO b`: 何か（`IO`でない、普通の）値`a`を受け取って、命令`IO b`を返す。
- `IO b`: 第二引数の関数`a -> IO b`の、**結果**と同じ型の値を返す`IO`（命令）。

「命令の実行結果を受け取って、別の命令を受け取る関数につなげる命令を返す」演算子


でもこれ↓はダメ

```
ghci> getLine >>= length

<interactive>:4:13: error:
    ? Couldn't match type ‘Int’ with ‘IO b’
      Expected type: String -> IO b
        Actual type: [Char] -> Int
    ? In the second argument of ‘(>>=)’, namely ‘length’
      In the expression: getLine >>= length
      In an equation for ‘it’: it = getLine >>= length
    ? Relevant bindings include it :: IO b (bound at <interactive>:4:1)
```

あくまでも、`>>=`の右辺に渡されるのは`IO`（命令）を返す関数。

`length`のような純粋な関数を`>>=`に渡すには、`return`などで、`IO`に変換しないといけない。

```
ghci> getLine >>= return . length
12345 -- ここは自分で入力した行。
5
```

ラムダ式で置き換えるとこう↓

```
getLine >>= (\line -> return (length line))
```

`do`で書き換えるとこう↓

```
do
    line <- getLine
    return (length line)
```

実際に`do`記法の中で`<-`を使った場合、例えば上記の「`line <- getLine`」で始まる2行は、その前の`getLine >>= (\line -> return (length line))`という式に置き換えられる。

`return`ではなく、`putStrLn`で`IO`に変えても型チェックは通る！

```
getLine >>= putStrLn . length
```

普通の純粋な関数を使っている場面でもっと気軽に`do`を消す方法は次の課題で！

### 番外編: 他によく使われる`do`を消すために関数

個人的にはこちらをよく使う。


```
ghci> :t (=<<)
(=<<) :: Monad m => (a -> m b) -> m a -> m b
ghci> :t (=<<) @IO
(=<<) @IO :: (a -> IO b) -> IO a -> IO b
```

`>>=`の引数の順番を逆にしただけ！  
右辺の`IO a`の実行結果を左辺の関数`a -> IO b`に渡して`IO b`として返す。

↓のように、普通の関数呼び出しと同じ順番で書けるから！

```
putStrLn =<< getLine
```
