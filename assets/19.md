# `do`における変数への代入を抑える 1

課題4のアプリケーションを、`<-`とカッコを使わずに書き換えましょう。

## 必要な知識

### `do`記法の正体1: `do`をなくす`>>`

```
loremIpsum = do
    putStrLn "Lorem ipsum dolor sit amet,"
    putStrLn "consectetur adipiscing elit,"
    putStrLn "sed do eiusmod tempor incididunt"
    putStrLn "ut labore et dolore magna aliqua."
```

から`do`をなくすと...

```
loremIpsum =
    putStrLn "Lorem ipsum dolor sit amet,"
    >> putStrLn "consectetur adipiscing elit,"
    >> putStrLn "sed do eiusmod tempor incididunt"
    >> putStrLn "ut labore et dolore magna aliqua."
```

1行で書くと...

```
loremIpsum =
    putStrLn "Lorem ipsum dolor sit amet," >> putStrLn "consectetur adipiscing elit," >> putStrLn "sed do eiusmod tempor incididunt" >> putStrLn "ut labore et dolore magna aliqua."
```

読みづらい！

要するにほかのプログラミング言語における`;`（文の区切り記号）と似てる！

```
ghci> putStrLn "Hello," >> putStrLn "World!"
Hello,
World!
```

通常、Haskellの`do`において

```
do
    action1
    action2
    action3
```

と書いた場合、

```
action1 >> action2 >> action3
```

というコードにコンパイル時に内部で置き換えられる。  
`do`は`>>`の「糖衣構文(syntax sugar)」である、とも言う。

#### 型で知る`>>`

Haskellにおける`>>`は演算子なので、`:t`を使えばどんな型かがわかる！見てみよう。

```
ghci> :t (>>)
(>>) :: Monad m => m a -> m b -> m b
```

`Monad`が出てきた...

`=>`の左辺に出てくると言うことは型クラスらしいので`:i`で見てみる。

```
ghci> :i Monad
class Applicative m => Monad (m :: * -> *) where
  (>>=) :: m a -> (a -> m b) -> m b
  (>>) :: m a -> m b -> m b
  return :: a -> m a
  fail :: String -> m a
  {-# MINIMAL (>>=) #-}
        -- Defined in ‘GHC.Base’
instance Monad (Either e) -- Defined in ‘Data.Either’
instance Monad [] -- Defined in ‘GHC.Base’
instance Monad Maybe -- Defined in ‘GHC.Base’
instance Monad IO -- Defined in ‘GHC.Base’
instance Monad ((->) r) -- Defined in ‘GHC.Base’
instance Monoid a => Monad ((,) a) -- Defined in ‘GHC.Base’
```

なんかたくさんある！

特に注目して欲しいのは、

```
instance Monad IO -- Defined in ‘GHC.Base’
```

と書かれていること。  
つまり、これまで何度も使ってきた`IO`は`Monad`型クラスのインスタンス（そして、ほかにも`Monad`のインスタンスはたくさんある）

ここまでのポイントは以下の通り

- `Monad`は型クラス。
- `>>`は、`Monad`型クラスのインスタンス全般に対して使える多相関数（演算子）
- 今まで使ってきた、`putStrLn`や`getLine`が返す`IO`も`Monad`のインスタンス。

##### GHCの言語拡張`TypeApplications`で、分かりやすく見てみる

`Monad`のことを一旦忘れるために、便利なGHCの言語拡張を有効にする。

###### そもそも言語拡張とは？

現行のHaskellの仕様[Haskell 2010][1]に書かれている仕様でサポートされていない、実験的な機能。  
通常、下記のような特別な形式のコメントを`.hs`ファイルの先頭に書くことで、そのファイルの中のみで指定した言語拡張（下記の例は`TypeApplications`）を有効にすることができます。

[1]: https://www.haskell.org/onlinereport/haskell2010/

```
{-# LANGUAGE TypeApplications #-}
```

あるいは、GHCiで言語拡張を有効にしたい場合、↓のように書くと、`TypeApplications`を有効にすることができる。

```
ghci> :set -XTypeApplications
```

`-XTypeApplications`とあるとおり、`-X`と`TypeApplications`の間にスペースがない点に注意  
スペースを書くとエラーになる。

```
ghci> :set -X TypeApplications
Some flags have not been recognized: -X, TypeApplications
```

GHCiを起動している間に言語拡張を無効にしたくなったら、下記のように書く。

```
ghci> :set -XNoTypeApplications
```

###### `TypeApplications`を使う

```
ghci> :set -XTypeApplications
ghci> :t map
map :: (a -> b) -> [a] -> [b]
ghci> map length ["aaa", "bb", "cccc"]
[3,2,4]
```

`map @Bool`と書くことで、`Bool`のリスト専用の`map`ができる  
`map :: (a -> b) -> [a] -> [b]`の最初の型引数`a`に`Bool`を代入するのと同じ意味になる  
通常、この、型変数に具体的な型を代入する処理は型推論によってコンパイル時に自動で行われますが、`TypeApplications`を有効にすることで、ユーザー自ら制御できるようになります。

```
ghci> :t map @Bool
map @Bool :: (Bool -> b) -> [Bool] -> [b]
ghci> map @Bool length ["aaa", "bb", "cccc"]

<interactive>:8:11: error:
    ? Couldn't match type ‘Bool’ with ‘[a0]’
      Expected type: Bool -> Int
        Actual type: [a0] -> Int
    ? In the second argument of ‘map’, namely ‘length’
      In the expression: map @Bool length ["aaa", "bb", "cccc"]
      In an equation for ‘it’:
          it = map @Bool length ["aaa", "bb", "cccc"]

<interactive>:8:19: error:
    ? Couldn't match expected type ‘Bool’ with actual type ‘[Char]’
    ? In the expression: "aaa"
      In the third argument of ‘map’, namely ‘["aaa", "bb", "cccc"]’
      In the expression: map @Bool length ["aaa", "bb", "cccc"]

<interactive>:8:26: error:
    ? Couldn't match expected type ‘Bool’ with actual type ‘[Char]’
    ? In the expression: "bb"
      In the third argument of ‘map’, namely ‘["aaa", "bb", "cccc"]’
      In the expression: map @Bool length ["aaa", "bb", "cccc"]

<interactive>:8:32: error:
    ? Couldn't match expected type ‘Bool’ with actual type ‘[Char]’
    ? In the expression: "cccc"
      In the third argument of ‘map’, namely ‘["aaa", "bb", "cccc"]’
      In the expression: map @Bool length ["aaa", "bb", "cccc"]
```

今回は、`Monad`のことを考えないために、`(>>)`の`m`を`TypeApplications`で`IO`に置き換えて見てみるのに使いましょう。

```
ghci> :t (>>) @IO
(>>) @IO :: IO a -> IO b -> IO b
```

2つの引数と戻り値:

- 第1引数（左辺）の`IO a`: `getLine`や`putStrLn "hello"`などの命令。
- 第2引数（右辺）の`IO b`: 同じく`getLine`や`putStrLn "hello"`などの命令。
- 戻り値の`IO b`: 第2引数（右辺）の命令と、同じ型の値を返す命令。

「右辺の命令の結果をそのまま返す命令」を返すことが読み取れる。  
例えば

```
ask =
    putStrLn "Hello, how are you?"
    >> getLine
```

と書くと、`putStrLn "Hello, how are you?"`と`getLine`を続けて実行して、`getLine`の実行結果を返す命令が作られる。

```
ghci> ask
Hello, how are you?
Fine! -- ここはユーザーによる入力
"Fine!"
```

`do`を使ってやってもやっぱり同じ。

```
ghci> :{
ghci| ask = do
ghci|     putStrLn "Hello, how are you?"
ghci|     getLine
ghci| :}
ghci> ask
Hello, how are you?
Alright. -- ここはユーザーによる入力
"Alright."
```

まとめると、`>>`は、「両辺の命令を続けて実行して、右辺の命令の結果を返す命令」を作る演算子。  
ほかのプログラミング言語でよく出てくるセミコロン `;`とよく似てる。

### `do`記法の正体2: `<-`をなくす `>>=`

今度は`do`の中で単に命令を列挙する処理だけでなく、`do`の中で`<-`を使って変数に代入をする処理を、`do`を使わないで書き換えてみましょう。

```
echo = do
  line <- getLine
  putStrLn line
```

↓のように置き換えられる！

```
echo = getLine >>= putStrLn
```

1行だけ。またしても`do`がない！  
`>>=`とは何者？

```
ghci> :t (>>=)
(>>=) :: Monad m => m a -> (a -> m b) -> m b
```

また`Monad`が出てきたので、`TypeApplications`で`IO`に置き換えてみる。

```
ghci> :t (>>=) @IO
(>>=) @IO :: IO a -> (a -> IO b) -> IO b
```

`>>`と違って第二引数が関数`a -> IO b`になっているのがポイント。

2つの引数と戻り値:

- `IO a`: 第二引数の関数`a -> IO b`の、**引数**と同じ型`a`の値を返す`IO`（命令）。
- `a -> IO b`: 何か（`IO`でない、普通の）値`a`を受け取って、命令`IO b`を返す。
- `IO b`: 第二引数の関数`a -> IO b`の、**結果**と同じ型`b`の値を返す`IO`（命令）。

「左辺の命令の実行結果を受け取って、右辺の『命令を返す関数』につなげて、続けて実行する命令」を返す演算子

```
echo = getLine >>= putStrLn
```

両辺の型を調べてみると

```
ghci> :t getLine
getLine :: IO String
```

左辺に当たる`getLine`が結果として`String`を返して、

```
ghci> :t putStrLn
putStrLn :: String -> IO ()
```

右辺に当たる`putStrLn`の引数として渡す。

最終的に`putStrLn`が返すのは`IO ()`なので、`echo`の型は`IO ()`となる。

```
ghci> echo = getLine >>= putStrLn
ghci> :t echo
echo :: IO ()
```

でもこれ↓はダメ

```
ghci> getLine >>= length

<interactive>:4:13: error:
    ? Couldn't match type ‘Int’ with ‘IO b’
      Expected type: String -> IO b
        Actual type: [Char] -> Int
    ? In the second argument of ‘(>>=)’, namely ‘length’
      In the expression: getLine >>= length
      In an equation for ‘it’: it = getLine >>= length
    ? Relevant bindings include it :: IO b (bound at <interactive>:4:1)
```

あくまでも、`>>=`の右辺に渡されるのは`IO`（命令）を返す関数

`length`のような純粋な関数を`>>=`に渡すには、`return`などで、`IO`に変換しないといけない。

```
ghci> getLine >>= return . length
12345 -- ここは自分で入力した行。
5
```

ラムダ式で置き換えるとこう↓

```
getLine >>= (\line -> return (length line))
```

`do`で書き換えるとこう↓

```
do
    line <- getLine
    return (length line)
```

このとおり、実際に`do`記法の中で`<-`を使った場合、例えば上記の「`line <- getLine`」で始まる2行は、その前の`getLine >>= (\line -> return (length line))`という式に置き換えられる。

`return`ではなく、`print`で`IO`に変えても型チェックは通る！

```
getLine >>= print . length
```

普通の純粋な関数を使っている場面でもっと気軽に、`return`を使わずに`do`を消す方法は次の課題で！

### 番外編: 他によく使われる`do`を消すために使う関数

```
ghci> :t (=<<)
(=<<) :: Monad m => (a -> m b) -> m a -> m b

ghci> :t (=<<) @IO
(=<<) @IO :: (a -> IO b) -> IO a -> IO b
```

`>>=`の引数の順番を逆にしただけ！  
「右辺の`IO a`の実行結果を左辺の関数`a -> IO b`に渡して`IO b`として返す」命令を返す。

個人的にはこちらをよく使う。

↓のように、普通の関数呼び出しと同じ順番で書けるから！

```
putStrLn =<< getLine
```

### 番外編: 各種演算子の読み方（発音）

今回説明した演算子`>>`と`>>=`は、次のように読みます。

- `>>`: then
- `>>=`: bind

ほかの演算子については<https://wiki.haskell.org/Pronunciation>をご覧ください。  
