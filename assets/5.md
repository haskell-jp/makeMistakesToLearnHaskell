# 入力を数値に変換する

複利計算をして、将来儲かるお金を計算しましょう💰:

1. 標準入力から3行の入力を受け取ります。
1. 1行目は元金の額として解釈します。
1. 2行目は1年間あたりの金利（**単位はパーセント**）として解釈します。
1. 3行目は預けた年数として解釈します。
1. 以上の入力を元に、預けた年数後の預入額を計算してください。

## 注意事項

- 小数点以下の値に対して、四捨五入などの丸め処理をする必要はありません。
- 浮動小数点数の丸め誤差を気にする必要もありません。

## 実行結果例

「元金100円、金利1%で2年間預けた場合」を計算した結果です。

```bash
shell> stack exec runhaskell 5.hs
100 # ここはユーザーが入力する箇所
1   # ここもユーザーが入力する箇所
2   # ここまでユーザーが入力する箇所
102.01
```

## 必要な知識

### `getLine`で標準入力から1行ずつ読み出す

前回の課題では、`getContents`という命令を使って、標準入力からすべての文字列を読み出す方法を習いました。  
今回の課題では、「標準入力から3行の入力を」受け取り、なおかつ各行で受け取った文字列を別々に扱う必要があります。  
標準入力から1行ずつ読まなければならないでしょう。  
そのために使う関数は`getLine`といいます。

早速GHCiで試してみましょう。

```haskell
ghci> getLine
```

`getLine`と入力してEnterキーやReturnキーを押した時点では、プロンプトが表示されず、GHCiが止まったように見えますよね。  
これは`getLine`関数が標準入力から入力を待ち受けている証拠です。  
そのまま適当な文字列を入力してEnterまたはReturnを押せば、入力した結果がGHCiによって出力されるはずです。

```haskell
ghci> getLine
This is a line I entered!
--                       ^ ここでEnterまたはReturn
"This is a line I entered!"
-- ^ これはGHCiが`getLine`を実行した結果を出力したもの
ghci>
```

EnterやReturnを押した直後に出てきた文字列、ここでは`"This is a line I entered!"`に注目してください。  
これは`getLine`を実行した結果の文字列を、Haskellにおける文字列リテラルの形式で出力したものです。  
Rubyで言うところの`inspect`、Pythonで言うところの`repr()`を実行した結果だと言えば通じるでしょうか？  
非印刷文字や改行文字など、普通に`putStrLn`や`putStr`で表示しようとするとわかりづらい文字も見やすくしてくれます。

### 入力を数値に変換する

続いて、`getLine`で受け取った文字列を数値に変換することで、足し算やかけ算などの計算に使えるようにしましょう。  
そのためには、`read`という関数を使います。

ただし、この`read`関数、GHCiで扱う際は非常にやっかいな性質を持っています。  
そのまま試そうとしても、下記のようにエラーになってしまうでしょう。

```haskell
ghci> read "2.0"
*** Exception: Prelude.read: no parse
```

詳細は後の課題で説明しますが、これはHaskellの「型推論」という機能と、そのデフォルト設定が組み合わさってしまったことによるエラーです。  
簡単に言うと、`read`関数は本来「文字列を数値に変換する」だけでなく、文字列を様々な種類の値に変換できる、魔法のような関数です。  
しかし、上記の式`read "2.0"`ではHaskellは「どんな値に変換するのか」を推測することができず、代わりに（デフォルトの）意図しない値に変換しようと試みてしまうのです。  
そして、残念ながら`"2.0"`という値は「意図しない値」に変換できない文字列なので、`read`関数は解釈できず、エラーとなります。

この問題は、もう少し大きなHaskellのプログラムを書く場合、問題にならないことが多いです。  
少なくとも今回の課題を解くだけであれば、気にしなくて良いはずです。  
なぜなら、Haskellは`read`関数が返した値がどのように使用されているかを見て、どんな値に変換しようとしているか、自動で判断することができるからです。  
例えば今回の`read "2.0"`のようにごく短い式であっても、次のように`+ 0.0` と着けるだけでエラーを回避できます。

```haskell
ghci> read "2.0" + 0.0
2.0
```

これは、`read "2.0"`の結果に対して`+ 0.0`という計算をしようとしていることから、Haskellが「あっ、この`read "2.0"`の結果は数値として解釈すればいいんだ！」と判断しているためです。

### 複利計算の公式

それでは肝心の、「預けた年数後の預入額」を計算する際の式をHaskellで書いてみましょう。  
日本語で言うと、次のような式で計算されます。

```
預けた年数後の預入額 = 元金 × (1 + 年利)の「年数」乗
```

おっと、「『年数』乗」ということは、累乗の計算が必要ですね。  
ほかのプログラミング言語で累乗を計算する際は`**`や`^`という演算子、はたまた`pow`関数などを使用しますが、Haskellでは果たして何を使うのでしょうか！？

... 答えはキャレット `^` です！

```haskell
ghci> 2 ^ 10
1024
```

そして、ここで言う「年利」は問題の仕様上、パーセントとして入力されるため、100で割る必要があります。  
つまり次のような式になりますね。

```
預けた年数後の預入額 = 元金 × (1 + 年利(%) ÷ 100) ^ 年数
```

第2章で習ったとおり、足し算・かけ算・割り算にはそれぞれ `+`, `*`, `/` を使います。  
元金・年利(%)・預けた年数をそれぞれ`principal`・`interestRate`・`years`という変数に割り当てれば、最終的に下記のようなHaskellの式になるでしょう:

```haskell
principal * (1 + interestRate / 100) ^ years
```

## 課題の解き方

今回も課題4と同様、`do`記法の中で`<-`を使って`getLine`関数の実行結果を代入するのがポイントです。  
`getLine`で読んだ各行を変数に代入した後は、`read`関数で数値に変換しつつ、上記の複利計算の式に当てはめましょう。  
「Haskellでは関数呼び出しが最も優先して結合される」というルールを思い出しつつ、カッコで囲う場所にはくれぐれも気をつけてください。
