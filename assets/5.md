# 型注釈をつける・入力を数値に変換する

複利計算をして、将来儲かるお金を計算しましょう💰:

1. 標準入力から3行の入力を受け取ります。
1. 1行目は元金の額として解釈します。
1. 2行目は1年間あたりの金利（**単位はパーセント**）として解釈します。
1. 3行目は預けた年数として解釈します。
1. 以上の入力を元に、預けた年数後の預入額を計算してください。

## 注意事項

- 小数点以下の値に対して、四捨五入などの丸め処理をする必要はありません。
- 浮動小数点数の丸め誤差を気にする必要もありません。

## 実行結果例

「元金100円、金利1%で2年間預けた場合」を計算した結果です。

```bash
shell> stack exec runhaskell 5.hs
100 # ここはユーザーが入力する箇所
1   # ここもユーザーが入力する箇所
2   # ここまでユーザーが入力する箇所
102.01
```

## 必要な知識

### `getLine`で標準入力から1行ずつ読み出す

前回の課題では、`getContents`という命令を使って、標準入力からすべての文字列を読み出す方法を習いました。  
今回の課題では、「標準入力から3行の入力を」受け取り、なおかつ各行で受け取った文字列を別々に扱う必要があります。  
標準入力から1行ずつ読まなければならないでしょう。  
そのために使う関数は`getLine`といいます。

早速GHCiで試してみましょう。

```haskell
ghci> getLine
```

`getLine`と入力してEnterキーやReturnキーを押した時点では、プロンプトが表示されず、GHCiが止まったように見えますよね。  
これは`getLine`関数が標準入力から入力を待ち受けている証拠です。  
そのまま適当な文字列を入力してEnterまたはReturnを押せば、入力した結果がGHCiによって出力されるはずです。

```haskell
ghci> getLine
This is a line I entered!
--                       ^ ここでEnterまたはReturn
"This is a line I entered!"
-- ^ これはGHCiが`getLine`を実行した結果を出力したもの
ghci>
```

EnterやReturnを押した直後に出てきた文字列、ここでは`"This is a line I entered!"`に注目してください。  
これは`getLine`を実行した結果の文字列を、Haskellにおける文字列リテラルの形式で出力したものです。  
Rubyで言うところの`inspect`、Pythonで言うところの`repr()`を実行した結果だと言えば通じるでしょうか？  
非印刷文字や改行文字など、普通に`putStrLn`や`putStr`で表示しようとするとわかりづらい文字も見やすくしてくれます。

### 入力を数値に変換する

続いて、`getLine`で受け取った文字列を数値に変換することで、足し算やかけ算などの計算に使えるようにしましょう。  
そのためには、`read`という関数を使います。

ただし、この`read`関数、GHCiで扱う際は非常にやっかいな性質を持っています。  
そのまま試そうとしても、下記のようにエラーになってしまいます。

```haskell
ghci> read "2.0"
*** Exception: Prelude.read: no parse
```

これを避けるためにはいくつかの方法があります。まずは最も確実な方法をお伝えしましょう。

#### 型推論とは

...と、その前に、重要な話なのでこのエラーの詳細について解説させてください。  
少し難しい話ですがどうかお付き合いを。🙏  
少なくとも今回の課題を解く**だけ**であれば必要ないので、難しい場合は次の節まで飛ばしてしまうのもありかもしれません。

先ほどのエラーは、Haskellの「型推論」という機能と、そのデフォルトの挙動が組み合わさってしまったことによるエラーです。

さて、「型推論」とは一体なんでしょうか？  
文字通り「型」を推論する機能なのですが、そもそもその「型」とは何か、といった点から説明したいと思います。  
Haskellやその他の多くのプログラミング言語において「型」とは、「文字」や「整数」、「文字列」といった、値の「種類」を表す分類です。  
Haskellは静的型付言語であるため、Haskellのソースコードに現れるありとあらゆる式は、プログラムとして実行する前の時点で、なんらかの「型」に分類されます。  
これは、これまでの課題で代入した、`main`関数や、`getContents`を実行した結果を結びつけた、変数も例外ではありません。

他の静的型付言語を経験した方であれば、`main`関数を定義した際や`getContents`を実行した結果を代入した際に、型注釈を書かなかったことにお気づきかもしれません。  
実はHaskellは、静的型付言語でありながら、多くの箇所で型注釈を書かなくてもよいことになっています。  
それを可能にしてくれているのがその「型推論」という機能です。

「型推論」は、実際に関数や変数を含む式がどのように使われているかを見ることで、自動で式の型を決定してくれる機能です。  
これまでの課題では、私たちは文字列（例えば`"Hello, world!"`）や数値（例えば`60`や`1.7`）といった値について、それらが何の型であるか、特に言及せずに扱うことができました。  
実際のところ、Haskellでは文字列は`String`という型に属しますし、`60`のような整数は通常`Integer`型に属し、`1.7`のような小数を含む数値は、通常`Double`型に属します。  
加えて、`main`関数には、`IO`という変わった名前の型に必ず属します（これについてはもっと先の課題で紹介しましょう）。  
これまでそれらの名前に一切触れなくて済んだのは、型推論のおかげなのです。

型推論は、`read`関数のような、様々な型の値を返すことができる関数（「多相関数」と呼ばれます）を簡単に扱えるようにするために、とても重要な機能です。  
しかし、「様々な型の値を返すことができる関数」はその原理上、型推論にとってやっかいなものになることがあります。  
Haskellの強力な型推論機能を持ってしても、**どんな型の値を返すか決定できない場合がある**のです。  
例えば先ほどのように、GHCiの中で`read`関数を使用した場合がその典型的なケースです。  
`read`関数の**返す値**はその性質上、「様々な型の値」になり得ます。  
そして、GHCiがHaskellの式を評価した結果を表示する関数 --- 第2章で学習した、`print`関数のことですね --- は、「様々な型の値」を**引数として受け取る**関数（これも「多相関数」と呼ばれます）となっています。  
このように、「様々な型の値」を返す関数と、それを引数として受け取る関数が組み合わさった式を見つけると、型推論機能は決定不能に陥ってしまいます。

通常であれば、そうした場合Haskellは決定できなかった式を「曖昧な(ambiguous)型」として扱い**型エラー**にします。  
しかし、それでは困る場合が（特に、GHCiのように短い式を評価することが多いプログラムでは）あるので、Haskellは一部のケースにおいて「曖昧な型」をエラーとしないで、代わりに「デフォルトの型」として解釈することにしています。  
それが今回エラーを起こした`read "2.0"`の結果の型なのです。  
GHCiは、「`read "2.0"`の結果を`print`関数で表示する式」を型推論する際、`print`関数に渡す引数の型を、そのデフォルトの型である`()`という変な名前の型として解釈します。「ユニット」と呼ばれています。  
この「ユニット」という型の値を`read`関数によって（無事、エラーを起こさず）返させるには、`"()"`という文字列を与えればよいのです。

```
ghci> read "()"
()
```

`*** Exception`などと出ていませんね。これは、ちゃんとエラーを起こさずに`read "()"`を実行できた証拠です！よかった！😌

#### 確実な解決方法: 型注釈をつける

... いや、`read "()"`をエラーを起こさずに実行できてもあまりうれしいことはありません。  
私たちがエラーを起こさずに実行したいのは`read "2.0"`の方です。
`read "2.0"`という式の型がデフォルトの型ではなく、希望する数値の型(`Double`型)とするには、どうすればいいでしょうか？  
それを解決するのが型注釈です。

C言語などの一部の静的型付のプログラミング言語では、変数や関数を定義する際に型宣言をすることができます。  
Haskellでは、同じように変数や関数の型宣言をする機能に加え、**あらゆる式**に対して「ここの式はこの型ですよ」と明確に示す機能があります。  
それが型注釈です。

具体的には、「ここの式はこの型ですよ」とHaskellに教えてあげたい式の後ろに、`:: 型の名前`と書けば、指定した式に対して型注釈を加えることができます。  
下記は`read "2.0"`という式に対して数値の型(`Double`型)という型注釈を加える例です:

```
ghci> read "2.0" :: Double
2.0
```

ついに、`read "2.0"`をエラーを起こすことなく実行できました！🎉

型注釈の使い方についてもう少し捕捉しましょう。  
他の式と同じように、カッコで囲うことで、どの式に注釈を加えたいかをコントロールすることもできます。  
次に示す例では、カッコで囲った、`(read "2" + read "1")`という式全体に対して整数型(`Integer`)という型注釈を加えています。

```
ghci> (read "2" + read "1") :: Integer
3
```

もちろん、間違った型注釈をすると、ちゃんと型エラーにしてくれます。

```
ghci> "2.0" :: Double

<interactive>:2:1: error:
    • Couldn't match expected type ‘Double’ with actual type ‘[Char]’
    • In the expression: "2.0" :: Double
      In an equation for ‘it’: it = "2.0" :: Double
```

これまでにも見かけたことがあるかも知れませんが、複数行にまたがる`Couldn't match expected type ... ` や、`No instance for ...`などというエラーメッセージを見たら、型エラーなんだと考えてください。`read "2.0"`を実行したとき出た`*** Exception: ...`とは異なりますよね。

#### よくある解決方法: 型が曖昧にならないように使用する

型注釈を適切に使うことで、`read`関数が文字列をおかしな型の値に変換するのを回避できることを学びました。  
一方この問題は、もう少し大きなHaskellのプログラムを書く場合、問題にならないことが多いです。  
少なくとも今回の課題を解くだけであれば、気にしなくて良いはずです。  
型推論機能がちゃんと働いて、どの型なのかを曖昧にならずに判断できる式を書けばよいのです。それだけです。  
例えば今回の`read "2.0"`であっても、次のように`+ 0.0` と着けるだけでエラーを回避できます。

```haskell
ghci> read "2.0" + 0.0
2.0
```

これは、`read "2.0"`の結果に対して`+ 0.0`という計算をしようとしていることから、Haskellの型推論機能が「あっ、この`read "2.0"`の結果は数値の型(`Double`型)として解釈すればいいんだ！」と判断しているためです。

### 複利計算の公式

それでは肝心の、「預けた年数後の預入額」を計算する際の式をHaskellで書いてみましょう。  
日本語で言うと、次のような式で計算されます。

```
預けた年数後の預入額 = 元金 × (1 + 年利)の「年数」乗
```

おっと、「『年数』乗」ということは、累乗の計算が必要ですね。  
ほかのプログラミング言語で累乗を計算する際は`**`や`^`という演算子、はたまた`pow`関数などを使用しますが、Haskellでは果たして何を使うのでしょうか！？

... 答えはキャレット `^` です！

```haskell
ghci> 2 ^ 10
1024
```

そして、ここで言う「年利」は問題の仕様上、パーセントとして入力されるため、100で割る必要があります。  
つまり次のような式になりますね。

```
預けた年数後の預入額 = 元金 × (1 + 年利(%) ÷ 100) ^ 年数
```

第2章で習ったとおり、足し算・かけ算・割り算にはそれぞれ `+`, `*`, `/` を使います。  
元金・年利(%)・預けた年数をそれぞれ`principal`・`interestRate`・`years`という変数に割り当てれば、最終的に下記のようなHaskellの式になるでしょう:

```haskell
principal * (1 + interestRate / 100) ^ years
```

## 課題の解き方

今回も課題4と同様、`do`記法の中で`<-`を使って`getLine`関数の実行結果を代入するのがポイントです。  
`getLine`で読んだ各行を変数に代入した後は、`read`関数で数値に変換しつつ、上記の複利計算の式に当てはめましょう。  
「Haskellでは関数呼び出しが最も優先して結合される」というルールを思い出しつつ、カッコで囲う場所にはくれぐれも気をつけてください。
