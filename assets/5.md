# 型注釈をつける・入力を数値に変換する

複利計算をして、将来儲かるお金を計算しましょう💰:

1. 標準入力から3行の入力を受け取ります。
1. 1行目は元金の額として解釈します。
1. 2行目は1年間あたりの金利（**単位はパーセント**）として解釈します。
1. 3行目は預けた年数として解釈します。
1. 以上の入力を元に、預けた年数後の預入額を計算してください。

## 注意事項

- 小数点以下の値に対して、四捨五入などの丸め処理をする必要はありません。
- 浮動小数点数の丸め誤差を気にする必要もありません。

## 実行結果例

「元金100円、金利1%で2年間預けた場合」を計算した結果です。

```bash
shell> stack exec runhaskell 5.hs
100 # ここはユーザーが入力する箇所
1   # ここもユーザーが入力する箇所
2   # ここまでユーザーが入力する箇所
102.01
```

## 必要な知識

### `getLine`で標準入力から1行ずつ読み出す

前回の課題では、`getContents`という命令を使って、標準入力からすべての文字列を読み出す方法を習いました。  
今回の課題では、「標準入力から3行の入力を」受け取り、なおかつ各行で受け取った文字列を別々に扱う必要があります。  
標準入力から1行ずつ読まなければならないでしょう。  
そのために使う関数は`getLine`といいます。

早速GHCiで試してみましょう。

```haskell
ghci> getLine
```

`getLine`と入力してEnterキーやReturnキーを押した時点では、プロンプトが表示されず、GHCiが止まったように見えますよね。  
これは`getLine`関数が標準入力から入力を待ち受けている証拠です。  
そのまま適当な文字列を入力してEnterまたはReturnを押せば、入力した結果がGHCiによって出力されるはずです。

```haskell
ghci> getLine
This is a line I entered!
--                       ^ ここでEnterまたはReturn
"This is a line I entered!"
-- ^ これはGHCiが`getLine`を実行した結果を出力したもの
ghci>
```

EnterやReturnを押した直後に出てきた文字列、ここでは`"This is a line I entered!"`に注目してください。  
これは`getLine`を実行した結果の文字列を、Haskellにおける文字列リテラルの形式で出力したものです。  
Rubyで言うところの`inspect`、Pythonで言うところの`repr()`を実行した結果だと言えば通じるでしょうか？  
非印刷文字や改行文字など、普通に`putStrLn`や`putStr`で表示しようとするとわかりづらい文字も見やすくしてくれます。

### 入力を数値に変換する

続いて、`getLine`で受け取った文字列を数値に変換することで、足し算やかけ算などの計算に使えるようにしましょう。  
そのためには、`read`という関数を使います。

ただし、この`read`関数、GHCiで扱う際は非常にやっかいな性質を持っています。  
そのまま試そうとしても、下記のようにエラーになってしまいます。

```haskell
ghci> read "2.0"
*** Exception: Prelude.read: no parse
```

これを避けるためにはいくつかの方法があります。まずは最も確実な方法をお伝えしましょう。

#### 型推論とは

...と、その前に、重要な話なのでこのエラーの詳細について解説させてください。  
少し難しい話ですがどうかお付き合いを。🙏  
少なくとも今回の課題を解く**だけ**であれば必要ないので、難しい場合は次の節まで飛ばしてしまうのもありかもしれません。

先ほどのエラーは、Haskellの「型推論」という機能と、そのデフォルトの挙動が組み合わさってしまったことによるエラーです。

さて、「型推論」とは一体なんでしょうか？  
文字通り「型」を推論する機能なのですが、そもそもその「型」とは何か、といった点から説明したいと思います。  
Haskellやその他の多くのプログラミング言語において「型」とは、「文字」や「整数」、「文字列」といった、値の「種類」を表す分類です。  
Haskellは静的型付言語であるため、Haskellのソースコードに現れるありとあらゆる式は、プログラムとして実行する前の時点で、なんらかの「型」に分類されます。  
これは、これまでの課題で代入した、`main`関数や、`getContents`を実行した結果を結びつけた、変数も例外ではありません。

他の静的型付言語を経験した方であれば、`main`関数を定義した際や`getContents`を実行した結果を代入した際に、型注釈を書かなかったことにお気づきかもしれません。  
実はHaskellは、静的型付言語でありながら、多くの箇所で型注釈を書かなくてもよいことになっています。  
それを可能にしてくれているのがその「型推論」という機能です。

「型推論」は、実際に関数や変数を含む式がどのように使われているかを見ることで、自動で式の型を決定してくれる機能です。  
これまでの課題では、私たちは文字列（例えば`"Hello, world!"`）や数値（例えば`60`や`1.7`）といった値について、それらが何の型であるか、特に言及せずに扱うことができました。  
実際のところ、Haskellでは文字列は`String`という型に属しますし、`60`のような整数は通常`Integer`型に属し、`1.7`のような小数を含む数値は、通常`Double`型に属します。  
加えて、`main`関数には、`IO`という変わった名前の型に必ず属します（これについてはもっと先の課題で紹介しましょう）。  
これまでそれらの名前に一切触れなくて済んだのは、型推論のおかげなのです。

型推論は、`read`関数のような、様々な型の値を返すことができる関数（「多相関数」と呼ばれます）を簡単に扱えるようにするために、とても重要な機能です。  
しかし、「様々な型の値を返すことができる関数」はその原理上、型推論にとってやっかいなものになることがあります。  
Haskellの強力な型推論機能を持ってしても、**どんな型の値を返すか決定できない場合がある**のです。  
例えば先ほどのように、GHCiの中で`read`関数を使用した場合がその典型的なケースです。  
`read`関数の**返す値**はその性質上、「様々な型の値」になり得ます。  
そして、GHCiがHaskellの式を評価した結果を表示する関数 --- 第2章で学習した、`print`関数のことですね --- は、「様々な型の値」を**引数として受け取る**関数（これも「多相関数」と呼ばれます）となっています。  
このように、「様々な型の値」を返す関数と、それを引数として受け取る関数が組み合わさった式を見つけると、型推論機能は決定不能に陥ってしまいます。

通常であれば、そうした場合Haskellは決定できなかった式を「曖昧な(ambiguous)型」として扱い**型エラー**にします。  
しかし、それでは困る場合が（特に、GHCiのように短い式を評価することが多いプログラムでは）あるので、Haskellは一部のケースにおいて「曖昧な型」をエラーとしないで、代わりに「デフォルトの型」として解釈することにしています。  
それが今回エラーを起こした`read "2.0"`の結果の型なのです。  
GHCiは、「`read "2.0"`の結果を`print`関数で表示する式」を型推論する際、`print`関数に渡す引数の型を、そのデフォルトの型である`()`という変な名前の型として解釈します。「ユニット」と呼ばれています。  
この「ユニット」という型の値を`read`関数によって（無事、エラーを起こさず）返させるには、`"()"`という文字列を与えればよいのです。

```
ghci> read "()"
()
```

`*** Exception`などと出ていませんね。これは、ちゃんとエラーを起こさずに`read "()"`を実行できた証拠です！よかった！😌

#### 確実な解決方法: 型注釈をつける

... いや、`read "()"`をエラーを起こさずに実行できてもあまりうれしいことはありません。  
私たちがエラーを起こさずに実行したいのは`read "2.0"`の方です。
`read "2.0"`という式の型がデフォルトの型ではなく、希望する数値の型(`Double`型)とするには、どうすればいいでしょうか？  
それを解決するのが型注釈です。

C言語などの一部の静的型付のプログラミング言語では、変数や関数を定義する際に型宣言をすることができます。  
Haskellでは、同じように変数や関数の型宣言をする機能に加え、**あらゆる式**に対して「ここの式はこの型ですよ」と明確に示す機能があります。  
それが型注釈です。

具体的には、「ここの式はこの型ですよ」とHaskellに教えてあげたい式の後ろに、`:: 型の名前`と書けば、指定した式に対して型注釈を加えることができます。  
下記は`read "2.0"`という式に対して数値の型(`Double`型)という型注釈を加える例です:

```
ghci> read "2.0" :: Double
2.0
```

ついに、`read "2.0"`をエラーを起こすことなく実行できました！🎉

型注釈の使い方についてもう少し捕捉しましょう。  
他の式と同じように、カッコで囲うことで、どの式に注釈を加えたいかをコントロールすることもできます。  
次に示す例では、カッコで囲った、`(read "2" + read "1")`という式全体に対して整数型(`Integer`)という型注釈を加えています。

```
ghci> (read "2" + read "1") :: Integer
3
```

もちろん、間違った型注釈をすると、ちゃんと型エラーにしてくれます。

```
ghci> "2.0" :: Double

<interactive>:2:1: error:
    • Couldn't match expected type ‘Double’ with actual type ‘[Char]’
    • In the expression: "2.0" :: Double
      In an equation for ‘it’: it = "2.0" :: Double
```

これまでにも見かけたことがあるかも知れませんが、複数行にまたがる`Couldn't match expected type ... ` や、`No instance for ...`などというエラーメッセージを見たら、型エラーなんだと考えてください。`read "2.0"`を実行したとき出た`*** Exception: ...`とは異なりますよね。

#### よくある解決方法: 型が曖昧にならないように使用する

型注釈を適切に使うことで、`read`関数が文字列をおかしな型の値に変換するのを回避できることを学びました。  
一方この問題は、もう少し大きなHaskellのプログラムを書く場合、問題にならないことが多いです。  
少なくとも今回の課題を解くだけであれば、気にしなくて良いはずです。  
型推論機能がちゃんと働いて、どの型なのかを曖昧にならずに判断できる式を書けばよいのです。それだけです。  
例えば今回の`read "2.0"`であっても、次のように`+ 0.0` と着けるだけでエラーを回避できます。

```haskell
ghci> read "2.0" + 0.0
2.0
```

これは、`read "2.0"`の結果に対して`+ 0.0`という計算をしようとしていることから、Haskellの型推論機能が「あっ、この`read "2.0"`の結果は数値の型(`Double`型)として解釈すればいいんだ！」と判断しているためです。

### 複利計算の公式

それでは肝心の、「預けた年数後の預入額」を計算する際の式をHaskellで書いてみましょう。  
日本語で言うと、次のような式で計算されます。

```
預けた年数後の預入額 = 元金 × (1 + 年利)の「年数」乗
```

おっと、「『年数』乗」ということは、累乗の計算が必要ですね。  
ほかのプログラミング言語で累乗を計算する際は`**`や`^`という演算子、はたまた`pow`関数などを使用しますが、Haskellでは果たして何を使うのでしょうか！？

... 答えはキャレット `^` です！

```haskell
ghci> 2 ^ 10
1024
```

そして、ここで言う「年利」は問題の仕様上、パーセントとして入力されるため、100で割る必要があります。  
つまり次のような式になりますね。

```
預けた年数後の預入額 = 元金 × (1 + 年利(%) ÷ 100) ^ 年数
```

第2章で習ったとおり、足し算・かけ算・割り算にはそれぞれ `+`, `*`, `/` を使います。  
元金・年利(%)・預けた年数をそれぞれ`principal`・`interestRate`・`years`という変数に割り当てれば、最終的に下記のようなHaskellの式になるでしょう:

```haskell
principal * (1 + interestRate / 100) ^ years
```

### `let`で「純粋な計算」の結果を変数に代入する

今回の課題は、ここまでで説明した知識で十分解くことができます。  
しかし、もう一つだけ新しい構文を覚えることで、もっとエレガントに解けるようになります。それは`let`です。  
`let`を使うと、`lines`関数や`reverse`関数、それから足し算 `+`やかけ算 `*`などによって作られる値を、変数に代入できるようになります。  
例えば課題4では、次のように「文字列を、改行文字で区切って、逆順に並び替えて標準出力に出力する」までの処理を、一つの大きな式で書いていましたね。

```haskell
putStr (unlines (reverse (lines input)))
```

課題4を解いていた方の中には、次のように、「改行文字で区切った結果」や「逆順に並び替えた結果」などを逐一変数に代入したくなった方もいらっしゃるかも知れません。

```haskell
splitByLine = lines input
reversed = reverse splitByLine
result = unlines reversed
putStr result
```

残念ながら、Haskellではこれはできません（実は[できるようにしようという議論][1]もありますが、解釈が曖昧になるケースがあり、2018年12月現在保留されています）。  
`do`記法の中で（`getContents`のような、「命令」以外によって作られる）普通の値を変数に代入する場合は、次のように書きましょう。  
課題4の解答を`let`で書き換えた場合を例に示します。

[1]: https://github.com/ghc-proposals/ghc-proposals/pull/62

```haskell
do
  -- ... 省略
  let splitByLine = lines input
  let reversed = reverse splitByLine
  let result = unlines reversed
  -- ... 省略
```

`let <変数名> = <式>`と書くことで`<変数名>`の変数に`<式>`の結果を代入することができます。  
`do`の中で`let`で代入する変数がいくつも続く場合、`let`は1行目だけにして、2行目以降は省略することができます。  
先ほどの例で言うと、次のように書き換えることができる、ということです。

```haskell
do
  -- ... 省略
  let splitByLine = lines input
      reversed = reverse splitByLine
      result = unlines reversed
  -- ... 省略
```

間に「命令」が挟まってしまった場合、この方法は使えません。

```haskell
do
  -- ... 省略
  let splitByLine = lines input
  anotherInput <- getContents
      reversed = reverse splitByLine -- これはダメ！
      result = unlines reversed      -- これもダメ！
  -- ... 省略
```

その場合、改めて`let`を挟みましょう。

```haskell
do
  -- ... 省略
  let splitByLine = lines input
  anotherInput <- getContents
  let reversed = reverse splitByLine -- これはOK！
      result = unlines reversed      -- これもOK！
  -- ... 省略
```

そして、ここでもう一度強調しておきたいのは、`let`で代入するのは、`getContents`のような、「命令」以外によって作られる普通の値だけ、という点です。  
Haskellでは、`getContents`や`putStrLn`のような入出力などを行う「命令」と、それ以外の「純粋な計算」とを厳密に区別しています。  
「純粋な計算」とはなんでしょうか？それは、次のような特徴を持った計算です。

1. 「副作用」を持たない:
    - 「純粋な計算」は**計算以外の処理を一切行いません**。  
      例えば、`1 + 2 * 7`という「純粋な計算」は、計算を始めてから`15`という結果を返すまでの間に、どこかのファイルに何かを書き込んだり、外部のサーバーと何かしらおしゃべりしたり、ましてやミサイルを発射したり、なんてことは決してしません。`lines`関数や`reverse`関数も同様です。  
      あくまでも、引数や両辺に渡された値を最終的な結果に変換するだけのことしかしないのです。
1. 同じ式は必ず同じ結果になる:
    - 「純粋な計算」の結果（関数や演算子の戻り値）は、**同じ関数や演算子に同じ値を同じ順番で渡した場合、必ず同じ値**となります。  
      例えば、`getContents`関数はユーザーなどからの入力を結果として返すため、実行する度に違う結果を返す可能性があります。ユーザーは気まぐれなのです。  
      それからまだ紹介してませんが、乱数を取得する関数も、実行する度に結果が変わるので「純粋な計算」とはいえません。乱数もやっぱり気まぐれなのです。

結果的に「純粋な計算」は、**外から受けうる影響の範囲と、外に与えうる影響の範囲が、常に明瞭**となります。  
「純粋な計算」は、関数や演算子に渡した値からしか影響を受けませんし、`let`で代入する変数以外に影響を与えることもありません[2]。  
このような性質があるからこそ、Haskellでは「純粋な計算」とそれ以外の「命令」とを厳密に区別しています。  
区別することで、あなたが書いたソースコードの「影響範囲が明瞭な箇所」と「それ以外の箇所」を分離し、理解しやすくします（実際には、「それ以外の箇所」だらけのソースコードになってしまうことも多いですが😅）。

[2]: もっと正確には、関数の結果を受け取るまた別の関数意外に影響を与えることもない、と言う意味です。

ここまでを見る限り、代入の際に使う構文ぐらいしか違いがありません。  
しかしこの先で、この使い分けの裏に隠された巧妙なトリックを知ることになるでしょう。乞うご期待。

まとめて、以下の点を押さえておきましょう。

- `let <変数名> = <式>`
    - 代入する値の種類: 「純粋な計算」によって作られる値
    - 例: `let splitByLine = lines input`
- `<変数名> <- <命令>`
    - 代入する値の種類: 「命令」を実行した結果得られる値
    - 例: `input <- getContents`

また、`<-`と同様、`do`記法の中でしか`let <変数名> = <式>`を使った書き方はできません。  
`do`記法の中以外で代入する方法については、またの機会に。

#### `let`で「文字列を数値に変換する式」と「複利計算を行う式」を明確に分ける

今回の課題で`let`を使うならば、`read`関数で読み出した文字列を数値に変換する処理と、実際に複利計算を行う処理を分けるために使うのが良いでしょう。  
「数値を計算する」というこのアプリケーションのコアに当たる処理と、（標準入力という）外の世界からやってくる文字列をコアの処理向けに変換する処理を分割できれば、コアの処理の再利用性を高められるでしょうし、読みやすくもなりそうです。

課題のヒントを兼ねて、「1行目を`getLine`で受け取って、元金の額として変換する」処理までを例示しましょう。

```haskell
  line1 <- getLine
  let principal = read line1
```

これと同じ要領で他の行を変換した数値も`let`で代入すれば、「`principal * (1 + interestRate / 100) ^ years`」という式にすっきり当てはめることができますね！  
`let`を使わないバージョンと併せて書いてみて、比べてみるのも良いでしょう。

## 課題の解き方

今回も課題4と同様、`do`記法の中で`<-`を使って`getLine`関数の実行結果を代入するのがポイントです。  
`getLine`で読んだ各行を変数に代入した後は、`read`関数で数値に変換しつつ、上記の複利計算の式に当てはめましょう。`read`関数を実行した結果を`let`で新しい変数に代入すると、よりわかりやすく書けます。  
「Haskellでは関数呼び出しが最も優先して結合される」というルールを思い出しつつ、カッコで囲う場所にはくれぐれも気をつけてください。
