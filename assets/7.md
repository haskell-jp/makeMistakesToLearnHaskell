# 型クラスで自分が作った型を拡張する

課題6で作ったプログラムを元に、次のようなプログラムを書きましょう。

1. 標準入力から2行の入力を受け取ります。
2. 1行目は「分類」を表す文字列として解釈します。
3. 2行目は「金額」を表す整数として解釈します。
4. それぞれを`Entry`型の値としてまとめます。
5. まとめた値を**デバッグ時に特に便利な方法で**標準出力に出力してください。

## 必要な知識

冒頭のとおり今回は課題6で作ったプログラムを元に作ることになるので、下記の知識は既知のものとして省略します。  

- `getLine`で標準入力から1行ずつ読み出す
- `read`で入力を数値に変換する
- 自分でレコード型を定義する

作るときもコピペしちゃってから作るのがおすすめです！

### `deriving`で型クラスの実装を自動で定義する

「5. まとめた値を**デバッグ時に特に便利な方法で**標準出力に出力してください」の「デバッグ時に特に便利な方法」とはなんでしょう？  
ここではそれは、`print`関数で出力することを指します。  
そう、みんな大好きprintデバッグをするときに、`Entry`型を簡単に扱えるようにするのが今回の課題の目的です！

結論から言うと、課題6で書いた下記の`data`宣言に、

```haskell
data Entry =
  Entry
  { category :: String
  , price :: Integer
  }
```

次のように`deriving Show`という魔法のフレーズを追記してください。たったそれだけです。

```haskell
data Entry = Entry
  { category :: String
  , price :: Integer
  } deriving Show
```

早速GHCiにも入力してみましょう。  
前の課題で習った`:{`と`:}`を使うのを忘れないでくださいね！

```haskell
ghci> :{
ghci| data Entry = Entry
ghci|   { category :: String
ghci|   , price :: Integer
ghci|   } deriving Show
ghci| :}
ghci>
```

```haskell
ghci> print (Entry "Food" 150)
Entry {category = "Food", price = 150}
```

出来ました！🎉

皆さんが入力した式を標準出力に書き込む際にGHCiが使用しているのが`print`関数なので、自分で`print`を書かなくとも、同じ結果になります。

```haskell
ghci> Entry "Food" 150
Entry {category = "Food", price = 150}
```

`deriving Show`をつけていなかった場合、つまり、前の課題で`Entry`型の値を入力していたときは、次のような型エラーになっていました。

```haskell
ghci> Entry "Magazine" 120

<interactive>:8:1: error:
    • No instance for (Show Entry) arising from a use of ‘print’
    • In a stmt of an interactive GHCi command: print it
```

このエラーメッセージの肝となる箇所は`No instance for (Show Entry) arising from a use of ‘print’`という行です。  
これは、「`Entry`型は`Show`型クラスのインスタンスではないので、`print`関数に渡すことは出来ないよ！」というエラーです。

### 型クラスとは？

型クラスは、一言で言うと「同じような特徴（振る舞い）を持った型を、まとめて扱えるようにする仕組み」です。  
他のプログラミング言語で言うと、「インターフェイス」とか、「プロトコル」といった仕組みとちょっと似ています。  
ある型クラスが表す特徴を備えた型を、その型クラスの「インスタンス」と呼びます。  
自分が作った型を「型クラスのインスタンスにする」ことで、その型クラスのインスタンスの値を受け取る関数が、すべて再利用できるようになります。

例えば、今回出てきた`Show`型クラスは、「（主にデバッグ向けの）文字列に変換できる」という特徴を備えた型をまとめています。  
これまでに紹介した型を始め、Haskellにおける多くの型はこの`Show`型クラスのインスタンスとなっています。  
皆さんが作った型（今回の場合`Entry`型）を`Show`型クラスのインスタンスにすることで、`print`関数などの、「文字列に変換できる」という特徴を使った関数を再利用できるようになるのです。

今の話をさらに具体的に知るために、`Show`型クラスの定義を見て、実際にそのインスタンスを定義してみましょう。

GHCiに`:i Show`と入力することで、`Show`型クラスの定義と、`Show`型クラスのインスタンスの一覧を見ることが出来ます。

```haskell
ghci> :i Show
class Show a where
  showsPrec :: Int -> a -> ShowS
  show :: a -> String
  showList :: [a] -> ShowS
  {-# MINIMAL showsPrec | show #-}
        -- Defined in ‘GHC.Show’
instance [safe] Show Entry -- Defined at <interactive>:6:14
-- ... 省略
ghci>
```

非常に長い出力が出ましたが、重要なのは、冒頭の`class Show a where`で始まる行から、`instance [safe] Show Entry`で始まる行までです。

まず、`class Show a where`で始まる行から、インデントされている行、つまり`-- Defined in ‘GHC.Show’`という行までが、`Show`型クラスの定義です（Haskellの多くの構文は、インデントで範囲を示すというのを思い出してください）。  
最初の`class Show a where`は、「今から`Show`と言う名前の型クラスを宣言しますよ。それはどんなのかというとね...」という意味です。  
その次の3行、つまり`showsPrec`、`show`、`showList`で始まる行が、型クラスの「メソッド」とその型を宣言している行です。

型クラスのメソッドとは、その型クラスのインスタンス、すなわちその型クラスが表す特徴を備えた型には、「こんな関数を適用することが出来ますよ」という関数です。  
ある型を型クラスのインスタンスにするには、これらの「メソッド」と呼ばれる関数の中身を実装しないといけません。  
Javaなどのプログラミング言語における「インターフェイス」をご存じの方は、これがインターフェイスのメソッドと同じ特徴であることにお気づきでしょう。やっぱり似てますよね。

さらに次の行`{-# MINIMAL showsPrec | show #-}`は、特別なコメントです。  
先ほど「ある型を型クラスのインスタンスにするには、『メソッド』と呼ばれる関数の中身を実装しないといけない」と述べました。  
実際には、この`{-# MINIMAL ... #-}`という特別なコメントで宣言されたメソッドのみを実装しておくだけでよいことになっています。  
`{-# MINIMAL ... #-}`の詳細な構文は割愛しますが、この場合`showsPrec`か`show`の「どちらか一方」のみを実装すればよいです。  
`showList`が実装されない場合はどうなるのかというと、`showsPrec`メソッドや`show`メソッドの実装を利用して自動で実装されます。

あと、`-- Defined in ‘GHC.Show’`というのは`:i`コマンドが出したただの（なんら特別な意味もない）コメントです。型クラスが実際に定義されている場所が書かれています。

続いて、`instance [safe] Show Entry`と書かれている行が、「`Entry`型は`Show`型クラスのインスタンスだよ」という意味の宣言です。それ以上の意味は特にありません。

### 自分で作った型を型クラスのインスタンスにする

#### その1. 楽な方法

それでは、実際に`Entry`型が、どのように`Show`型クラスのインスタンスになっているか見るために、`Entry`型を`Show`型クラスのインスタンスにしてみましょう。  
まずは最も簡単な方法です。

... と、実はそれはすでに紹介しました。  
そう、先ほどの`Entry`型の定義

```haskell
data Entry = Entry
  { category :: String
  , price :: Integer
  } deriving Show
```

に追記した`deriving Show`、これを書くだけです。  
Haskellの仕様上、`Show`型クラスのような、特によく使われる型クラスは、型を定義する際に`deriving Show`と書くだけで、自動的にその型をインスタンスにすることができるようになっています。  
Haskellは`deriving Show`された型の定義 --- どんな値コンストラクターを定義してどんなレコードラベルにどんな型を紐付けているか --- を見て、`show`メソッドや`showsPrec`メソッドなどの実装を自動で生成してくれます。  
実際にどのようなアルゴリズムで生成しているのかは、「Haskell 2010 Language Report」というHaskellの「標準の仕様」をまとめたサイトの[11章][1]に載っています。  
まだこの入門で紹介していない知識が必要な上、かなり難しい書き方がされていますので、チャレンジしてみたい方は読んでみてください。

[1]: https://www.haskell.org/onlinereport/haskell2010/haskellch11.html

#### その2. 面倒だけどおもしろい方法

もちろん、`show`メソッドや`showsPrec`メソッドの実装を自分で書くことで、`Show`型クラスのインスタンスにすることもできます。  
自分でメソッドの実装を書いてみることで、型クラスに対する理解がより深まるでしょう。  
例によって今回の課題を解くために必須な知識ではないので、面倒くさいという方は飛ばしちゃってください。

やり方を説明する前に、新しい（`deriving Show`していない）`Entry2`という型を定義しておきましょう。  
先ほど定義した`Entry`型はすでに`Show`型クラスのインスタンスですので、自分で`show`メソッドなどの実装を書き換えることが出来ないのです。

```haskell
ghci> :{
ghci| data Entry2 = Entry2
ghci|   { category2 :: String
ghci|   , price2 :: Integer
ghci|   }
ghci| :}
```

##### 真面目な実装にしてみる

先ほど`{-# MINIMAL showsPrec | show #-}`を解説したとき触れたとおり、新しい型を`Show`型クラスのインスタンスにするには、「`showsPrec`か`show`のどちらか一方のみを実装すればよい」ことになっています。  
このうち、`show`メソッドのほうは、これまでに数値を文字列に変換するために度々使用してきました（もちろん、数値も`Show`型クラスのインスタンスだから`show`関数が使えるのです）。  
なので親しみやすいでしょうから、こちらを実装することで`Entry2`型を`Show`型クラスのインスタンスにしてましょう。

`deriving`を使わず、自分で`show`メソッドの定義を書いて`Entry2`型を`Show`型クラスのインスタンスにしたい場合、下記のように`instance`というキーワードで宣言します。

```haskell
instance Show Entry2 where
  show entry2 = category2 entry2 ++ "," ++ show (price2 entry2)
```

1行目の`instance Show Entry2 where`という行で、「今から`Entry2`という型を`Show`型クラスのインスタンスにします。そのメソッドの定義はね...」と宣言します。  
それ以降のインデントした行において、`Entry2`型を`Show`型クラスのインスタンスにする上で必要な、メソッドの実装を行います。  
繰り返しになりますが`Show`型クラスにおいては`show`メソッドを実装すればよいので、この場合`show`メソッドのみ実装しています。

ここで出てくる`show`メソッドの定義を書くときの構文は、インデントが必要なことを除けば関数を定義する構文と全く変わりません。  
しかし、当入門があまりにも最小主義的に進めていたせいか、そういえばまだその関数を定義する構文も紹介していませんでした😥。  
改めて必要になったときにまた触れますが、ここでも簡単に紹介します。

まず、`show entry2 = `という箇所で、定義する関数の名前とその引数を列挙します。  
この場合、定義する関数の名前は「`show`」で、残りの`entry2`が引数です。`entry2`という一つだけの引数をとることになっています。

イコール `=` より後ろの`category2 entry2 ++ "," ++ show (price2 entry2)`という箇所に、`show`メソッドの実装、すなわち`Entry2`型の値に対して`show`メソッドはどのような処理を行うかを書きます。  
他のプログラミング言語のように`return`といったキーワードで戻り値を明示する必要はなく（そもそも、`return`に相当するものがありません！）、 `=` 以降に書いた式がそのまま関数の戻り値となります。

それでは、`Entry2`に対する`show`メソッドの本体を見てみましょう。  
いずれの式もこれまでの課題で学習した関数や演算子を使用しているため、詳しい説明は省略します。  
次の段落で動作例を示しますが、その前に、復習も兼ねて自力で推測してみてください！

...推測できたでしょうか？  
それではGHCiで試してみましょう。  
例のごとく`:{`と`:}`を使って複数行の入力を有効にするのをお忘れなく。

```haskell
ghci> :{
ghci| instance Show Entry2 where
ghci|   show entry2 = category2 entry2 ++ "," ++ show (price2 entry2)
ghci| :}
```

```haskell
ghci> show (Entry2 "Magazine" 120)
"Magazine,120"
```

```haskell
ghci> show (Entry2 "Rice" 2000)
"Rice,2000"
```

GHCiに入力した式を標準出力に書き込む際も`show`メソッドは使われているので、`Entry2`型の値をGHCiに入力した結果も、やはり`show`メソッドの実装として書いた式、そのままの結果となります。

```haskell
ghci> Entry2 "Magazine" 120
Magazine,120
```

```haskell
ghci> Entry2 "Rice" 2000
"Rice,2000"
```

#### 変な実装にしてみる

型クラスのメソッドは、インスタンスである型によって動作を変えることができる、ということをより実感するために、もう一つの型を定義して、全く違う`Show`型クラスのインスタンスにしてみましょう。

```haskell
ghci> :{
ghci| data Entry3 = Entry3
ghci|   { category3 :: String
ghci|   , price3 :: Integer
ghci|   }
ghci| :}
```

今度は、どんな値を受け取っても`"Hello, world!"`という文字列を返す、という変な実装にしてみます。

```haskell
ghci> :{
ghci| instance Show Entry3 where
ghci|   show entry3 = "Hello, world!"
ghci| :}
```

早速使ってみましょう。

```haskell
ghci> show (Entry3 "Magazine" 120)
"Hello, world!"
```

```haskell
ghci> Entry3 "Magazine" 120
"Hello, world!"
```

はい、定義のとおり、`Entry3`型の`show`メソッドは、値の中身を一切無視して必ず`"Hello, world!"`を返すという、ヘンテコな実装となりました！

このように、型ごとに`show`メソッドの実装をわけて書くことによって、`Show`型クラスのインスタンスの値を受け取る関数は、いろいろな`show`メソッドを使って振る舞いを変えることが出来ます。

### いろいろな型クラス

※この節は今回の課題を解くだけでは必要ありません。難しいと感じたら適当に飛ばしちゃってください。

#### `Read`型クラス

`Read`型クラスは、`Show`型クラスとある意味で逆のことを行う型クラスです。  
文字列を数値に変換するときに使用した、`read`関数をメソッドとして持っています。  
これはつまり、数値は`Read`型クラスのインスタンスなので、`read`関数を使って文字列から数値に変換することができるし、読者のみなさんが定義した型も`Read`型クラスのインスタンスにすれば、`read`関数を使って文字列からその値を作れるようになる、ということです。

「文字列からその値を作れる」ということをちゃんと型に翻訳して理解しましょう。  
おなじみの`:t`コマンドを使ってください。

```haskell
ghci> :t read
read :: Read a => String -> a
```

👆の型定義をご覧になった方は、少し不思議に感じたかも知れません。  
普通、よくあるオブジェクト指向のプログラミング言語だと、「メソッド」と呼ばれる部類の関数は、メソッドを呼び出すオブジェクトを引数として受け取るように（少なくとも、メソッドの定義において入力として参照できるように）なっています。  
オブジェクトを「入力」の一つとすることによって、どのメソッドの実装を使用するか決定できるワケですね。  
一方、👆の型定義をご覧になると分かるとおり、`read`メソッドにおいては「入力」にあたる引数の部分に、`Read`型クラスのインスタンスの値が存在していません。  
`Read`型クラスは`read`メソッドを使って「文字列からその値を作れる」という性質の型クラスなので、引数として「その型の値」を受け取ることがないのです。

では一体どうやって、「どの型の`read`メソッドを呼ぶか」が決まるのでしょう？  
一言で言うと、「型推論して、判明した型によって」決まります。  
「型」という情報はHaskellのソースコードをコンパイルした時点、つまりプログラムを実行し**始める前**に分かるものなので、ある場所に書いた`read`が何の型の値を返すべきかも、型推論が成功すれば判明します。結果、どの型の`read`関数を呼ぶかも同時に決まります。逆に型推論が失敗した場合は、コンパイルエラーにする、それだけのことです。  
一方、よくあるオブジェクト指向のプログラミング言語では、オブジェクトの中身がどうなっているかは実行時にしかわからない、というのが原則です（実際は言語によってはそうじゃない場合の方が多いですが）。それなので、どのオブジェクトのメソッドを呼ぶかを決める「レシーバー」は必ずメソッドを実行する**直前**にわかる入力として与えられます。

まとめると以下👇の通りです。

- よくあるオブジェクト指向言語のメソッドはレシーバー --- 例えば`object.method()`などと書いたときに現れる`object`、すなわちメソッドを呼び出すオブジェクト --- が、どのメソッドの実装を呼ぶか決める。
- Haskellの型クラスのメソッドは型推論して決定された型が、どのメソッドの実装を呼ぶか決める。

さて、説明が長くなりましたがいよいよあなたが作った`Entry`型の値を`read`関数から作れるよう、`Read`型クラスのインスタンスにしてみましょう。  
`Read`型クラスは`Show`型クラスと同様に、`deriving Read`と追記するだけで対象の型をインスタンスにすることができます。

```haskell
ghci> :{
ghci| data Entry = Entry
ghci|   { category :: String
ghci|   , price :: Integer
ghci|   } deriving Read
ghci| :}
ghci>
```

ただし、`Show`型クラスと`Read`型クラス両方のインスタンスにしたい、といったように、2つ以上の型クラスを`deriving`する場合は、下記のように括弧で囲ってカンマで区切ってください（順番はどちらでも🆗）。

```haskell
ghci> :{
ghci| data Entry = Entry
ghci|   { category :: String
ghci|   , price :: Integer
ghci|   } deriving (Read, Show)
ghci| :}
ghci>
```

括弧で囲わなかった場合、次のように構文エラーとなります。ご注意ください。

```haskell
ghci> :{
ghci| data Entry = Entry
ghci|   { category :: String
ghci|   , price :: Integer
ghci|   } deriving Read, Show
ghci| :}

<interactive>:55:18: error: parse error on input ‘,’
```

それから、実際に`read`関数で`Entry`型の値を作る場合は、次のようにレコード構文で書かれた文字列を渡す必要があります。ちょっと面倒くさいですね。

※課題6の「レコードラベルと値コンストラクターを使ってレコード型の値を作成する」をまだご覧になってない方は、読んでキャッチアップしましょう。

```haskell
ghci> read "Entry { category =  \"Magazine\", price = 120 }" :: Entry
Entry {category = "Magazine", price = 120}
```

⚠️なお、特にGHCi上で試す場合、上記のように`read`関数の戻り値に`:: Entry`と付けて、型を明確にしないといけない点にもご注意ください。  
先ほど説明した「どの型のメソッドを呼ぶか分からない」という問題は、特にGHCiのように短い入力を繰り返す状況で`read`を使用した場合に、しばしば発生します。  
結果、`:: Entry`などの型注釈のない`read "..."`という式をGHCiは変な風に型推論してしまい、思わぬエラーを引き起こしてしまいます💥:

```haskell
ghci> read "Entry { category =  \"Magazine\", price = 120 }"
*** Exception: Prelude.read: no parse
```

本来であればこのような場合、GHCは型推論に失敗して型エラーを起こすのですが、上記のエラーは型エラーではありません。  
課題hogeの`if`式の解説で紹介したような、「`type`」や「`instance`」という単語が含まれていませんよね？

このエラーは実行時エラーです。実行時エラーは型エラーと異なり、あなたが作成したプログラムで発生したとき、プログラムの**実行が途中で止まってしまう**原因となるエラーです。  
一方、型エラーはプログラムをそもそも実行する前に「おかしいよ！」と教えてくれるエラーなので、もう少しいいやつです。どうせ失敗するなら早い方がいいですよね？  
なのでできれば避けたいエラーなのですが、なぜかここでは型エラーとならずに実行時エラーとなってしまいました...。

どうして`:: Entry`を付けなかった場合に実行時エラーとなってしまったのか、については長くなるので申し訳なくも割愛します。  
`ExtendedDefaultRules`と呼ばれるGHCの言語拡張がGHCiでのみデフォルトで有効になる、という特殊な事情が関係しているので、気になった方は調べてみてください。

#### 数値リテラルの正体

もう一つ、これまでの課題で触れられなかった、秘密の型クラスを明かしましょう。  
それは`Num`型クラスです。`Num`型クラスは、「足し算・かけ算・引き算が出来る」数値っぽい型をまとめています。

下記のように、適当な整数のリテラルに対してGHCiの`:t`コマンドを実行してみてください。

```haskell
ghci> :t 1
1 :: Num p => p
```

... おっと、見慣れない表記が出てきましたね。  
`Num p => p`の`Num`は`Num`型クラスのことを指しているんでしょうけども、残りの`p`やら`=>`は何を指しているのでしょうか。

まず、`p`は「型変数」を表しています。  
Haskellの世界において、型が現れるべき箇所に出てくるアルファベット小文字で始まる識別子は、すべてこの「型変数」を表しています。  
アルファベットの小文字でさえ始まっていればよく、文字ごとに異なる意味があるわけではありません。  
環境によっては、この`p`の部分が、`t`などの他のアルファベットの小文字になっているかもしれませんが、特に意味は変わらないのでご安心ください。

この型変数というのは、「何かの型」を表す変数です。  
特定の型を指しているのはなく、「任意の型」に変わりうることを表しています。

`=>`は「制約 (constraint)」を示すために使います。  
矢印`=>`の前に書かれているのが型クラスなどの制約で、後ろに書かれた型についての条件を規定する際に使います。  
`○○ => ×××`と書かれていたとき、「○○であるならば×××」とか、「○○である場合の×××」と読み替えるとわかりやすいかもしれません。

したがって、`Num p => p`という型は「`p`が`Num`型クラスのインスタンスである場合の`p`」、言い換えると、「`Num`型クラスのインスタンスである型（`p`）のうちの何か」を指しています。  
そう、`1`という整数のリテラルは、何物でもない、**「`Num`型クラスのインスタンスである何かの型」の値**でしかないのです。型がまだ決まっていないんですね！

先ほど「`Num`型クラスは、『足し算・かけ算・引き算が出来る』数値っぽい型をまとめている」と述べたとおり、足し算の演算子`+`などをメソッドとして持っています。  
そのため、`+`などの演算子で適当に計算をしてみても、やっぱり型は定まりません。

```haskell
ghci> :t 1 + 2 * 3
1 + 2 * 3 :: Num a => a
```

上記のように`:t 1 + 2 * 3`の結果も、「`Num`型クラスのインスタンスである型（`a`）のうちの何か」のままです。  
まだ型が決まっていないにもかかわらず、これまで私たちは特に型を明示することなく、HaskellでBMIやら複利計算やらを行えてきました。  
そこにはどのような仕組みが働いているのでしょうか？

それは、課題5でも少し触れた「デフォルトの型」です。  
`Num`型クラスをはじめとする一部の型クラスには、「型推論したけど型を決定することが出来なかった。でも、この型は○○の型クラスのインスタンスであることは間違いないので、デフォルトの型である××に決定してしまおう」という型が決められています。それが「デフォルトの型」です。

その挙動を確認するために、GHCの`-Wtype-defaults`という警告を有効にしましょう。  
GHCiでこの警告を有効にするには、`:set -Wtype-defaults`と入力します。

```haskell
ghci> :set -Wtype-defaults
ghci>
```

何もエラーが出ていなければ成功です。  
そのまま、適当な整数のリテラルや、整数のリテラルを使った式を入力してみてください。

```haskell
ghci> 1

<interactive>:17:1: warning: [-Wtype-defaults]
    • Defaulting the following constraints to type ‘Integer’
        (Show a0) arising from a use of ‘print’ at <interactive>:17:1
        (Num a0) arising from a use of ‘it’ at <interactive>:17:1
    • In a stmt of an interactive GHCi command: print it
1
ghci> 1 + 2 * 3

<interactive>:3:1: warning: [-Wtype-defaults]
    • Defaulting the following constraints to type ‘Integer’
        (Show a0) arising from a use of ‘print’ at <interactive>:3:1-9
        (Num a0) arising from a use of ‘it’ at <interactive>:3:1-9
    • In a stmt of an interactive GHCi command: print it
7
```

仰々しい警告の後に式の評価結果が表示されました。  
それぞれ同じ内容の警告が出ているのがわかるでしょうか？  
いずれも要約すると、「`Show`型クラスと`Num`型クラスによる制約がついた型を、デフォルトの`Integer`型に設定しました」という意味です。  
これは、`:t 1`などで確認したとおり、整数のリテラルが「`Num`型クラスのインスタンスである何かの型」の値を表しており、そのデフォルトが`Integer`型に設定されているため、表示された警告です。

それから、整数と同様に小数点を含めた数値のリテラルも特定の型の値ではなく、`Fractional`という「型クラスのインスタンスである型のうちの何か」の値となっています。  
`:t`して確かめましょう。

```haskell
ghci> :t 1.2
1.2 :: Fractional p => p
```

`Fractional`型クラスは`Num`型クラスの特徴に加えて、（結果に小数点以下の値を含みうる[^div]）割り算ができる、という特徴も備えています。割り算と聞いて多くの方がイメージするであろう、`/`を使うことができます。

[^div]: 結果が必ず整数になる割り算については、`Integral`型クラスが担います。`Integral`型クラスについてはhoge課題で取り上げる予定です。

```haskell
ghci> :t 1.2 / 3
1.2 / 3 :: Fractional a => a
ghci> 1.2 / 3

<interactive>:7:1: warning: [-Wtype-defaults]
    ? Defaulting the following constraints to type ‘Double’
        (Show a0) arising from a use of ‘print’ at <interactive>:7:1-7
        (Fractional a0) arising from a use of ‘it’ at <interactive>:7:1-7
    ? In a stmt of an interactive GHCi command: print it
0.39999999999999997
```

`1.2 / 3`の結果を見ようとすると、再び仰々しい警告の後に結果が表示されました。  
こちらは先ほど`1`とか`1 + 2 * 3`と入力したときと同じ種類の警告です。  
小数点以下を含めた数値リテラルのみを書いた場合でも、やはり同じ警告が出ます。

```haskell
ghci> 1.2

<interactive>:9:1: warning: [-Wtype-defaults]
    • Defaulting the following constraints to type ‘Double’
        (Show a0) arising from a use of ‘print’ at <interactive>:9:1-3
        (Fractional a0) arising from a use of ‘it’ at <interactive>:9:1-3
    • In a stmt of an interactive GHCi command: print it
1.2
```

数値リテラルで表される型は、他にもあります。  
この先の課題で折に触れて紹介しましょう（ちなみに、自分で定義した型を`Show`型クラスのインスタンスにするのと同じ要領で、`Num`型クラスなどのインスタンスにすれば、自分で定義した型を数値リテラルから作ることもできます！）。

## 課題の解き方

課題6で書いたソースコードをコピペしつつ、必ず`Entry`型を`deriving Show`で`Show`型クラスのインスタンスにした上で解いてください。
