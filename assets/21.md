# `IO`以外でも`do`を使う: Maybe編

コマンドラインから受け取った名前に基づいて、単純なデータベースを検索するコマンドを作りましょう。

1. コマンドライン引数のリストを取得します。
2. コマンドライン引数のリストの長さが
    1. 「1」であれば、その要素を用いて、後述する4つの連想配列から対応する要素を検索します。
        1. 4つの連想配列**すべて**に該当する要素があった場合、それらをすべて標準出力に出力します （出力形式は実行例から推測してください）。
        2. それ以外の場合、「`Not found. He/She may be shy.`」と出力します。
    2. それ以外の場合は、「`Invalid arguments: <コマンドライン引数のリスト>`」という形式のメッセージを例外としてスローし、終了します。

## 検索対象となる4つの連想配列

※[「なんちゃって個人情報」][1]というサービスで生成しました。

[1]: http://kazina.com/dummy/

好きな果物

```haskell
  [ ("aki"      , "りんご")
  , ("asami"    , "みかん")
  , ("ouga"     , "バナナ")
  , ("kazuyo"   , "桃")
  , ("kazuo"    , "ブドウ")
  , ("kimiko"   , "りんご")
  , ("ken"      , "柿")
  , ("saki"     , "パイナップル")
  , ("shunsuke" , "ブドウ")
  , ("sousuke"  , "梨")
  , ("teppei"   , "ライチ")
  , ("natsumi"  , "みかん")
  , ("masashi"  , "桃")
  , ("meibi"    , "メロン")
  , ("yu"       , "グレープフルーツ")
  , ("yuji"     , "りんご")
  , ("yoshimasa", "バナナ")
  , ("rio"      , "バナナ")
  ]
```

生年月日

```haskell
  [ ("aki"      , "1968/1/18")
  , ("asami"    , "1995/6/5")
  , ("ouga"     , "1995/9/14")
  , ("kazuyo"   , "1952/4/26")
  , ("kazuo"    , "1942/11/4")
  , ("kimiaki"  , "1970/5/17")
  , ("kimiko"   , "1988/7/31")
  , ("saki"     , "1990/3/26")
  , ("shunsuke" , "1960/11/15")
  , ("sousuke"  , "1977/1/1")
  , ("teppei"   , "1976/12/4")
  , ("natsumi"  , "1988/4/16")
  , ("masashi"  , "1954/1/28")
  , ("meibi"    , "1953/11/7")
  , ("yu"       , "1990/6/22")
  , ("yuji"     , "1989/4/16")
  , ("yoshimasa", "1992/12/6")
  , ("rio"      , "1987/12/8")
  ]
```

メールアドレス

```haskell
  [ ("aki"      , "yamane_aki@example.com")
  , ("asami"    , "ooizumi_asami@example.com")
  , ("ouga"     , "nasu_ouga@example.com")
  , ("kazuyo"   , "ezaki_kazuyo@example.com")
  , ("kimiaki"  , "tsutsui_kimiaki@example.com")
  , ("kimiko"   , "maeda_kimiko@example.com")
  , ("ken"      , "mita_ken@example.com")
  , ("saki"     , "okudera_saki@example.com")
  , ("shunsuke" , "konuma_shunsuke@example.com")
  , ("sousuke"  , "asari_sousuke@example.com")
  , ("teppei"   , "taniguchi_teppei@example.com")
  , ("natsumi"  , "komachi_natsumi@example.com")
  , ("masashi"  , "itano_masashi@example.com")
  , ("meibi"    , "shimizu_meibi@example.com")
  , ("yu"       , "matsushima_yu@example.com")
  , ("yoshimasa", "onoda_yoshimasa@example.com")
  , ("rio"      , "tsukahara_rio@example.com")
  ]
```

住んでいる都道府県

```haskell
  [ ("aki"      , "福岡県")
  , ("asami"    , "茨城県")
  , ("ouga"     , "栃木県")
  , ("kazuyo"   , "神奈川県")
  , ("kazuo"    , "神奈川県")
  , ("kimiaki"  , "岡山県")
  , ("kimiko"   , "群馬県")
  , ("ken"      , "福岡県")
  , ("saki"     , "福井県")
  , ("shunsuke" , "栃木県")
  , ("sousuke"  , "和歌山県")
  , ("teppei"   , "神奈川県")
  , ("natsumi"  , "栃木県")
  , ("masashi"  , "青森県")
  , ("meibi"    , "栃木県")
  , ("yu"       , "東京都")
  , ("yoshimasa", "三重県")
  , ("rio"      , "北海道")
  ]
```

## 実行例

すべての連想配列に対応する要素が存在する名前を指定したとき

```shell
shell> stack exec runhaskell 21.hs aki
fruit: りんご
birthday: 1968/1/18
mailAddress: yamane_aki@example.com
prefecture: 福岡県
```

いずれの連想配列にも存在しない名前を指定したとき

```shell
> stack exec runhaskell 21.hs none
Not found. He/She might be shy.
```

「誕生日」の連想配列に対応する要素が存在しない名前を指定したとき

```shell
> stack exec runhaskell 21.hs ken
Not found. He/She might be shy.
```

## 必要な知識

### 問題提起: `case`式を何度も書くのが面倒くさい

今回の課題は、（ここ最近のいくつかの課題と同様）新しい知識を学ばなくても解くことができます。  
しかし、「4つの連想配列**すべて**に該当する要素があった場合」を愚直に実装しようとすると、結構面倒なことになります。

`lookup`関数が返すのは`Maybe`型の値

```haskell
ghci> import qualified Data.Map.Strict as M
ghci> :t M.lookup
M.lookup :: Ord k => k -> M.Map k a -> Maybe a
```

```haskell
ma = Just 'a'
mb = Just 'b'
mc = Just 'c'
```

愚直に`case`式を使うと...

```
case ma of
  Just a ->
    case mb of
      Just b ->
        case mc of
          Just c ->
            putStrLn $ "Found " ++ show a ++ show b ++ show c
        Nothing ->
          putStrLn "Not found."
      Nothing ->
        putStrLn "Not found."
  Nothing ->
    putStrLn "Not found."
```

ネストがめっちゃ深い！

これまでの課題の知識を少しひねって使うなら、↓のように一旦タプルに包んでもよい

```
case (ma, mb, mc) of
  Just (a, b, c) ->
    putStrLn $ "Found " ++ show a ++ show b ++ show c
  Nothing ->
    putStrLn "Not found."
```

今回は、一旦タプルに入れる必要がない、より汎用性が高い方法を紹介します。

### 「命令」としてのMaybe

hoge
