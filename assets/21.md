# `IO`以外でも`do`を使う: Maybe編

コマンドラインから受け取った名前に基づいて、単純なデータベースを検索するコマンドを作りましょう。

1. コマンドライン引数のリストを取得します。
2. コマンドライン引数のリストの長さが
    1. 「1」であれば、その要素を用いて、後述する4つの連想配列から対応する要素を検索します。
        1. 4つの連想配列**すべて**に該当する要素があった場合、それらをすべて標準出力に出力します （出力形式は実行例から推測してください）。
        2. それ以外の場合、「`Not found. He/She may be shy.`」と出力します。
    2. それ以外の場合は、「`Invalid arguments: <コマンドライン引数のリスト>`」という形式のメッセージを例外としてスローし、終了します。

## 検索対象となる4つの連想配列

※「好きな果物」以外については[「なんちゃって個人情報」][1]というサービスで生成しました。

[1]: http://kazina.com/dummy/

好きな果物

```haskell
  [ ("aki"      , "apple")
  , ("asami"    , "orange")
  , ("ouga"     , "banana")
  , ("kazuyo"   , "peach")
  , ("kazuo"    , "grape")
  , ("kimiko"   , "apple")
  , ("ken"      , "kaki")
  , ("saki"     , "pineapple")
  , ("shunsuke" , "grape")
  , ("sousuke"  , "pear")
  , ("teppei"   , "liche")
  , ("natsumi"  , "orange")
  , ("masashi"  , "peach")
  , ("meibi"    , "melon")
  , ("yu"       , "grape fruit")
  , ("yuji"     , "apple")
  , ("yoshimasa", "banana")
  , ("rio"      , "banana")
  ]
```

生年月日

```haskell
  [ ("aki"      , "1968/1/18")
  , ("asami"    , "1995/6/5")
  , ("ouga"     , "1995/9/14")
  , ("kazuyo"   , "1952/4/26")
  , ("kazuo"    , "1942/11/4")
  , ("kimiaki"  , "1970/5/17")
  , ("kimiko"   , "1988/7/31")
  , ("saki"     , "1990/3/26")
  , ("shunsuke" , "1960/11/15")
  , ("sousuke"  , "1977/1/1")
  , ("teppei"   , "1976/12/4")
  , ("natsumi"  , "1988/4/16")
  , ("masashi"  , "1954/1/28")
  , ("meibi"    , "1953/11/7")
  , ("yu"       , "1990/6/22")
  , ("yuji"     , "1989/4/16")
  , ("yoshimasa", "1992/12/6")
  , ("rio"      , "1987/12/8")
  ]
```

メールアドレス

```haskell
  [ ("aki"      , "yamane_aki@example.com")
  , ("asami"    , "ooizumi_asami@example.com")
  , ("ouga"     , "nasu_ouga@example.com")
  , ("kazuyo"   , "ezaki_kazuyo@example.com")
  , ("kimiaki"  , "tsutsui_kimiaki@example.com")
  , ("kimiko"   , "maeda_kimiko@example.com")
  , ("ken"      , "mita_ken@example.com")
  , ("saki"     , "okudera_saki@example.com")
  , ("shunsuke" , "konuma_shunsuke@example.com")
  , ("sousuke"  , "asari_sousuke@example.com")
  , ("teppei"   , "taniguchi_teppei@example.com")
  , ("natsumi"  , "komachi_natsumi@example.com")
  , ("masashi"  , "itano_masashi@example.com")
  , ("meibi"    , "shimizu_meibi@example.com")
  , ("yu"       , "matsushima_yu@example.com")
  , ("yoshimasa", "onoda_yoshimasa@example.com")
  , ("rio"      , "tsukahara_rio@example.com")
  ]
```

住んでいる都道府県

```haskell
  [ ("aki"      , "Fukuoka")
  , ("asami"    , "Ibaraki")
  , ("ouga"     , "Tochigi")
  , ("kazuyo"   , "Kanagawa")
  , ("kazuo"    , "Kanagawa")
  , ("kimiaki"  , "Okayama")
  , ("kimiko"   , "Gunma")
  , ("ken"      , "Fukuoka")
  , ("saki"     , "Fukui")
  , ("shunsuke" , "Tochigi")
  , ("sousuke"  , "Wakayama")
  , ("teppei"   , "Kanagawa")
  , ("natsumi"  , "Tochigi")
  , ("masashi"  , "Aomori")
  , ("meibi"    , "Tochigi")
  , ("yu"       , "Tokyo")
  , ("yoshimasa", "Mie")
  , ("rio"      , "Hokkaido")
  ]
```

## 実行例

すべての連想配列に対応する要素が存在する名前を指定したとき

```shell
shell> stack exec runhaskell 21.hs aki
fruit: apple
birthday: 1968/1/18
mailAddress: yamane_aki@example.com
prefecture: Fukuoka
```

いずれの連想配列にも存在しない名前を指定したとき

```shell
> stack exec runhaskell 21.hs none
Not found. He/She might be shy.
```

「誕生日」の連想配列に対応する要素が存在しない名前を指定したとき

```shell
> stack exec runhaskell 21.hs ken
Not found. He/She might be shy.
```

## 必要な知識

### 問題提起: `case`式を何度も書くのが面倒くさい

今回の課題は、（ここ最近のいくつかの課題と同様）新しい知識を学ばなくても解くことができます。  
しかし、「4つの連想配列**すべて**に該当する要素があった場合」を愚直に実装しようとすると、結構面倒なことになります。

`lookup`関数が返すのは`Maybe`型の値

```haskell
ghci> import qualified Data.Map.Strict as M
ghci> :t M.lookup
M.lookup :: Ord k => k -> M.Map k a -> Maybe a
```

なので`Maybe`型を扱うために`case`式を扱う必要がある（課題9を思い出しましょう）

例えば以下のような`Maybe`な値があったとして、

```haskell
ghci> ma = Just 'a'
ghci> mb = Just 'b'
ghci> mc = Just 'c'
```

愚直に`case`式を使うと...

```haskell
ghci> :{
ghci| case ma of
ghci|   Just a ->
ghci|     case mb of
ghci|       Just b ->
ghci|         case mc of
ghci|           Just c ->
ghci|             putStrLn $ "Found " ++ show a ++ show b ++ show c
ghci|           Nothing ->
ghci|             putStrLn "Not found."
ghci|       Nothing ->
ghci|         putStrLn "Not found."
ghci|   Nothing ->
ghci|     putStrLn "Not found."
ghci| :}
Found 'a''b''c'
```

ネストがめっちゃ深い！

これまでの課題の知識を少しひねって使うなら、↓のように一旦タプルに包んでもよい

```haskell
ghci> :{
ghci| case (ma, mb, mc) of
ghci|   (Just a, Just b, Just c) ->
ghci|     putStrLn $ "Found " ++ show a ++ show b ++ show c
ghci|   _ ->
ghci|     putStrLn "Not found."
ghci| :}
Found 'a''b''c'
```

今回は、一旦タプルに入れる必要がない、より汎用性が高い方法を紹介します。

### `Maybe`に対して`<$>`を使う

普通に関数を適用しようとしても`Maybe`型の値を引数としてとらない関数である限りは当然エラーに。

```haskell
ghci> ma = Just 'a'

ghci> import Data.Char
ghci> toUpper ma

<interactive>:59:9: error:
    ? Couldn't match expected type ‘Char’ with actual type ‘Maybe Char’
    ? In the first argument of ‘toUpper’, namely ‘ma’
      In the expression: toUpper ma
      In an equation for ‘it’: it = toUpper ma
```

下記のように、`case`式を使って確認しなければなりません。

```haskell
case ma of
  Just a -> Just $ toUpper a
  Nothing -> Nothing
```

このように、`Maybe`型の値が`Just`か`Nothing`か確認して、`Just`だったら関数を適用しつつ、`Nothing`だったら何もしない、といった処理は、割とありふれている

Haskellは「関数を受け取る関数」も作れるので、↓のような関数を定義できる

```haskell
applyIfJust :: (a -> b) -> Maybe a -> Maybe b
applyIfJust f mx =
  case mx of
      Just a -> Just $ f a
      Nothing -> Nothing
```

```haskell
ghci> applyIfJust toUpper ma
Just 'A'
```

そしてもちろんすでにそれはある。  
それが`<$>`！

```haskell
ghci> toUpper <$> ma
Just 'A'
```

`Maybe`に対する`<$>`は、前述の`applyIfJust`と同様、

- `Just`であれば第1引数（左辺）に渡した関数を実行し、結果をまた`Just`でくるんで返す。
- `Nothing`であればそのまま`Nothing`を返す。

という動作になっております。

```haskell
ghci> toUpper <$> Just 'z'
Just 'Z'
ghci> toUpper <$> Nothing
Nothing
```

一言で言うと、`Maybe`に対する`<$>`は、「**右辺が`Just`か`Nothing`か確認**して関数を適用する」関数と言える

当然型も`applyIfJust`と同じ

```haskell
ghci> :set -XTypeApplications
ghci> :t (<$>) @Maybe
(<$>) @Maybe :: (a -> b) -> Maybe a -> Maybe b
```

### `Maybe`に対して`<*>`を使う

今回の課題のように2つ以上の`Maybe`な値があって、それを（`a -> b -> c`という型の）複数の引数を受け取る関数に渡す場合

```haskell
ghci> (++) <$> Just "foo" <*> Just "bar"
Just "foobar"
```

どれか一つでも`Nothing`を渡すと、`<*>`も`Nothing`を返す。

```haskell
ghci> (++) <$> Nothing <*> Just "bar"
Nothing
ghci> (++) <$> Just "foo" <*> Nothing
Nothing
```

型を覗いてみましょう。

```haskell
ghci> :set -XTypeApplications
ghci> :t (<*>) @Maybe
(<*>) @Maybe :: Maybe (a -> b) -> Maybe a -> Maybe b
```

案の定、`Maybe (a -> b)`と`Maybe a`を受け取ることがわかる

より詳しく動作を確認するために、`<$>`を使わずに`Maybe (a -> b)`な値を作ってみよう

```haskell
ghci> :t Just (* 2)
Just (* 2) :: Num a => Maybe (a -> a)
```

やはり、左辺か右辺どちらか一方でも`Nothing`を渡すと、そのまま`Nothing`を返す

```haskell
ghci> Just (* 2) <*> Just 5
Just 10
ghci> Nothing <*> Just 5
Nothing
ghci> Just (* 2) <*> Nothing
Nothing
```

このことから、`Maybe`に対する`<*>`は、「**左辺と右辺それぞれを続けて`Just`か`Nothing`か確認**して関数を適用する」関数と言える

### `Maybe`に対して`do`や`>>=`を使う

`Maybe`に対しても`>>=`や`=<<`、`>>`は使える

今度は型から見てみよう

```haskell
ghci> :set -XTypeApplications
ghci> :t (=<<) @Maybe
(=<<) @Maybe :: (a -> Maybe b) -> Maybe a -> Maybe b
```

`(a -> Maybe b)`な関数と、`Maybe a`な値を受け取る

`(a -> Maybe b)`の典型例といえば、課題17で紹介した[`Data.Map.Strict`モジュールの`lookup`関数](http://hackage.haskell.org/package/containers-0.6.2.1/docs/Data-Map-Strict.html#v:lookup)！

```haskell
ghci> import qualified Data.Map.Strict as M
ghci> :t M.lookup
M.lookup :: Ord k => k -> M.Map k a -> Maybe a
```

第1引数に連想配列のkeyとなる値を渡せば、後は`(a -> Maybe b)`という形の関数になる！

```haskell
ghci> :t M.lookup "key"
M.lookup "key" :: M.Map [Char] a -> Maybe a
```

引数を入れ替えても`(a -> Maybe b)`になる！

```haskell
ghci> :t (\m key -> M.lookup key m) M.empty
(\m key -> M.lookup key m) M.empty :: Ord k => k -> Maybe a
```

よくある例: `lookup`して得た結果で`lookup`したい

名前から好きな果物を引いて、果物の値段を調べる

```haskell
fruitDictionary :: M.Map String String
fruitDictionary = M.fromList
  ... -- 「検索対象となる4つの連想配列」の「好きな果物」からコピペしてください
```

```haskell
ghci> :{
ghci| priceDictionary :: M.Map String Int
ghci| priceDictionary = M.fromList
ghci|   [ ("orange"     , 98)
ghci|   , ("apple"      , 198)
ghci|   , ("grape fruit", 138)
ghci|   , ("banana"     , 258)
ghci|   , ("pineapple"  , 458)
ghci|   , ("grape"      , 398)
ghci|   , ("melon"      , 4980)
ghci|   , ("kaki"       , 198)
ghci|   , ("peach"      , 298)
ghci|   , ("pear"       , 178)
ghci|   ]
ghci| :}
```

```haskell
ghci> M.lookup "rio" fruitDictionary
Just "banana"
ghci> M.lookup "rio" fruitDictionary >>= (\fruit -> M.lookup fruit priceDictionary)
Just 258
```

liche（ライチ）は`priceDictionary`に登録していないので、teppeiさんが好きな果物の価格を調べようとしても、`Nothing`が返ってきます。

```haskell
ghci> M.lookup "teppei" fruitDictionary
Just "liche"
ghci> M.lookup "teppei" fruitDictionary >>= (\fruit -> M.lookup fruit priceDictionary)
Nothing
```

「`M.lookup`して得た結果に基づいて別の連想配列を`M.lookup`する」という処理を簡単に書けるのが伝わったでしょうか。  
さらにこれを一般化していうと、「`Maybe a`を返す関数、つまり『結果として`Just`を返したか`Nothing`を返したか確認する必要がある関数』の**結果に基づいて**、また別の『結果として`Just`を返したか`Nothing`を返したか確認する必要がある関数』を**続けて実行**するのに便利な関数」、それが`Maybe`に対する`>>=`なのです。

`>>=`や`=<<`が使えるということは、`do`記法も使うことができます。  
課題19で触れたとおり、`>>=`を使って次のように書いた式は、

```haskell
someAction >>= (\result -> anotherAction result)
```

必ず`do`記法で次のように書き換えることができるのでした。

```haskell
do
  result <- someAction
  anotherAction result
```

これは`Maybe`に対する`do`や`>>=`でも同様です。  
と、いうわけで、さっきの例を`do`で書き換えてみましょう。

```haskell
-- do で書き換える前
ghci> M.lookup "rio" fruitDictionary >>= (\fruit -> M.lookup fruit priceDictionary)
Just 258

-- do で書き換えた後
ghci> :{
ghci| do
ghci|   fruit <- M.lookup "rio" fruitDictionary
ghci|   M.lookup fruit priceDictionary
ghci| :}
Just 258
```

```haskell
-- do で書き換える前
ghci> M.lookup "teppei" fruitDictionary >>= (\fruit -> M.lookup fruit priceDictionary)
Nothing

-- do で書き換えた後
ghci> :{
ghci| do
ghci|   fruit <- M.lookup "teppei" fruitDictionary
ghci|   M.lookup fruit priceDictionary
ghci| :}
Nothing
```

やっぱり`>>=`を使った場合と同じ結果になりましたね！
`do`を`Maybe`に対して使った場合、`do`における各行の「間」で`Just`か`Nothing`か確認しているかのような振る舞いになります。  
そして、各行での結果となるアクション（上記の場合 `M.lookup ...`）の結果が`Just`か`Nothing`かを確認して`Just`であれば、続く行で変数`fruit`が使えるよう、代入します。  
この時点で代入された`fruit`は`Maybe`を剥がした、ただの`String`型の値になっている点にご注意ください。  
`fruit`を取得するために`M.lookup`を実行した後、`do`記法の各行の「間」が自動で`Just`か`Nothing`か確認してくれているので、あなたはもうそうする必要がないのです。

逆に`fruit <- M.lookup ...`の行において`M.lookup ...`が`Nothing`を返した場合、`do`は次の行は実行しないと判断し、`fruit <- ...`は後続の行や代入なんてあたかもなかったかのように無視して`do`全体を終了します。

例えば、

```haskell
ghci> :{
ghci| do
ghci|   fruit <- M.lookup "none" fruitDictionary
ghci|   M.lookup fruit priceDictionary
ghci| :}
Nothing
```

の場合、（どちらにしても`Nothing`が返ってきてしまうのでわかりづらいんですが）最初の行の`M.lookup "none" fruitDictionary`を実行した時点で`Nothing`が返されるので、その時点で`do`の実行は終了してしまいます。

### `Maybe`に対して`>>`も使う

「`do`における各行の「間」で`Just`か`Nothing`か確認している」ということをよりはっきり示すために、`Maybe`に対する`>>`も紹介しましょう。  
こちらは左辺と右辺、それぞれに`Maybe`な値を受け取り、両方が`Just`であった場合のみ、右辺の値を`Just`として返す演算子です（左辺の結果はどちらにしても無視されてしまうので、あまり頻繁に使うものではなさそうですね）。

```haskell
ghci> :t (>>) @Maybe
(>>) @Maybe :: Maybe a -> Maybe b -> Maybe b

ghci> Just 'a' >> Just 'b'
Just 'b'
ghci> Nothing >> Just 'b'
Nothing
ghci> Just 'a' >> Nothing
Nothing
ghci> Nothing >> Nothing
Nothing
```

この`>>`も`do`で書き換えることができます。  
`do`は`>>`の糖衣構文でもあるので、次のような形の任意の式は、

```haskell
someAction >> anotherAction
```

↓のように`do`で書き換えることができます。

```haskell
do
  someAction
  anotherAction
```

この書き換えを`Maybe`に対する`>>`にも適用すると、以下のように書き換えられます。

```haskell
-- do で書き換える前
ghci> Just 'a' >> Just 'b'
Just 'b'

-- do で書き換えた後
ghci> :{
ghci| do
ghci|   Just 'a'
ghci|   Just 'b'
ghci| :}
Just 'b'


-- do で書き換える前
ghci> Nothing >> Just 'b'
Nothing

-- do で書き換えた後
ghci> :{
ghci| do
ghci|   Nothing
ghci|   Just 'b'
ghci| :}
Nothing


-- do で書き換える前
ghci> Just 'a' >> Nothing
Nothing

-- do で書き換えた後
ghci> :{
ghci| do
ghci|   Just 'a'
ghci|   Nothing
ghci| :}
Nothing


-- do で書き換える前
ghci> Nothing >> Nothing
Nothing

-- do で書き換えた後
ghci> :{
ghci| do
ghci|   Nothing
ghci|   Nothing
ghci| :}
Nothing
```

`Maybe`に対する`>>`では、`>>`演算子がまず左辺の値を確認して、`Just`であれば次に右辺の値を確認します。  
一方これを`do`で書き換えたバージョンでは、最初の行で`Just 'a'`を実行した際、次の行に進む前に`Just`か`Nothing`か確認しているかのように処理します。  
`>>`のやっていることが`do`における各行の「間」でやっていることに置き換えられたのが、よくわかりますね。

### 「命令」としての`Maybe`

ここまで説明したとおり、`do`や`<$>`、`<*>`、`>>=`や`>>`といった演算子は、これまで何度も使ってきた`IO`だけでなく、`Maybe`に対しても使えます。  
これが一体どういうことなのか、より詳しく説明しましょう。

`Maybe`は`Functor`、`Applicative`、`Monad`のインスタンス

```haskell
ghci> :i Maybe
data Maybe a = Nothing | Just a         -- Defined in ‘GHC.Maybe’
instance Applicative Maybe -- Defined in ‘GHC.Base’
instance Eq a => Eq (Maybe a) -- Defined in ‘GHC.Maybe’
instance Functor Maybe -- Defined in ‘GHC.Base’
instance Monad Maybe -- Defined in ‘GHC.Base’
-- ... 以下略
```

`<$>`や`<*>`、`>>=`や`do`が使えるのは、`IO`も`Maybe`も、これら3つの型クラスのインスタンスであるためです。  
型クラスは「同じような特徴（振る舞い）を持った型を、まとめて扱えるようにする仕組み」であることを思い出してください（課題7を参照）。  
`IO`と`Maybe`が`Functor`・`Applicative`・`Monad`のインスタンスであるということは、`Functor`・`Applicative`・`Monad`それぞれの型クラスが表す、「同じような特徴（振る舞い）」があるはずです。  
それは一体なんでしょうか？

この`Functor`・`Applicative`・`Monad`における「同じような特徴（振る舞い）」は、「[計算の文脈][1]」、「文脈を伴う計算（「[関数プログラミング実践入門][2]」のp. 241より）」とか「[計算を表現する構造][3]」など様々な説明がなされていますが、ここでは「結果を持った、**命令っぽいもの**」としましょう。  
ここまで`do`の役割を説明するにあたり、主に`IO`を使用してきました。`IO`はこれまで何度もカッコ書きしてきたとおり（入出力ができる）「命令」ですから、他の「命令っぽいもの」についても、ある程度類推して理解できると私は信じているからです。  
しかし、今回学習した`Maybe`型をはじめ、一見して「命令っぽいもの」とは思えないものも、`Functor`・`Applicative`・`Monad`のインスタンスには数多くあります。そうしたものはどのように解釈すればいいでしょうか？

`Maybe`における`do`の場合「各行の『間』で`Just`か`Nothing`かどうかを確認する」のと同じように、`IO`では「各行の『間』で対応する入出力処理を実行している」と捉えてみてください。  
つまりここでいう、「命令っぽいもの」とは、`do`において「行と行の間で結果を返すために行っている何か」なのです。  
`IO`においては`putStrLn`のように標準出力に文字列を書き込んだり、`getLine`で標準入力から文字列を読み出したり、そのほかファイルやソケットの読み書きに例外のthrow/catchなど、本入門で紹介していないものも含めてありとあらゆる「純粋な関数では賄えないこと」を実行できるので、多種多様な「命令」があります。  
それに対して`Maybe`では、「`Just`か`Nothing`かどうかを確認して、次の行を実行するかどうか決める」という1種類の「命令」しかありません。  
（注意: この数え方に明確な基準があるわけではないですし、「`Maybe`における『命令』の種類は1種類だ」なんてことはどこでも合意されてません。あくまでも「`IO`に比べて`Maybe`は`do`の中でできることが限られてる」ということを伝えるための便宜だと思ってください）

そのように、`Functor`・`Applicative`・`Monad`のインスタンスである各型には、それぞれ固有の「`do`における各行の『間』で実行する『命令』」があります。  
繰り返しますがその「命令」には`Maybe`のように一見して「命令」らしからぬものが数多く存在するので、説明が難しくなりがちなのです。  
簡潔・正確・明瞭に表現できる言葉が自然言語にはないため、「命令」という言葉もあなたには不自然に聞こえるかも知れません。  
`Functor`・`Applicative`・`Monad`が表す「同じような特徴（振る舞い）」をより正確に理解するためには`Functor`則、`Applicative`則、`Monad`則というルールを知る必要があるのですが、ここではそれらの解説は控えます。  
`Functor`・`Applicative`・`Monad`を単に使用するだけでは特に知る必要はないためです。

[1]: https://kazu-yamamoto.hatenablog.jp/entry/20110413/1302683869

[2]: https://gihyo.jp/book/2016/978-4-7741-8390-9

[3]: https://ja.wikipedia.org/w/index.php?title=%E3%83%A2%E3%83%8A%E3%83%89_(%E3%83%97%E3%83%AD%E3%82%B0%E3%83%A9%E3%83%9F%E3%83%B3%E3%82%B0)&oldid=73845335

### 「命令」の混ぜ方を軽く

前節で触れたとおり、`Functor`・`Applicative`・`Monad`のインスタンスである各型には、それぞれ固有の「命令」があります。  
これらを利用する際に気をつけていただきたい点が一つあります。

それは、原則として一つの`<*>`や`>>=`・`>>`、`do`で組み合わせることができる「命令」の型は一つだけ、という制限があることです。  
例えば、下記のように`Maybe`に対する`do`を書いているところに`getLine`などの`IO`型の値を混ぜることはできません。

```haskell
ghci> :{
ghci| do
ghci|   c <- Just 'a'
ghci|   putStrLn $ "This is invalid: " ++ show c
ghci|   Just 'b'
ghci| :}

<interactive>:10:3: error:
    ? Couldn't match type ‘IO’ with ‘Maybe’
      Expected type: Maybe ()
        Actual type: IO ()
    ? In a stmt of a 'do' block:
        putStrLn $ "This is invalid: " ++ show c
      In the expression:
        do c <- Just 'a'
           putStrLn $ "This is invalid: " ++ show c
           Just 'b'
      In an equation for ‘it’:
          it
            = do c <- Just 'a'
                 putStrLn $ "This is invalid: " ++ show c
                 Just 'b'
```

エラーメッセージにあるとおり、GHCiは`putStrLn`を使った箇所について「期待する型（Expected type）は`Maybe ()`なのに、実際の型（Actual type）は`IO ()`になっている」と報告しています。  
GHCiは`do`の1行目に`c <- Just 'a'`と書いたのを見て「あっ、この`do`は`Maybe`に対する`do`だから、次の行に来るのも`Maybe`の『命令』に違いない！」と判断したため、「期待する型」を`Maybe ()`としたのです。

この注意事項は、`<*>`や`>>=`、`>>`の型定義を思い出していただけると、よくわかるでしょう。

```haskell
ghci> :t (<*>)
(<*>) :: Applicative f => f (a -> b) -> f a -> f b
ghci> :t (>>=)
(>>=) :: Monad m => m a -> (a -> m b) -> m b
ghci> :t (>>)
(>>) :: Monad m => m a -> m b -> m b
```

各演算子の型注釈において、右太い矢印`=>`の左辺で`Applicative f => ...`、`Monad m =>`などと示されている`f`や`m`がそれぞれ`Applicative`・`Monad`のインスタンスである型なのですが、いずれの演算子においても、左辺と右辺、戻り値で言及されている`f`、`m`は同じ型を指しています。  
なので、これらの演算子に渡す「命令」の型は必ず一つでないといけないのです。

当然、言語拡張の`TypeApplications`を使用して`Maybe`用の`<*>`や`>>=`、`>>`の定義を確認してみても、左辺と右辺、戻り値すべてにおいて、一貫して`Maybe`型の値（あるいは、`Maybe`型の値を返す関数）を渡さなければならないことがわかります。

```haskell
ghci> :set -XTypeApplications

ghci> :t (<*>) @Maybe
(<*>) @Maybe :: Maybe (a -> b) -> Maybe a -> Maybe b

ghci> :t (>>=) @Maybe
(>>=) @Maybe :: Maybe a -> (a -> Maybe b) -> Maybe b

ghci> :t (>>) @Maybe
(>>) @Maybe :: Maybe a -> Maybe b -> Maybe b
```

さて、複数の型による「命令」、例えば`IO`と`Maybe`を同じ`do`の中で同時に使いたくなったら、どのように書けば良いでしょうか？  
特に`IO (Maybe a)`なんて型を返す関数は、実践でもしばしば出遭います（例えば[aesonパッケージの`decodeFileStrict`関数][4]）。  
そのようなケースの解決策として、[`Compose`][5]と[`MaybeT`][6]という型があります。

[4]: http://hackage.haskell.org/package/aeson-1.4.5.0/docs/Data-Aeson.html#v:decodeFileStrict
[5]: http://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Functor-Compose.html#t:Compose
[6]: http://hackage.haskell.org/package/transformers-0.5.6.2/docs/Control-Monad-Trans-Maybe.html#t:MaybeT

`Compose`は、任意の`Functor`・`Applicative`のインスタンスである型を組み合わせて、その値に対して同じ`<$>`や`<*>`で利用できるようにする（合成する）型です。  
以下のように、hogeすると、`Compose <Functor・Applicativeのインスタンス> <Functor・Applicativeのインスタンス>`という型の値が作られます。  
...が、`IO`と`Maybe`を組み合わせた場合の`Compose`、つまり`Compose IO Maybe`の挙動は直感に反し、使いにくいのでここでは紹介は控えます。

例えば下記のような、`IO (Maybe Integer)`を返す適当な関数があったとして、

```haskell
-- 0の場合のみNothingを返し、それ以外なら整数をそのまま返す
ghci> :{
ghci| neverZero :: Integer -> IO (Maybe Integer)
ghci| neverZero 0 = do
ghci|   putStrLn "Zero given!"
ghci|   return Nothing
ghci| neverZero i = do
ghci|   putStrLn "Other number given!"
ghci|   return $ Just i
ghci| :}
```

```haskell
ghci> :t Compose (neverZero 1)
Compose (neverZero 1) :: Compose IO Maybe Integer
```

`MaybeT`は「Monad Transformer」という、「`Monad`を受け取って`Monad`を返す型hoge

（しかし残念ながら、`IO`のMonad Transformerにあたる`IOT`はありません。どうも仕様上作成できないらしいです）

`MaybeT`についての詳細は[hoge][7]をご覧ください。

[7]: hoge

hoge: 関数Monadに注意

### `Maybe`に対して`return`も使う

hoge: `Maybe`の`return`についてはここで触れる

### 課題のヒント

`<$>`も`<*>`も`>>=`も、最終的に返す値は`Maybe`な値であることに注意。  
`<$>`や`<*>`、`>>=`だけでは今回の課題は解けず、結果を利用するために必ず一度は`case`を使う必要があります。
