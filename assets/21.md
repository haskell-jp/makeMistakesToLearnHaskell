# `IO`以外でも`do`を使う: Maybe編

TODO: `>>=`も使えるようにサンプルを書き換える

コマンドラインから受け取った名前に基づいて、単純なデータベースを検索するコマンドを作りましょう。

1. コマンドライン引数のリストを取得します。
2. コマンドライン引数のリストの長さが
    1. 「1」であれば、その要素を用いて、後述する4つの連想配列から対応する要素を検索します。
        1. 4つの連想配列**すべて**に該当する要素があった場合、それらをすべて標準出力に出力します （出力形式は実行例から推測してください）。
        2. それ以外の場合、「`Not found. He/She may be shy.`」と標準出力に出力します。
    2. それ以外の場合は、「`Invalid arguments: <コマンドライン引数のリスト>`」という形式のメッセージを例外としてスローし、終了します。

## 検索対象となる4つの連想配列

※「好きな果物」以外については[「なんちゃって個人情報」][1]というサービスで生成しました。

[1]: http://kazina.com/dummy/

好きな果物

```haskell
  [ ("aki"      , "apple")
  , ("asami"    , "orange")
  , ("ouga"     , "banana")
  , ("kazuyo"   , "peach")
  , ("kazuo"    , "grape")
  , ("kimiko"   , "apple")
  , ("ken"      , "kaki")
  , ("saki"     , "pineapple")
  , ("shunsuke" , "grape")
  , ("sousuke"  , "pear")
  , ("teppei"   , "liche")
  , ("natsumi"  , "orange")
  , ("masashi"  , "peach")
  , ("meibi"    , "melon")
  , ("yu"       , "grape fruit")
  , ("yuji"     , "apple")
  , ("yoshimasa", "banana")
  , ("rio"      , "banana")
  ]
```

生年月日

```haskell
  [ ("aki"      , "1968/1/18")
  , ("asami"    , "1995/6/5")
  , ("ouga"     , "1995/9/14")
  , ("kazuyo"   , "1952/4/26")
  , ("kazuo"    , "1942/11/4")
  , ("kimiaki"  , "1970/5/17")
  , ("kimiko"   , "1988/7/31")
  , ("saki"     , "1990/3/26")
  , ("shunsuke" , "1960/11/15")
  , ("sousuke"  , "1977/1/1")
  , ("teppei"   , "1976/12/4")
  , ("natsumi"  , "1988/4/16")
  , ("masashi"  , "1954/1/28")
  , ("meibi"    , "1953/11/7")
  , ("yu"       , "1990/6/22")
  , ("yuji"     , "1989/4/16")
  , ("yoshimasa", "1992/12/6")
  , ("rio"      , "1987/12/8")
  ]
```

メールアドレス

```haskell
  [ ("aki"      , "yamane_aki@example.com")
  , ("asami"    , "ooizumi_asami@example.com")
  , ("ouga"     , "nasu_ouga@example.com")
  , ("kazuyo"   , "ezaki_kazuyo@example.com")
  , ("kimiaki"  , "tsutsui_kimiaki@example.com")
  , ("kimiko"   , "maeda_kimiko@example.com")
  , ("ken"      , "mita_ken@example.com")
  , ("saki"     , "okudera_saki@example.com")
  , ("shunsuke" , "konuma_shunsuke@example.com")
  , ("sousuke"  , "asari_sousuke@example.com")
  , ("teppei"   , "taniguchi_teppei@example.com")
  , ("natsumi"  , "komachi_natsumi@example.com")
  , ("masashi"  , "itano_masashi@example.com")
  , ("meibi"    , "shimizu_meibi@example.com")
  , ("yu"       , "matsushima_yu@example.com")
  , ("yoshimasa", "onoda_yoshimasa@example.com")
  , ("rio"      , "tsukahara_rio@example.com")
  ]
```

住んでいる都道府県

```haskell
  [ ("aki"      , "Fukuoka")
  , ("asami"    , "Ibaraki")
  , ("ouga"     , "Tochigi")
  , ("kazuo"    , "Kanagawa")
  , ("kimiaki"  , "Okayama")
  , ("kimiko"   , "Gunma")
  , ("ken"      , "Fukuoka")
  , ("saki"     , "Fukui")
  , ("shunsuke" , "Tochigi")
  , ("sousuke"  , "Wakayama")
  , ("teppei"   , "Kanagawa")
  , ("natsumi"  , "Tochigi")
  , ("masashi"  , "Aomori")
  , ("meibi"    , "Tochigi")
  , ("yu"       , "Tokyo")
  , ("yoshimasa", "Mie")
  , ("rio"      , "Hokkaido")
  ]
```

## 実行例

すべての連想配列に対応する要素が存在する名前を指定したとき

```shell
shell> stack exec runhaskell 21.hs aki
fruit: apple
birthday: 1968/1/18
mailAddress: yamane_aki@example.com
prefecture: Fukuoka
```

いずれの連想配列にも存在しない名前を指定したとき

```shell
> stack exec runhaskell 21.hs none
Not found. He/She might be shy.
```

「誕生日」の連想配列に対応する要素が存在しない名前を指定したとき

```shell
> stack exec runhaskell 21.hs ken
Not found. He/She might be shy.
```

## 必要な知識

### 問題提起: `case`式を何度も書くのが面倒くさい

今回の課題は、（ここ最近のいくつかの課題と同様）新しい知識を学ばなくても解くことができます。  
しかし、「4つの連想配列**すべて**に該当する要素があった場合」を愚直に実装しようとすると、結構面倒なことになります。

`lookup`関数が返すのは`Maybe`型の値

```haskell
ghci> import qualified Data.Map.Strict as M
ghci> :t M.lookup
M.lookup :: Ord k => k -> M.Map k a -> Maybe a
```

なので`Maybe`型を扱うために`case`式を扱う必要がある（課題9を思い出しましょう）

例えば以下のような`Maybe`な値があったとして、

```haskell
ghci> ma = Just 'a'
ghci> mb = Just 'b'
ghci> mc = Just 'c'
```

愚直に`case`式を使うと...

```haskell
ghci> :{
ghci| case ma of
ghci|   Just a ->
ghci|     case mb of
ghci|       Just b ->
ghci|         case mc of
ghci|           Just c ->
ghci|             putStrLn $ "Found " ++ show a ++ show b ++ show c
ghci|           Nothing ->
ghci|             putStrLn "Not found."
ghci|       Nothing ->
ghci|         putStrLn "Not found."
ghci|   Nothing ->
ghci|     putStrLn "Not found."
ghci| :}
Found 'a''b''c'
```

ネストがめっちゃ深い！

これまでの課題の知識を少しひねって使うなら、↓のように一旦タプルに包んでもよい

```haskell
ghci> :{
ghci| case (ma, mb, mc) of
ghci|   (Just a, Just b, Just c) ->
ghci|     putStrLn $ "Found " ++ show a ++ show b ++ show c
ghci|   _ ->
ghci|     putStrLn "Not found."
ghci| :}
Found 'a''b''c'
```

今回は、一旦タプルに入れる必要がない、より汎用性が高い方法を紹介します。

### `Maybe`に対して`<$>`を使う

普通に関数を適用しようとしても`Maybe`型の値を引数としてとらない関数である限りは当然エラーに。

```haskell
ghci> ma = Just 'a'

ghci> import Data.Char
ghci> toUpper ma

<interactive>:59:9: error:
    ? Couldn't match expected type ‘Char’ with actual type ‘Maybe Char’
    ? In the first argument of ‘toUpper’, namely ‘ma’
      In the expression: toUpper ma
      In an equation for ‘it’: it = toUpper ma
```

下記のように、`case`式を使って確認しなければなりません。

```haskell
case ma of
  Just a -> Just $ toUpper a
  Nothing -> Nothing
```

このように、`Maybe`型の値が`Just`か`Nothing`か確認して、`Just`だったら関数を適用しつつ、`Nothing`だったら何もしない、といった処理は、割とありふれている

Haskellは「関数を受け取る関数」も作れるので、↓のような関数を定義できる

```haskell
applyIfJust :: (a -> b) -> Maybe a -> Maybe b
applyIfJust f mx =
  case mx of
      Just a -> Just $ f a
      Nothing -> Nothing
```

```haskell
ghci> applyIfJust toUpper ma
Just 'A'
```

そしてもちろんすでにそれはある。  
それが`<$>`！

```haskell
ghci> toUpper <$> ma
Just 'A'
```

`Maybe`に対する`<$>`は、前述の`applyIfJust`と同様、

- `Just`であれば第1引数（左辺）に渡した関数を実行し、結果をまた`Just`でくるんで返す。
- `Nothing`であればそのまま`Nothing`を返す。

という動作になっております。

```haskell
ghci> toUpper <$> Just 'z'
Just 'Z'
ghci> toUpper <$> Nothing
Nothing
```

一言で言うと、`Maybe`に対する`<$>`は、「**右辺が`Just`か`Nothing`か確認**して関数を適用する」関数と言える

当然型も`applyIfJust`と同じ

```haskell
ghci> :set -XTypeApplications
ghci> :t (<$>) @Maybe
(<$>) @Maybe :: (a -> b) -> Maybe a -> Maybe b
```

### `Maybe`に対して`<*>`を使う

今回の課題のように2つ以上の`Maybe`な値があって、それを（`a -> b -> c`という型の）複数の引数を受け取る関数に渡す場合

```haskell
ghci> (++) <$> Just "foo" <*> Just "bar"
Just "foobar"
```

どれか一つでも`Nothing`を渡すと、`<*>`も`Nothing`を返す。

```haskell
ghci> (++) <$> Nothing <*> Just "bar"
Nothing
ghci> (++) <$> Just "foo" <*> Nothing
Nothing
```

型を覗いてみましょう。

```haskell
ghci> :set -XTypeApplications
ghci> :t (<*>) @Maybe
(<*>) @Maybe :: Maybe (a -> b) -> Maybe a -> Maybe b
```

案の定、`Maybe (a -> b)`と`Maybe a`を受け取ることがわかる

より詳しく動作を確認するために、`<$>`を使わずに`Maybe (a -> b)`な値を作ってみよう

```haskell
ghci> :t Just (* 2)
Just (* 2) :: Num a => Maybe (a -> a)
```

やはり、左辺か右辺どちらか一方でも`Nothing`を渡すと、そのまま`Nothing`を返す

```haskell
ghci> Just (* 2) <*> Just 5
Just 10
ghci> Nothing <*> Just 5
Nothing
ghci> Just (* 2) <*> Nothing
Nothing
```

このことから、`Maybe`に対する`<*>`は、「**左辺と右辺それぞれを続けて`Just`か`Nothing`か確認**して関数を適用する」関数と言える

### `Maybe`に対して`do`や`>>=`を使う

※今回の課題を解くのに必要な内容は、この手前までです。

`Maybe`に対しても`>>=`や`=<<`、`>>`は使える

今度は型から見てみよう

```haskell
ghci> :set -XTypeApplications
ghci> :t (=<<) @Maybe
(=<<) @Maybe :: (a -> Maybe b) -> Maybe a -> Maybe b
```

`(a -> Maybe b)`な関数と、`Maybe a`な値を受け取る

`(a -> Maybe b)`の典型例といえば、課題17で紹介した[`Data.Map.Strict`モジュールの`lookup`関数](http://hackage.haskell.org/package/containers-0.6.2.1/docs/Data-Map-Strict.html#v:lookup)！

```haskell
ghci> import qualified Data.Map.Strict as M
ghci> :t M.lookup
M.lookup :: Ord k => k -> M.Map k a -> Maybe a
```

第1引数に連想配列のkeyとなる値を渡せば、後は`(a -> Maybe b)`という形の関数になる！

```haskell
ghci> :t M.lookup "key"
M.lookup "key" :: M.Map [Char] a -> Maybe a
```

引数を入れ替えても`(a -> Maybe b)`になる！

```haskell
ghci> :t (\m key -> M.lookup key m) M.empty
(\m key -> M.lookup key m) M.empty :: Ord k => k -> Maybe a
```

よくある例: `lookup`して得た結果で`lookup`したい

名前から好きな果物を引いて、果物の値段を調べる

```haskell
fruitDictionary :: M.Map String String
fruitDictionary = M.fromList
  ... -- 「検索対象となる4つの連想配列」の「好きな果物」からコピペしてください
```

```haskell
ghci> :{
ghci| priceDictionary :: M.Map String Int
ghci| priceDictionary = M.fromList
ghci|   [ ("orange"     , 98)
ghci|   , ("apple"      , 198)
ghci|   , ("grape fruit", 138)
ghci|   , ("banana"     , 258)
ghci|   , ("pineapple"  , 458)
ghci|   , ("grape"      , 398)
ghci|   , ("melon"      , 4980)
ghci|   , ("kaki"       , 198)
ghci|   , ("peach"      , 298)
ghci|   , ("pear"       , 178)
ghci|   ]
ghci| :}
```

```haskell
ghci> M.lookup "rio" fruitDictionary
Just "banana"
ghci> M.lookup "rio" fruitDictionary >>= (\fruit -> M.lookup fruit priceDictionary)
Just 258
```

liche（ライチ）は`priceDictionary`に登録していないので、teppeiさんが好きな果物の価格を調べようとしても、`Nothing`が返ってきます。

```haskell
ghci> M.lookup "teppei" fruitDictionary
Just "liche"
ghci> M.lookup "teppei" fruitDictionary >>= (\fruit -> M.lookup fruit priceDictionary)
Nothing
```

「`M.lookup`して得た結果に基づいて別の連想配列を`M.lookup`する」という処理を簡単に書けるのが伝わったでしょうか。  
さらにこれを一般化していうと、「`Maybe a`を返す関数、つまり『結果として`Just`を返したか`Nothing`を返したか確認する必要がある関数』の**結果に基づいて**、また別の『結果として`Just`を返したか`Nothing`を返したか確認する必要がある関数』を**続けて実行**するのに便利な関数」、それが`Maybe`に対する`>>=`なのです。

`>>=`や`=<<`が使えるということは、`do`記法も使うことができます。  
課題19で触れたとおり、`>>=`を使って次のように書いた式は、

```haskell
someAction >>= (\result -> anotherAction result)
```

必ず`do`記法で次のように書き換えることができるのでした。

```haskell
do
  result <- someAction
  anotherAction result
```

これは`Maybe`に対する`do`や`>>=`でも同様です。  
と、いうわけで、さっきの例を`do`で書き換えてみましょう。

```haskell
-- do で書き換える前
ghci> M.lookup "rio" fruitDictionary >>= (\fruit -> M.lookup fruit priceDictionary)
Just 258

-- do で書き換えた後
ghci> :{
ghci| do
ghci|   fruit <- M.lookup "rio" fruitDictionary
ghci|   M.lookup fruit priceDictionary
ghci| :}
Just 258
```

```haskell
-- do で書き換える前
ghci> M.lookup "teppei" fruitDictionary >>= (\fruit -> M.lookup fruit priceDictionary)
Nothing

-- do で書き換えた後
ghci> :{
ghci| do
ghci|   fruit <- M.lookup "teppei" fruitDictionary
ghci|   M.lookup fruit priceDictionary
ghci| :}
Nothing
```

やっぱり`>>=`を使った場合と同じ結果になりましたね！
`do`を`Maybe`に対して使った場合、`do`における各行の「間」で`Just`か`Nothing`か確認しているような振る舞いになります。  
各行での結果となるアクション（上記の場合 `M.lookup ...`）の結果が`Just`か`Nothing`かを確認して`Just`であれば、続く行で変数`fruit`が使えるよう、代入します。  
この時点で代入された`fruit`は`Maybe`を剥がした、ただの`String`型の値になっている点にご注意ください。  
`fruit`を取得するために`M.lookup`を実行した後、`do`記法の各行の「間」が自動で`Just`か`Nothing`か確認してくれているので、あなたはもう確認する必要がないのです。

逆に`fruit <- M.lookup ...`の行において`M.lookup ...`が`Nothing`を返した場合、`do`は次の行は実行しないと判断し、`fruit <- ...`は後続の行や代入なんてあたかもなかったかのように無視して`do`全体を終了します。

例えば、

```haskell
ghci> :{
ghci| do
ghci|   fruit <- M.lookup "none" fruitDictionary
ghci|   M.lookup fruit priceDictionary
ghci| :}
Nothing
```

の場合、（どちらにしても`Nothing`が返ってきてしまうのでわかりづらいんですが）最初の行の`M.lookup "none" fruitDictionary`を実行した時点で`Nothing`が返されるので、その時点で`do`の実行は終了してしまいます。

### `Maybe`に対して`>>`も使う

「`do`における各行の『間』で`Just`か`Nothing`か確認している」ということをよりはっきり示すために、`Maybe`に対する`>>`も紹介しましょう。  
こちらは左辺と右辺、それぞれに`Maybe`な値を受け取り、両方が`Just`であった場合のみ、右辺の値を`Just`として返す演算子です（左辺の結果は`Just`であっても無視されてしまうので、あまり頻繁に使うものではなさそうですね）。

```haskell
ghci> :t (>>) @Maybe
(>>) @Maybe :: Maybe a -> Maybe b -> Maybe b

ghci> Just 'a' >> Just 'b'
Just 'b'
ghci> Nothing >> Just 'b'
Nothing
ghci> Just 'a' >> Nothing
Nothing
ghci> Nothing >> Nothing
Nothing
```

この`>>`も`do`で書き換えることができます。  
`do`は`>>`の糖衣構文でもあるので、次のような形の任意の式は、

```haskell
someAction >> anotherAction
```

↓のように`do`で書き換えることができます。

```haskell
do
  someAction
  anotherAction
```

この書き換えを`Maybe`に対する`>>`にも適用すると、以下のように書き換えられます。

```haskell
-- do で書き換える前
ghci> Just 'a' >> Just 'b'
Just 'b'

-- do で書き換えた後
ghci> :{
ghci| do
ghci|   Just 'a'
ghci|   Just 'b'
ghci| :}
Just 'b'


-- do で書き換える前
ghci> Nothing >> Just 'b'
Nothing

-- do で書き換えた後
ghci> :{
ghci| do
ghci|   Nothing
ghci|   Just 'b'
ghci| :}
Nothing


-- do で書き換える前
ghci> Just 'a' >> Nothing
Nothing

-- do で書き換えた後
ghci> :{
ghci| do
ghci|   Just 'a'
ghci|   Nothing
ghci| :}
Nothing


-- do で書き換える前
ghci> Nothing >> Nothing
Nothing

-- do で書き換えた後
ghci> :{
ghci| do
ghci|   Nothing
ghci|   Nothing
ghci| :}
Nothing
```

`Maybe`に対する`>>`では、`>>`演算子がまず左辺の値を確認して、`Just`であれば次に右辺の値を確認します。  
一方これを`do`で書き換えたバージョンでは、最初の行で`Just 'a'`を実行した際、次の行に進む前に`Just`か`Nothing`か確認しているかのように処理します。  
`>>`のやっていることが`do`における各行の「間」でやっていることに置き換えられたのが、よくわかりますね。

### 「文脈」としての`Maybe`・`IO`

ここまで説明したとおり、`do`や`<$>`、`<*>`、`>>=`や`>>`といった演算子は、これまで何度も使ってきた`IO`だけでなく、`Maybe`に対しても使えます。  
これが一体どういうことなのか、より詳しく説明しましょう。

`Maybe`は`Functor`、`Applicative`、`Monad`のインスタンス

```haskell
ghci> :i Maybe
data Maybe a = Nothing | Just a         -- Defined in ‘GHC.Maybe’
instance Applicative Maybe -- Defined in ‘GHC.Base’
instance Eq a => Eq (Maybe a) -- Defined in ‘GHC.Maybe’
instance Functor Maybe -- Defined in ‘GHC.Base’
instance Monad Maybe -- Defined in ‘GHC.Base’
-- ... 以下略
```

`IO`も同様

```haskell
ghci> :i IO
-- ... 省略
instance Applicative IO -- Defined in ‘GHC.Base’
instance Functor IO -- Defined in ‘GHC.Base’
instance Monad IO -- Defined in ‘GHC.Base’
-- ... 以下略
```

`<$>`や`<*>`、`>>=`や`do`が使えるのは、`IO`も`Maybe`も、これら3つの型クラスのインスタンスであるためです。  
型クラスは「同じような特徴（振る舞い）を持った型を、まとめて扱えるようにする仕組み」であることを思い出してください（課題7を参照）。  
`IO`と`Maybe`が`Functor`・`Applicative`・`Monad`のインスタンスであるということは、`Functor`・`Applicative`・`Monad`それぞれの型クラスが表す、「同じような特徴（振る舞い）」があるはずです。  
それは一体なんでしょうか？

この`Functor`・`Applicative`・`Monad`における「同じような特徴（振る舞い）」は、「[計算の文脈][1]」、「文脈を伴う計算（「[関数プログラミング実践入門][2]」のp. 241より）」とか「[計算を表現する構造][3]」など様々な説明がなされていますので、ここではそのうち「文脈を持った計算」としましょう。  
しかしこの手の説明では、「文脈」というこの抽象的な概念が、どういう意味なのか曖昧になりがちです。  
なのでここでは、その「文脈」について詳しく解説します。

`Maybe`における`do`の場合「各行の『間』で`Just`か`Nothing`かどうかを確認する」のと同じように、`IO`では「各行の『間』で対応する入出力処理を実行している」と捉えてみてください。

```haskell
:{
do
  putStrLn "Hello,"                -- この行から次の行までの「間」で標準出力に "Hello," と出力
  putStrLn "what's you name?"      -- この行から次の行までの「間」で標準出力に "What's you name?" と出力
  name <- getLine                  -- この行から次の行までの「間」で標準入力から文字列を取得。
  putStrLn $ "Hi, " ++ name ++ "!" -- この行から次の行までの「間」で標準出力に挨拶を出力
:}
```

つまりここでいう、「文脈」とは、`do`において「行と行の間で、計算の結果を返すために行っている何か」なのです。  
`IO`においては`putStrLn`のように標準出力に文字列を書き込んだり、`getLine`で標準入力から文字列を読み出したり、そのほかファイルやソケットの読み書きに例外のthrow/catchなど、本入門で紹介していないものも含めてありとあらゆる「純粋な関数では賄えないこと」を実行する、という多種多様な「文脈」があります。  
一方`Maybe`では、「`Just`か`Nothing`かどうかを確認して、次の行を実行するかどうか決める」という「文脈」があります。  

そのように、`Functor`・`Applicative`・`Monad`のインスタンスである各型には、それぞれ固有の「`do`における各行の『間』で処理される『文脈』」があります。  
簡潔・正確・明瞭に表現できる言葉が自然言語にはないため、「文脈」という言葉もあなたには不自然に聞こえるかも知れません。  
`Functor`・`Applicative`・`Monad`が表す「同じような特徴（振る舞い）」をより正確に理解するためには`Functor`則、`Applicative`則、`Monad`則というルールを知る必要があるのですが、一部を除き当入門ではそれらの解説は控えます。  
`Functor`・`Applicative`・`Monad`を単に使用するだけでは知る必要がないためです。

[1]: https://kazu-yamamoto.hatenablog.jp/entry/20110413/1302683869

[2]: https://gihyo.jp/book/2016/978-4-7741-8390-9

[3]: https://ja.wikipedia.org/w/index.php?title=%E3%83%A2%E3%83%8A%E3%83%89_(%E3%83%97%E3%83%AD%E3%82%B0%E3%83%A9%E3%83%9F%E3%83%B3%E3%82%B0)&oldid=73845335

### 「文脈」の混ぜ方を軽く

前節で触れたとおり、`Functor`・`Applicative`・`Monad`のインスタンスである各型には、それぞれ固有の「文脈」があります。  
これらを利用する際に気をつけていただきたい点が一つあります。

それは、原則として一つの`<*>`や`>>=`・`>>`、`do`で組み合わせることができる「文脈」の型は一つだけ、という制限があることです。  
例えば、下記のように`Maybe`に対する`do`を書いているところに`putStrLn`などの`IO`型の文脈を混ぜることはできません。

```haskell
ghci> :{
ghci| do
ghci|   c <- Just 'a'
ghci|   putStrLn $ "This is invalid: " ++ show c
ghci|   Just 'b'
ghci| :}

<interactive>:10:3: error:
    ? Couldn't match type ‘IO’ with ‘Maybe’
      Expected type: Maybe ()
        Actual type: IO ()
    ? In a stmt of a 'do' block:
        putStrLn $ "This is invalid: " ++ show c
      In the expression:
        do c <- Just 'a'
           putStrLn $ "This is invalid: " ++ show c
           Just 'b'
      In an equation for ‘it’:
          it
            = do c <- Just 'a'
                 putStrLn $ "This is invalid: " ++ show c
                 Just 'b'
```

エラーメッセージにあるとおり、GHCiは`putStrLn`を使った箇所について「期待する型（Expected type）は`Maybe ()`なのに、実際の型（Actual type）は`IO ()`になっている」と報告しています。  
GHCiは`do`の1行目に`c <- Just 'a'`と書いたのを見て「あっ、この`do`は`Maybe`に対する`do`だから、次の行に来るのも`Maybe`の『文脈』に違いない！」と判断したため、「期待する型」を`Maybe ()`としたのです。

この制限は、`<*>`や`>>=`、`>>`の型定義を思い出していただけると、よくわかるでしょう。

```haskell
ghci> :t (<*>)
(<*>) :: Applicative f => f (a -> b) -> f a -> f b
ghci> :t (>>=)
(>>=) :: Monad m => m a -> (a -> m b) -> m b
ghci> :t (>>)
(>>) :: Monad m => m a -> m b -> m b
```

各演算子の型注釈において、右太い矢印`=>`の左辺で`Applicative f => ...`、`Monad m => ...`などと示されている`f`や`m`がそれぞれ`Applicative`・`Monad`のインスタンスである型なのですが、いずれの演算子においても、左辺と右辺、戻り値で言及されている`f`、`m`は同じ型を指しています。  
なので、これらの演算子に渡す「文脈」の型は必ず一つでないといけないのです。

さて、複数の型による「文脈」、例えば`IO`と`Maybe`を同じ`do`の中で同時に使いたくなったら、どのように書けば良いでしょうか？  
特に`IO (Maybe a)`なんて型を返す関数は、実践でもしばしば出遭います（例えば[aesonパッケージの`decodeFileStrict`関数][4]）。  
そうした型の値を何度も扱う場合は、`IO a`に対する`<$>`や`>>=`などの演算子、`Maybe `に対する`<$>`や`>>=`などの演算子をバラバラに使うよりは、`IO (Maybe a)`そのものに対する`<$>`や`>>=`などの演算子を使えた方が、書きやすいでしょう。

[4]: http://hackage.haskell.org/package/aeson-1.4.5.0/docs/Data-Aeson.html#v:decodeFileStrict

例えば下記のような、`IO (Maybe Integer)`を返す適当な関数があったとして、

```haskell
-- 0の場合のみNothingを返し、それ以外なら整数をそのまま返す
ghci> :{
ghci| neverZero :: Integer -> IO (Maybe Integer)
ghci| neverZero 0 = do
ghci|   putStrLn "Zero given!"
ghci|   return Nothing
ghci| neverZero i = do
ghci|   putStrLn "Other number given!"
ghci|   return $ Just i
ghci| :}
```

次のように、単純に`<$>`と`<*>`を使用すると、型エラーになってしまいます。

```haskell
ghci> (+) <$> neverZero 1 <*> neverZero 2

<interactive>:12:1: error:
    ? No instance for (Num (Maybe Integer)) arising from a use of ‘+’
    ? In the first argument of ‘(<$>)’, namely ‘(+)’
      In the first argument of ‘(<*>)’, namely ‘(+) <$> neverZero 1’
      In the expression: (+) <$> neverZero 1 <*> neverZero 2
```

このエラーは、`(+) <$> neverZero 1`において、`<$>`が`neverZero 1`から`IO`のみを取り出すために起こるエラーです。  
`(+)`は`IO (Maybe Integer)`の中の`Integer`ではなく、`IO`の中の`Maybe Integer`の値に対して適用されようとしてしまうのです。  
`(+)`は`Num`型クラスのインスタンスである型全般に対して使えるので、`No instance for (Num (Maybe Integer)) arising from a use of ‘+’`というエラーメッセージになっております。

このようなケースの解決策として、[`MaybeT`][5]という型があります。

[5]: http://hackage.haskell.org/package/transformers-0.5.6.2/docs/Control-Monad-Trans-Maybe.html#t:MaybeT

`MaybeT`は「Monad Transformer」という、「型引数として`Monad`型クラスのインスタンスである型を受け取って、また`Monad`型クラスのインスタンスの型を返す型」の一種です。  
`Maybe`と`MaybeT`以外にも、多くの対応する「Monad Transformer」が存在し、それらは大抵`***T`と、`T`という接尾辞をつけた名前がつけられています。  
（しかし残念ながら、`IO`のMonad Transformerにあたる`IOT`はありません。どうも仕様上作成できないらしいです）

下記のように書けば、`MaybeT IO`という「入出力処理を実行した後、結果が`Just`か`Nothing`かをチェックする」文脈を持った`Monad`のインスタンスの型の値が生まれます。

```haskell
-- importをお忘れなく！
ghci> import Control.Monad.Trans.Maybe

ghci> :t MaybeT (neverZero 1)
MaybeT (neverZero 1) :: MaybeT IO Integer
```

せっかくなんで試してみましょう。

```haskell
ghci> runMaybeT $ (+) <$> MaybeT (neverZero 1) <*> MaybeT (neverZero 2)
Other number given!
Other number given!
Just 3

ghci> runMaybeT $ (+) <$> MaybeT (neverZero 0) <*> MaybeT (neverZero 2)
Zero given!
Nothing

ghci> runMaybeT $ (+) <$> MaybeT (neverZero 1) <*> MaybeT (neverZero 0)
Other number given!
Zero given!
Nothing

ghci> runMaybeT $ (+) <$> MaybeT (neverZero 0) <*> MaybeT (neverZero 0)
Zero given!
Nothing
```

逐一`MaybeT`値コンストラクターに`IO (Maybe a)`型の値を渡して、最終的な結果を得るために`runMaybeT`しないといけないところが面倒ですが、ちゃんと実行できていますね！

二つ目のサンプル、`runMaybeT $ (+) <$> MaybeT (neverZero 0) <*> MaybeT (neverZero 2)`という行に注目してください。  
出力結果として`Zero given!`と最終的な結果に当たる`Nothing`しか書かれていないことからして、`<*>`の左辺に渡した`MaybeT (neverZero 0)`が`Nothing`を返した時点で`<*>`の実行は中断され、右辺の`MaybeT (neverZero 2)`は実行するまでもなく`Nothing`が返ってきていますね！  
つまり、`MaybeT IO`の`<*>`は、左辺に渡した`MaybeT IO (a -> b)`の文脈を処理して結果が`Nothing`だったら右辺の`MaybeT IO a`の`IO`の文脈から実行しない、という実装になっているのです。便利。

`MaybeT`についてのさらなる詳細は、[Maybe と IO を一緒に使いたくなったら][6]という記事をご覧ください。

[6]: https://ryota-ka.hatenablog.com/entry/2018/05/26/193220

### `Maybe`に対して`return`も使う

ここまで、`Functor`・`Applicative`・`Monad`における「同じような特徴（振る舞い）」を「文脈を持った計算」と解釈し、その意味するところを詳しく説明しました。  
加えて、ここで忘れてはならない`Monad`の`return`についてもう一言加えておきます。

最初に当入門で`return`を紹介したのは、課題11でした。  
課題11では、`return`を「何もしないで指定した値を返すだけの『命令』」として、「命令」、すなわち`IO`型の値を`do`で組み立てる際に、主に最後の行で使用する「命令」として紹介しました。  
以下に課題11で使用した例を少し修正して再掲します。

```haskell
askUntilNonEmpty :: IO String
askUntilNonEmpty = do
    putStrLn "Enter your name:"
    string <- getLine
    case string of
        [] -> do
            putStrLn "Empty! Try again!"
            askUntilNonEmpty
        _ -> do
            putStrLn ("Thanks, " ++ string ++ " san!")
            return string -- <- ここで何もしないで返す
```

しかしながら`return`は、下記の`:t`コマンドの結果からわかるとおり、実際のところ`Monad`全般に対して使えるようになっています。

```haskell
ghci> :t return
return :: Monad m => a -> m a
```

`return`は「文脈を持った計算」における「文脈に対して何の影響も与えない処理」を指します。  
具体的には、`Monad`のインスタンスである型`m`は、任意の値`x :: a`と、該当の型の任意の値を返す関数`f :: a -> m b`、それから該当の型の任意の値`m`について、次の二組の式が**常に同じ意味**になるよう、`return`と`>>=`を実装しなければならない、というルールを持った処理です。

```haskell
return x >>= f
-- と、
f x
```

```haskell
m >>= return
-- と、
m
```

これらのルールは、いずれも「`>>=`と`return`を削除しても、意味が変わらない」ということを述べています。  
`return x >>= f`と`f x`については、ラムダ抽象を挟んで、`return x >>= (\x -> f x)`と`(\x -> f x)`に書き換えてみると、より`>>=`と`return`を削除した形であることが分かりやすくなるでしょう。

すなわち`return`は、`Monad`のインスタンスである型が表す「文脈」において、削除しても意味が変わらない、文脈に影響を与えないような処理を表しています。

これは、先ほど触れた`Monad`則の一部です。  
`IO`における`return`が「何もしないで値を返す命令」であるように、`Monad`のインスタンスである型は、自身が表す「文脈」において、「何もしないで値を返す処理」に該当する`return`を実装しておく必要があります。

さて、それでは`Maybe`型における`return`とは、一体どんな処理なのでしょう？  
これは試してみるのが一番の近道です。  
おなじみ`TypeApplications`言語拡張を使って、`Maybe`専用の`return`を作ってみましょう。

```haskell
ghci> :set -XTypeApplications
ghci> return @Maybe 'a'
Just 'a'
```

はい、単純ですね。`Just`で包んで返すだけです。
「これが本当にさっきの`Monad`則を満たすの？」と疑問に思った方は、是非試してみてください。  
参考までに、`Maybe`の`>>=`の定義を[執筆時点の最新安定版][7]から引用しておきます。

[7]: http://hackage.haskell.org/package/base-4.12.0.0/docs/src/GHC.Base.html#line-854

```haskell
instance  Monad Maybe  where
    (Just x) >>= k      = k x
    Nothing  >>= _      = Nothing

    -- ... 以下略 ...
```

※そう言えばここまで触れてませんでしたので捕捉します。`>>=`や`+`などの二項演算子を定義する際は、上記のように、中置記法そのままでパターンマッチすることができます。

### 課題のヒント

`<$>`も`<*>`も`>>=`も、最終的に返す値は`Maybe`型の値であることに注意。  
`<$>`や`<*>`、`>>=`だけでは今回の課題は解けず、結果を利用するために必ず一度は`case`を使う必要があります。
