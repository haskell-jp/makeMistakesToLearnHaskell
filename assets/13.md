# モジュールをimportする

下記の手順で、入力したMETS値・体重・運動時間から、ウォーキングした際の消費カロリーを計算するプログラムを書きましょう。

1. コマンドライン引数のリストを取得します。
2. 取得したリストの要素数が
    1. 「3」であれば、1つめの要素を「メッツ値」、2つめの要素を「体重（単位はkg）」、3つめの要素を「運動時間（単位は分）」が書かれた文字列として解釈して、消費カロリーを計算し、出力します。
    2. それ以外であれば、「`Invalid input: <入力したコマンドライン引数のリストをshowした文字列>`」という形式のメッセージを**例外としてスロー**し、終了します。

## 必要な知識

### ウォーキングによるカロリー消費量

参考: <https://keisan.casio.jp/exec/system/1161228742>

```
消費カロリー(kcal) ＝ メッツ × 体重(kg) × (運動時間(分) / 60) × 1.05
```

### モジュールを`import`する

Haskellの世界には、GHCをインストールしただけで利用できるものを始め、無数の関数・型などが公開され、簡単に利用できるようになっています。これらの関数・型はあまりにも数が多いので、「モジュール」という単位でまとめられています。私たちがこれまで出会ってきた`putStrLn`関数や`show`関数、それから`Bool`型にタプル型、といった関数・型などを除いて、ほとんどのモジュールに含まれている関数は、`import`という機能を使うことで初めて使用できるようになります。

それでは、GHCをインストールしただけで使えるようになるモジュールの一つ、`System.Environment`を`import`してみましょう。`System.Environment`には、今回の課題を解くのに必要な、コマンドライン引数を取得する関数、`getArgs`が含まれています。

```haskell
import System.Environment
```

上記のような`import`文をGHCiに入力するか、`System.Environment`を利用したいファイルの最初の方に書くと`System.Environment`モジュールが提供する関数を利用できるようになります。

### `getArgs`関数でコマンドライン引数を取得する

試しに`System.Environment`モジュールを使用して、小さなプログラムを書いてみましょう。前述の`getArgs`関数を使用して、コマンドライン引数のリストを`print`するプログラムなんていかがでしょうか:

```haskell
import System.Environment

main = do
    args <- getArgs
    print args
```

以上のとおりです。`getArgs`関数は`getLine`などと同様、「命令」として使用しなければならないので、`do`記法の中で使用し、結果を`<-`で代入する点に注意してください。

早速実行してみましょう。以下の例では上記のコードを`printArgs.hs`という名前で保存して`runhaskell`コマンドで実行しています:

```bash
# ⚠️stack でGHCをインストールした場合は、「stack exec」を頭に付けましょう！
shell> runhaskell printArgs.hs arg1 arg2 arg3
["arg1","arg2","arg3"]
```

コマンドライン引数として渡した3つの文字列`arg1`・`arg2`・`arg3`を入れたリスト`["arg1","arg2","arg3"]`を`print`関数で表示できましたね！

繰り返しになりますが、`getArgs`関数は`System.Environment`モジュールを`import`しないと使用できないので、次のように`import`を書かなかった場合は`runhaskell`で実行しようとしてもエラーになってしまうのでご注意ください:

```haskell
main = do
    args <- getArgs
    print args
```

```bash
shell> runhaskell printArgs.hs arg1 arg2 arg3

printArgs.hs:2:13: error: Variable not in scope: getArgs :: IO a0
  |
2 |     args <- getArgs
  |             ^^^^^^^
```

なお、`System.Environment`モジュールが提供する他の関数については、[こちらのドキュメント][1]をご覧ください。

[1]: https://hackage.haskell.org/package/base/docs/System-Environment.html

#### `import`するとき、使用する関数を明示する

先ほどの例では、単に`import System.Environment`と書くことで`getArgs`関数を利用できるようにしていましたが、これだけだとどのモジュールによって`getArgs`関数が使えるようになったかが分かりづらい、と感じる方もいらっしゃるでしょう。`getArgs`関数が`System.Environment`モジュールにあることを知っていれば問題ないのですが、GHCに標準でついてくるモジュールだけでも山ほどありますし、いちいち覚えてられないですよね？特に`import`するモジュールの数が増えると余計に見分けづらくなります。

そんなときは、`import System.Environment (使用したい関数や型の名前のカンマ区切りのリスト)`を書いて、使用する関数の名前を明示しましょう:

```haskell
import System.Environment (getArgs)
```

このように書くことで、使用したい関数や型の名前を明確にできるほか、明示した関数以外を使用しないことで、他に`import`したモジュールと名前が被ってしまうことを防ぐこともできます。

#### `import`しなくても利用できる: `Prelude`モジュール

ちなみに、`import`しなくても利用できる関数・データ型（例えば`show`や`read`、`+`や`*`などの演算子、`Char`型や`Integer`型などなど）については[`Prelude`というmoduleのドキュメント][2]を参照。

[2]: https://hackage.haskell.org/package/base/docs/Prelude.html

#### `stack exec runhaskell` で試す

printArgs.hsという名前で保存した場合

```
shell> stack exec runhaskell printArgs.hs a b c d e
["a","b","c","d","e"]
```

#### `stack exec ghc` で試す

```
shell> stack exec ghc printArgs.hs
[1 of 1] Compiling Main             ( printArgs.hs, printArgs.o )
Linking printArgs.exe ...
```

```
shell> ./printArgs a b c d e
["a","b","c","d","e"]
```

#### `:main`コマンドで、GHCi上でも試す

```haskell
ghci> :l printArgs.hs
Ok, one module loaded.
ghci> :main a b c d e
["a","b","c","d","e"]
```

GHCiの`:main`コマンドは、`:l`で現在ロードしているmoduleの`main`関数を簡単に呼べる関数です。  
`:l`は現在ロードしているmoduleの任意の関数を呼べるので、そのまま`main`関数を呼ぶことも出来ますが、`:main`だと引数を簡単に渡すことが出来ます。
