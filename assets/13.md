# モジュールをimportする

下記の手順で、入力したMETS値・体重・運動時間から、ウォーキングした際の消費カロリーを計算するプログラムを書きましょう。

1. コマンドライン引数のリストを取得します。
2. 取得したリストの要素数が
    1. 「3」であれば、1つめの要素を「メッツ値」、2つめの要素を「体重（単位はkg）」、3つめの要素を「運動時間（単位は分）」が書かれた文字列として解釈して、消費カロリーを計算し、出力します。
    2. それ以外であれば、「`Invalid input: <入力したコマンドライン引数のリストをshowした文字列>`」という形式のメッセージを**例外としてスロー**し、終了します。

## 必要な知識

### ウォーキングによるカロリー消費量

参考: <https://keisan.casio.jp/exec/system/1161228742>

```
消費カロリー(kcal) ＝ メッツ × 体重(kg) × (運動時間(分) / 60) × 1.05
```

### モジュールを`import`する

Haskellの世界においては、GHCをインストールしただけで利用できるものを始め、無数の関数・型などが公開され、簡単に利用できるようになっています。これらの関数・型はあまりにも数が多いので、「モジュール」という単位でまとめられています。私たちがこれまで出会ってきた`putStrLn`関数や`show`関数、それから`Bool`型にタプル型、といった関数・型などを除いて、ほとんどのモジュールに含まれている関数は、`import`という機能を使うことで初めて使用できるようになります。

それでは、GHCをインストールしただけで使えるようになるモジュールの一つ、`System.Environment`を`import`してみましょう。`System.Environment`には、今回の課題を解くのに必要な、コマンドライン引数を取得する関数、`getArgs`が含まれています。

```haskell
import System.Environment
```

上記のような`import`文をGHCiに入力するか、`System.Environment`を利用したいファイルの最初の方に書くと`System.Environment`モジュールが提供する関数を利用できるようになります。

### `getArgs`関数でコマンドライン引数を取得する

試しに`System.Environment`モジュールを使用して、小さなプログラムを書いてみましょう。前述の`getArgs`関数を使用して、コマンドライン引数のリストを`print`するプログラムなんていかがでしょうか:

```haskell
import System.Environment

main = do
    args <- getArgs
    print args
```

以上のとおりです。`getArgs`関数は`getLine`などと同様、「命令」として使用しなければならないので、`do`記法の中で使用し、結果を`<-`で代入する点に注意してください。

hoge: `do`を使わず`let`や`where`で代入した場合の例と`do`を使った例を作る

早速実行してみましょう。以下の例では上記のコードを`printArgs.hs`という名前で保存して、`runhaskell`コマンドで実行しています:

```bash
# ⚠️stack でGHCをインストールした場合は、「stack exec」を頭に付けましょう！
shell> runhaskell printArgs.hs arg1 arg2 arg3
["arg1","arg2","arg3"]
```

コマンドライン引数として渡した3つの文字列`arg1`・`arg2`・`arg3`を入れたリスト`["arg1","arg2","arg3"]`を`print`関数で表示できましたね！

繰り返しになりますが、`getArgs`関数は`System.Environment`モジュールを`import`しないと使用できないので、次のように`import`を書かなかった場合は`runhaskell`で実行しようとしてもエラーになってしまうのでご注意ください:

```haskell
main = do
    args <- getArgs
    print args
```

```bash
shell> runhaskell printArgs.hs arg1 arg2 arg3

printArgs.hs:2:13: error: Variable not in scope: getArgs :: IO a0
  |
2 |     args <- getArgs
  |             ^^^^^^^
```

なお、`System.Environment`モジュールが提供する他の関数については、[こちらのドキュメント][1]をご覧ください。

[1]: https://hackage.haskell.org/package/base/docs/System-Environment.html

#### `import`するとき、使用する関数や型を明示する

先ほどの例では、単に`import System.Environment`と書くことで`getArgs`関数を利用できるようにしていましたが、これだけだとどのモジュールによって`getArgs`関数が使えるようになったかが分かりづらい、と感じる方もいらっしゃるでしょう。`getArgs`関数が`System.Environment`モジュールにあることを知っていれば問題ないのですが、GHCに標準でついてくるモジュールだけでも山ほどありますし、いちいち覚えてられないですよね？特に`import`するモジュールの数が増えると余計に見分けづらくなります。

そんなときは、`import System.Environment (使用したい関数や型の名前のカンマ区切りのリスト)`を書いて、使用する関数の名前を明示しましょう:

```haskell
import System.Environment (getArgs)
```

このように書くことで、使用したい関数や型の名前を明確にできるほか、明示した関数以外を使用しないことで、他に`import`したモジュールと名前が被ってしまうことを防ぐこともできます。

#### `import`しなくても利用できる: `Prelude`モジュール

ちなみに、`import`しなくても利用できる関数・型（例えば`show`や`read`、`+`や`*`などの演算子、`Char`型や`Integer`型などなど）は、すべて`Prelude`というモジュールに定義されています。どんなものがあるのか、ぜひ[ドキュメント][2]をチェックしてみてください。

[2]: https://hackage.haskell.org/package/base/docs/Prelude.html

### コマンドライン引数を渡して試す

ここまでで、コマンドライン引数をHaskellのプログラムにおいて取得する方法を紹介しました。ここからは、実際にコマンドライン引数をプログラムにどう渡すのか、についても紹介します。原則として他のコマンドラインアプリケーションと変わらないので、軽く流します。ついでに、Haskell製のプログラムを実行する方法について、ここまで紹介してこなかった方法も併せて紹介します。

#### `runhaskell` で試す

前述の、「コマンドライン引数を`print`するプログラム」のソースコードをprintArgs.hsという名前で保存したとします。課題hoge(1?)で学習した`runhaskell`コマンドを使った場合、コマンドライン引数は次のように渡します:

```
# stackでGHCをインストールした場合は「stack exec」を頭に付けるのを忘れずに！
shell> runhaskell printArgs.hs a b c d e
["a","b","c","d","e"]
```

単純に`runhaskell <ソースコードのファイル名>`に続けて空白で区切ったコマンドライン引数を渡すだけですね。

#### `ghc` で試す

Make Mistakes to Learn Haskellではこれまで、`runhaskell`コマンドや`ghci`コマンドといった、Haskellのソースコードを直接読んで実行する方法しか紹介しておりませんでした。しかしGHCは「Glasgow Haskell *Compiler*」と銘打っているとおり、本来はソースコードを事前に実行ファイルにコンパイルする為のプログラムです。と、いうわけで、次のように`ghc`コマンドを使ってコンパイルしたいソースコードのファイルを渡すと、拡張子の`.hs`を取り除いた名前で実行ファイルを作ってくれます:

```
# しつこいようですがstackでGHCをインストールした場合は「stack exec」を頭に付けるのを忘れずに！
shell> ghc printArgs.hs
[1 of 1] Compiling Main             ( printArgs.hs, printArgs.o )
Linking printArgs ...
shell>
```

`Linking printArgs ...`と表示された後、思いのほか時間がかかりますがご心配なく（もちろんコンピューターの性能にも寄りますがおおよそ十数秒くらい？）。

`ls`コマンドでもちゃんと`printArgs`という名前の実行ファイルができているのが分かります:

```
# Windowsでは拡張子 .exe がつくので注意！
shell> ls printArgs
printArgs
```

そしたら、完成した実行ファイルの名前を指定して、コマンドライン引数を渡しつつ実行してみましょう。特に他のコマンドと変わりません:

```
shell> ./printArgs a b c d e
["a","b","c","d","e"]
```

#### `:main`コマンドで、GHCi上でも試す

課題hoge(?10)で紹介したとおり、GHCiの`:l`コマンドを使うと、Haskellのソースコードが書かれたファイルを読んで、中で定義された関数を呼び、その結果を簡単に確認することができます。これは`main`関数とて例外ではなく、`:l`で前述の`printArgs.hs`を読めば、`main`関数を呼べるようになります:

```haskell
ghci> :l printArgs.hs
Ok, one module loaded.
ghci> main
[]
```

単に`main`と実行しただけなのでコマンドライン引数がセットされず、空のリスト`[]`が`print`されました。ではこの状態でコマンドライン引数を渡すにはどうすればいいでしょう？

単に`main`関数に文字列を渡してみても、うまく行きません:

```haskell
ghci> main "a"

<interactive>:3:1: error:
    ? Couldn't match expected type ‘[Char] -> t’
                  with actual type ‘IO ()’
    ? The function ‘main’ is applied to one argument,
      but its type ‘IO ()’ has none
      In the expression: main "a"
      In an equation for ‘it’: it = main "a"
    ? Relevant bindings include it :: t (bound at <interactive>:3:1)
```

エラーメッセージに`with actual type ‘IO ()’`とあるとおり、あくまで`main`関数は`IO ()`という型の関数なので引数を受け取ることができないのです。引数を受け取るのなら、`putStrLn`などのように`String -> IO ()`といった型になっているべきでしょう。

そこで活躍するのがGHCiの`:main`コマンドです（GHCiの特別なコマンドはすべてコロン `:` で始まるので`:main`です）。

普通のコマンドにコマンドライン引数を渡すのと同じ要領で、`:main`コマンドにコマンドライン引数を渡してみましょう:

```haskell
ghci> :main a b c d e
["a","b","c","d","e"]
```

ちゃんと`:main`コマンドで指定した文字列が、コマンドライン引数として渡っているようですね！

以上のとおりGHCiの`:main`コマンドを使えば、`:l`で現在ロードしているモジュールの`main`関数を、簡単にコマンドライン引数付きで呼ぶことができます。
